package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"strings"

	"github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk"
	lrzxLXR "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/base/custom/dhcpoptions"
	mCcgFKg "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dhcprelay"
	tOChZgD "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dhcprelay/option82"
	jGvcCTz "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dhcpserver"
	xygFTDt "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/iprange"
	eXzfzFj "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/lan/network/ipv4/config"
	xXKbjbR "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/lan/network/ipv6/config"
	yjUyRcw "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/lannetwork/screen/v3/n3"
	yKYCDSK "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/static/mapping"
	wHGMtfb "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/services/sdwan/v33/api/sites/siteid/lannetworks"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Data source (listing).
var (
	_ datasource.DataSource              = &lanNetworkListDataSource{}
	_ datasource.DataSourceWithConfigure = &lanNetworkListDataSource{}
)

func NewLanNetworkListDataSource() datasource.DataSource {
	return &lanNetworkListDataSource{}
}

type lanNetworkListDataSource struct {
	client *sdwan.Client
}

// lanNetworkListDsModel is the model.
type lanNetworkListDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	SiteId types.String `tfsdk:"site_id"`

	// Output.
	Items      []lanNetworkListDsModel_yjUyRcw_Config `tfsdk:"items"`
	TotalItems types.Int64                            `tfsdk:"total_items"`
}

type lanNetworkListDsModel_yjUyRcw_Config struct {
	Description      types.String                          `tfsdk:"description"`
	Etag             types.Int64                           `tfsdk:"etag"`
	Id               types.String                          `tfsdk:"id"`
	Ipv4Config       *lanNetworkListDsModel_eXzfzFj_Config `tfsdk:"ipv4_config"`
	Ipv6Config       *lanNetworkListDsModel_xXKbjbR_Config `tfsdk:"ipv6_config"`
	Name             types.String                          `tfsdk:"name"`
	NetworkContextId types.String                          `tfsdk:"network_context_id"`
	Scope            types.String                          `tfsdk:"scope"`
	Tags             types.List                            `tfsdk:"tags"`
	VrfContextId     types.String                          `tfsdk:"vrf_context_id"`
}

type lanNetworkListDsModel_eXzfzFj_Config struct {
	DefaultRouters types.List                            `tfsdk:"default_routers"`
	DhcpRelay      *lanNetworkListDsModel_mCcgFKg_Config `tfsdk:"dhcp_relay"`
	DhcpServer     *lanNetworkListDsModel_jGvcCTz_Config `tfsdk:"dhcp_server"`
	Prefixes       types.List                            `tfsdk:"prefixes"`
}

type lanNetworkListDsModel_mCcgFKg_Config struct {
	Enabled         types.Bool                            `tfsdk:"enabled"`
	Option82        *lanNetworkListDsModel_tOChZgD_Config `tfsdk:"option_82"`
	ServerIps       types.List                            `tfsdk:"server_ips"`
	SourceInterface types.String                          `tfsdk:"source_interface"`
}

type lanNetworkListDsModel_tOChZgD_Config struct {
	CircuitId          types.String `tfsdk:"circuit_id"`
	Enabled            types.Bool   `tfsdk:"enabled"`
	ReforwardingPolicy types.String `tfsdk:"reforwarding_policy"`
	RemoteId           types.String `tfsdk:"remote_id"`
}

type lanNetworkListDsModel_jGvcCTz_Config struct {
	BroadcastAddress types.String                           `tfsdk:"broadcast_address"`
	CustomOptions    []lanNetworkListDsModel_lrzxLXR_Config `tfsdk:"custom_options"`
	DefaultLeaseTime types.Int64                            `tfsdk:"default_lease_time"`
	Description      types.String                           `tfsdk:"description"`
	Disabled         types.Bool                             `tfsdk:"disabled"`
	DnsServers       types.List                             `tfsdk:"dns_servers"`
	DomainName       types.String                           `tfsdk:"domain_name"`
	Gateway          types.String                           `tfsdk:"gateway"`
	Id               types.String                           `tfsdk:"id"`
	IpRanges         []lanNetworkListDsModel_xygFTDt_Config `tfsdk:"ip_ranges"`
	MaxLeaseTime     types.Int64                            `tfsdk:"max_lease_time"`
	NetworkContextId types.String                           `tfsdk:"network_context_id"`
	StaticMappings   []lanNetworkListDsModel_yKYCDSK_Config `tfsdk:"static_mappings"`
	Subnet           types.String                           `tfsdk:"subnet"`
	Tags             types.List                             `tfsdk:"tags"`
}

type lanNetworkListDsModel_lrzxLXR_Config struct {
	OptionDefinition types.String `tfsdk:"option_definition"`
	OptionValue      types.String `tfsdk:"option_value"`
}

type lanNetworkListDsModel_xygFTDt_Config struct {
	EndIp   types.String `tfsdk:"end_ip"`
	StartIp types.String `tfsdk:"start_ip"`
}

type lanNetworkListDsModel_yKYCDSK_Config struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Mac       types.String `tfsdk:"mac"`
	Name      types.String `tfsdk:"name"`
}

type lanNetworkListDsModel_xXKbjbR_Config struct {
	DefaultRouters types.List `tfsdk:"default_routers"`
	Prefixes       types.List `tfsdk:"prefixes"`
}

// Metadata returns the data source type name.
func (d *lanNetworkListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_lan_network_list"
}

// Schema defines the schema for this listing data source.
func (d *lanNetworkListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a listing of config items.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"site_id":true} outputs:map[string]bool{"items":true, "tfid":true, "total_items":true} forceNew:map[string]bool{"site_id":true}
			"items": dsschema.ListNestedAttribute{
				Description: "The Items param.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"description":true, "etag":true, "id":true, "ipv4_config":true, "ipv6_config":true, "name":true, "network_context_id":true, "scope":true, "tags":true, "vrf_context_id":true} forceNew:map[string]bool(nil)
						"description": dsschema.StringAttribute{
							Description: "Description: Size(max = 1024, error = DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds limit, min = 0) .",
							Computed:    true,
						},
						"etag": dsschema.Int64Attribute{
							Description: "Entity tag for the resource.",
							Computed:    true,
						},
						"id": dsschema.StringAttribute{
							Description: "Id.",
							Computed:    true,
						},
						"ipv4_config": dsschema.SingleNestedAttribute{
							Description: "The Ipv4Config param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"default_routers":true, "dhcp_relay":true, "dhcp_server":true, "prefixes":true} forceNew:map[string]bool(nil)
								"default_routers": dsschema.ListAttribute{
									Description: "Default Routers: ListIPAddress(bcast = DENY, listMaxSize = 0, error = LAN_CONFIG_INVALID_DEFAULT_ROUTERS: Invalid ip for default routers., required = false, type = IPCIDR_32) .",
									Computed:    true,
									ElementType: types.StringType,
								},
								"dhcp_relay": dsschema.SingleNestedAttribute{
									Description: "The DhcpRelay param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} forceNew:map[string]bool(nil)
										"enabled": dsschema.BoolAttribute{
											Description: "Enabled.",
											Computed:    true,
										},
										"option_82": dsschema.SingleNestedAttribute{
											Description: "The Option82 param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} forceNew:map[string]bool(nil)
												"circuit_id": dsschema.StringAttribute{
													Description: "Circuit Id: Size(max = 255, error = DHCPRELAY_CIRCUIT_ID_EXCEEDS_LIMIT: Option 82 Circuid ID exceeds maximum length, min = 0) .",
													Computed:    true,
												},
												"enabled": dsschema.BoolAttribute{
													Description: "Enabled.",
													Computed:    true,
												},
												"reforwarding_policy": dsschema.StringAttribute{
													Description: "Reforwarding Policy: ValidateEnum(enumClass = classOf[DHCPRelayReforwardingPolicy], error = INVALID_DHCP_RELAY_REFWDING_POLICY: Option 82 invalid reforwarding policy, nullAllowed = false) . String must be one of these: `\"REPLACE\"`, `\"KEEP\"`, `\"APPEND\"`, `\"DROP\"`.",
													Computed:    true,
												},
												"remote_id": dsschema.StringAttribute{
													Description: "Remote Id: Size(max = 255, error = DHCPRELAY_REMOTE_ID_EXCEEDS_LIMIT: Option 82 Remote ID exceeds maximum length, min = 0) .",
													Computed:    true,
												},
											},
										},
										"server_ips": dsschema.ListAttribute{
											Description: "Server Ips: ListIPAddress(bcast = DENY, listMaxSize = 0, error = INTERFACE_CONFIG_INVALID_DHCP_RELAY_LIST: DHCP Servers IP specified in the list are invalid, required = true, type = IP) Size(max = 16, error = INTERFACE_CONFIG_DHCP_RELAY_LIST_EXCEEDS_LIMIT: DHCP Servers specified in the list exceeds maximum limit, min = 0) .",
											Computed:    true,
											ElementType: types.StringType,
										},
										"source_interface": dsschema.StringAttribute{
											Description: "Source Interface.",
											Computed:    true,
										},
									},
								},
								"dhcp_server": dsschema.SingleNestedAttribute{
									Description: "The DhcpServer param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true} forceNew:map[string]bool(nil)
										"broadcast_address": dsschema.StringAttribute{
											Description: "Broadcast Address.",
											Computed:    true,
										},
										"custom_options": dsschema.ListNestedAttribute{
											Description: "Custom Options: Valid .",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"option_definition":true, "option_value":true} forceNew:map[string]bool(nil)
													"option_definition": dsschema.StringAttribute{
														Description: "Option Definition: NotEmpty(groups = [classOf[Definition]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_DEF_UNSUPPORTED: Custom option definition is not supported) Size(groups = [classOf[Definition]], max = 1024, error = DHCPSERVER_CONFIG_OPTION_DEF_EXCEEDS_LIMIT: Custom option definition length exceeeds maximum limit, min = 0) .",
														Computed:    true,
													},
													"option_value": dsschema.StringAttribute{
														Description: "Option Value: NotEmpty(groups = [classOf[Value]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_VAL_UNSUPPORTED: Custom option value is not supported) Size(groups = [classOf[Value]], max = 8192, error = DHCPSERVER_CONFIG_OPTION_VAL_EXCEEDS_LIMIT: Custom option value length exceeds maximum limit, min = 0) .",
														Computed:    true,
													},
												},
											},
										},
										"default_lease_time": dsschema.Int64Attribute{
											Description: "Default Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
											Computed:    true,
										},
										"description": dsschema.StringAttribute{
											Description: "Description: Size(max = 256, error = DHCPSERVER_CONFIG_DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds the maximum limit., min = 0) .",
											Computed:    true,
										},
										"disabled": dsschema.BoolAttribute{
											Description: "Disabled.",
											Computed:    true,
										},
										"dns_servers": dsschema.ListAttribute{
											Description: "Dns Servers: Size(max = 3, error = DHCPSERVER_CONFIG_DNS_ENTRIES_EXCEEDS_LIMIT: Name servers count exceeds the maximum limit, min = 0) .",
											Computed:    true,
											ElementType: types.StringType,
										},
										"domain_name": dsschema.StringAttribute{
											Description: "Domain Name: Size(max = 256, error = DHCPSERVER_CONFIG_INVALID_DOMAIN_NAME: Domain name exceeds the maximum limit., min = 0) .",
											Computed:    true,
										},
										"gateway": dsschema.StringAttribute{
											Description: "Gateway.",
											Computed:    true,
										},
										"id": dsschema.StringAttribute{
											Description: "Id.",
											Computed:    true,
										},
										"ip_ranges": dsschema.ListNestedAttribute{
											Description: "Ip Ranges: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) Size(max = 2147483647, error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet., min = 1) Valid .",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"end_ip":true, "start_ip":true} forceNew:map[string]bool(nil)
													"end_ip": dsschema.StringAttribute{
														Description: "End Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
														Computed:    true,
													},
													"start_ip": dsschema.StringAttribute{
														Description: "Start Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
														Computed:    true,
													},
												},
											},
										},
										"max_lease_time": dsschema.Int64Attribute{
											Description: "Max Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
											Computed:    true,
										},
										"network_context_id": dsschema.StringAttribute{
											Description: "Network Context Id: Digits(fraction = 0, integer = 50, error = INVALID_NETWORK_CTX_ID: Invalid network ctrx id.) .",
											Computed:    true,
										},
										"static_mappings": dsschema.ListNestedAttribute{
											Description: "Static Mappings: Valid .",
											Computed:    true,
											NestedObject: dsschema.NestedAttributeObject{
												Attributes: map[string]dsschema.Attribute{
													// inputs:map[string]bool{} outputs:map[string]bool{"ip_address":true, "mac":true, "name":true} forceNew:map[string]bool(nil)
													"ip_address": dsschema.StringAttribute{
														Description: "Ip Address: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) .",
														Computed:    true,
													},
													"mac": dsschema.StringAttribute{
														Description: "Mac: MACAddressFiveColons(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_MAC_ADDR: Invalid mac address provided for static mapping) .",
														Computed:    true,
													},
													"name": dsschema.StringAttribute{
														Description: "Name: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) Size(max = 256, error = DHCPSERVER_CONFIG_STATIC_MAPPING_NAME_EXCEEDS_LIMIT: Static Mapping name execeeds the maximum limit, min = 0) Pattern(error = DHCPSERVER_CONFIG_STATIC_MAPPING_UNSUPPORTED_NAME: Provide valid static mapping name, regexp = ^[a-zA-Z0-9]+(([a-zA-Z0-9\\\\-_])|(\\\\.?[a-zA-Z0-9\\\\-]))*\\\\.?$) .",
														Computed:    true,
													},
												},
											},
										},
										"subnet": dsschema.StringAttribute{
											Description: "Subnet: NotNull(error = DHCPSERVER_CONFIG_INVALID_SUBNET_ADDR: Invalid IPv4 subnet address.) .",
											Computed:    true,
										},
										"tags": dsschema.ListAttribute{
											Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = DHCPSERVER_CONFIG_INVALID_TAGS: Tags config is invalid- maximum 10 tags are supported, tag should not exceed maximum limit of 128 characters, it should not have duplicates., noTrim = false, regex = [^,\\\\s]+, required = false) .",
											Computed:    true,
											ElementType: types.StringType,
										},
									},
								},
								"prefixes": dsschema.ListAttribute{
									Description: "Prefixes: ListIPAddress(bcast = DENY, listMaxSize = 0, error = LAN_CONFIG_INVALID_PREFIX: Invalid prefix ip., required = false, type = PREFIXCIDR_32) .",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
						"ipv6_config": dsschema.SingleNestedAttribute{
							Description: "The Ipv6Config param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"default_routers":true, "prefixes":true} forceNew:map[string]bool(nil)
								"default_routers": dsschema.ListAttribute{
									Description: "Default Routers: ListIPv6Address(bcast = DENY, listMaxSize = 0, message = LAN_CONFIG_V6_INVALID_DEFAULT_ROUTERS, required = false, type = IPCIDR_128) .",
									Computed:    true,
									ElementType: types.StringType,
								},
								"prefixes": dsschema.ListAttribute{
									Description: "Prefixes: ListIPv6Address(bcast = DENY, listMaxSize = 0, message = LAN_CONFIG_INVALID_PREFIX_V6, required = false, type = GATEWAYCIDRV6) .",
									Computed:    true,
									ElementType: types.StringType,
								},
							},
						},
						"name": dsschema.StringAttribute{
							Description: "Name: Required(error = NAME_REQD: Please provide resource name.) Size(max = 128, error = NAME_EXCEEDS_LIMIT: Name of the resource exceeds limit., min = 0) .",
							Computed:    true,
						},
						"network_context_id": dsschema.StringAttribute{
							Description: "Network Context Id: Digits(fraction = 0, integer = 30, error = INVALID_NETWORK_CONTEXT_ID: Specified network context is invalid.) .",
							Computed:    true,
						},
						"scope": dsschema.StringAttribute{
							Description: "Scope: ValidateEnum(enumClass = classOf[NetworkScope], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"GLOBAL\"`, `\"LOCAL\"`.",
							Computed:    true,
						},
						"tags": dsschema.ListAttribute{
							Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 1024, listMaxSize = 10, error = INVALID_TAG: Maximum 10 Unique tags of length 1024 each are allowed, noTrim = false, regex = [^,\\\\s]+, required = false) .",
							Computed:    true,
							ElementType: types.StringType,
						},
						"vrf_context_id": dsschema.StringAttribute{
							Description: "Vrf Context Id.",
							Computed:    true,
						},
					},
				},
			},
			"site_id": dsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"total_items": dsschema.Int64Attribute{
				Description: "The TotalItems param.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *lanNetworkListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*sdwan.Client)
}

// Read performs Read for the struct.
func (d *lanNetworkListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state lanNetworkListDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source listing", map[string]any{
		"data_source_name":            "prismasdwan_lan_network_list",
		"terraform_provider_function": "Read",
		"site_id":                     state.SiteId.ValueString(),
	})

	// Prepare to run the command.
	svc := wHGMtfb.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := wHGMtfb.ListInput{}

	input.SiteId = StringValue(state.SiteId)

	// Perform the operation.
	ans, err := svc.List(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error getting listing", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if len(ans.Items) == 0 {
		state.Items = nil
	} else {
		state.Items = make([]lanNetworkListDsModel_yjUyRcw_Config, 0, len(ans.Items))
		for _, var0 := range ans.Items {
			var1 := lanNetworkListDsModel_yjUyRcw_Config{}

			var1.Description = types.StringPointerValue(var0.Description)

			var1.Etag = types.Int64PointerValue(var0.Etag)

			var1.Id = types.StringPointerValue(var0.Id)

			if var0.Ipv4Config == nil {
				var1.Ipv4Config = nil
			} else {
				var1.Ipv4Config = &lanNetworkListDsModel_eXzfzFj_Config{}

				var2, var3 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.DefaultRouters)
				var1.Ipv4Config.DefaultRouters = var2
				resp.Diagnostics.Append(var3.Errors()...)

				if var0.Ipv4Config.DhcpRelay == nil {
					var1.Ipv4Config.DhcpRelay = nil
				} else {
					var1.Ipv4Config.DhcpRelay = &lanNetworkListDsModel_mCcgFKg_Config{}

					var1.Ipv4Config.DhcpRelay.Enabled = types.BoolPointerValue(var0.Ipv4Config.DhcpRelay.Enabled)

					if var0.Ipv4Config.DhcpRelay.Option82 == nil {
						var1.Ipv4Config.DhcpRelay.Option82 = nil
					} else {
						var1.Ipv4Config.DhcpRelay.Option82 = &lanNetworkListDsModel_tOChZgD_Config{}

						var1.Ipv4Config.DhcpRelay.Option82.CircuitId = types.StringPointerValue(var0.Ipv4Config.DhcpRelay.Option82.CircuitId)

						var1.Ipv4Config.DhcpRelay.Option82.Enabled = types.BoolPointerValue(var0.Ipv4Config.DhcpRelay.Option82.Enabled)

						var1.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(var0.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

						var1.Ipv4Config.DhcpRelay.Option82.RemoteId = types.StringPointerValue(var0.Ipv4Config.DhcpRelay.Option82.RemoteId)
					}

					var4, var5 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.DhcpRelay.ServerIps)
					var1.Ipv4Config.DhcpRelay.ServerIps = var4
					resp.Diagnostics.Append(var5.Errors()...)

					var1.Ipv4Config.DhcpRelay.SourceInterface = types.StringPointerValue(var0.Ipv4Config.DhcpRelay.SourceInterface)
				}

				if var0.Ipv4Config.DhcpServer == nil {
					var1.Ipv4Config.DhcpServer = nil
				} else {
					var1.Ipv4Config.DhcpServer = &lanNetworkListDsModel_jGvcCTz_Config{}

					var1.Ipv4Config.DhcpServer.BroadcastAddress = types.StringPointerValue(var0.Ipv4Config.DhcpServer.BroadcastAddress)

					if len(var0.Ipv4Config.DhcpServer.CustomOptions) == 0 {
						var1.Ipv4Config.DhcpServer.CustomOptions = nil
					} else {
						var1.Ipv4Config.DhcpServer.CustomOptions = make([]lanNetworkListDsModel_lrzxLXR_Config, 0, len(var0.Ipv4Config.DhcpServer.CustomOptions))
						for _, var6 := range var0.Ipv4Config.DhcpServer.CustomOptions {
							var7 := lanNetworkListDsModel_lrzxLXR_Config{}

							var7.OptionDefinition = types.StringValue(var6.OptionDefinition)

							var7.OptionValue = types.StringValue(var6.OptionValue)
							var1.Ipv4Config.DhcpServer.CustomOptions = append(var1.Ipv4Config.DhcpServer.CustomOptions, var7)
						}
					}

					var1.Ipv4Config.DhcpServer.DefaultLeaseTime = types.Int64PointerValue(var0.Ipv4Config.DhcpServer.DefaultLeaseTime)

					var1.Ipv4Config.DhcpServer.Description = types.StringPointerValue(var0.Ipv4Config.DhcpServer.Description)

					var1.Ipv4Config.DhcpServer.Disabled = types.BoolPointerValue(var0.Ipv4Config.DhcpServer.Disabled)

					var8, var9 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.DhcpServer.DnsServers)
					var1.Ipv4Config.DhcpServer.DnsServers = var8
					resp.Diagnostics.Append(var9.Errors()...)

					var1.Ipv4Config.DhcpServer.DomainName = types.StringPointerValue(var0.Ipv4Config.DhcpServer.DomainName)

					var1.Ipv4Config.DhcpServer.Gateway = types.StringPointerValue(var0.Ipv4Config.DhcpServer.Gateway)

					var1.Ipv4Config.DhcpServer.Id = types.StringPointerValue(var0.Ipv4Config.DhcpServer.Id)

					if len(var0.Ipv4Config.DhcpServer.IpRanges) == 0 {
						var1.Ipv4Config.DhcpServer.IpRanges = nil
					} else {
						var1.Ipv4Config.DhcpServer.IpRanges = make([]lanNetworkListDsModel_xygFTDt_Config, 0, len(var0.Ipv4Config.DhcpServer.IpRanges))
						for _, var10 := range var0.Ipv4Config.DhcpServer.IpRanges {
							var11 := lanNetworkListDsModel_xygFTDt_Config{}

							var11.EndIp = types.StringValue(var10.EndIp)

							var11.StartIp = types.StringValue(var10.StartIp)
							var1.Ipv4Config.DhcpServer.IpRanges = append(var1.Ipv4Config.DhcpServer.IpRanges, var11)
						}
					}

					var1.Ipv4Config.DhcpServer.MaxLeaseTime = types.Int64PointerValue(var0.Ipv4Config.DhcpServer.MaxLeaseTime)

					var1.Ipv4Config.DhcpServer.NetworkContextId = types.StringPointerValue(var0.Ipv4Config.DhcpServer.NetworkContextId)

					if len(var0.Ipv4Config.DhcpServer.StaticMappings) == 0 {
						var1.Ipv4Config.DhcpServer.StaticMappings = nil
					} else {
						var1.Ipv4Config.DhcpServer.StaticMappings = make([]lanNetworkListDsModel_yKYCDSK_Config, 0, len(var0.Ipv4Config.DhcpServer.StaticMappings))
						for _, var12 := range var0.Ipv4Config.DhcpServer.StaticMappings {
							var13 := lanNetworkListDsModel_yKYCDSK_Config{}

							var13.IpAddress = types.StringValue(var12.IpAddress)

							var13.Mac = types.StringPointerValue(var12.Mac)

							var13.Name = types.StringValue(var12.Name)
							var1.Ipv4Config.DhcpServer.StaticMappings = append(var1.Ipv4Config.DhcpServer.StaticMappings, var13)
						}
					}

					var1.Ipv4Config.DhcpServer.Subnet = types.StringValue(var0.Ipv4Config.DhcpServer.Subnet)

					var14, var15 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.DhcpServer.Tags)
					var1.Ipv4Config.DhcpServer.Tags = var14
					resp.Diagnostics.Append(var15.Errors()...)
				}

				var16, var17 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.Prefixes)
				var1.Ipv4Config.Prefixes = var16
				resp.Diagnostics.Append(var17.Errors()...)
			}

			if var0.Ipv6Config == nil {
				var1.Ipv6Config = nil
			} else {
				var1.Ipv6Config = &lanNetworkListDsModel_xXKbjbR_Config{}

				var18, var19 := types.ListValueFrom(ctx, types.StringType, var0.Ipv6Config.DefaultRouters)
				var1.Ipv6Config.DefaultRouters = var18
				resp.Diagnostics.Append(var19.Errors()...)

				var20, var21 := types.ListValueFrom(ctx, types.StringType, var0.Ipv6Config.Prefixes)
				var1.Ipv6Config.Prefixes = var20
				resp.Diagnostics.Append(var21.Errors()...)
			}

			var1.Name = types.StringValue(var0.Name)

			var1.NetworkContextId = types.StringPointerValue(var0.NetworkContextId)

			var1.Scope = types.StringValue(var0.Scope)

			var22, var23 := types.ListValueFrom(ctx, types.StringType, var0.Tags)
			var1.Tags = var22
			resp.Diagnostics.Append(var23.Errors()...)

			var1.VrfContextId = types.StringPointerValue(var0.VrfContextId)
			state.Items = append(state.Items, var1)
		}
	}

	state.TotalItems = types.Int64PointerValue(ans.TotalItems)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Data source.
var (
	_ datasource.DataSource              = &lanNetworkDataSource{}
	_ datasource.DataSourceWithConfigure = &lanNetworkDataSource{}
)

func NewLanNetworkDataSource() datasource.DataSource {
	return &lanNetworkDataSource{}
}

type lanNetworkDataSource struct {
	client *sdwan.Client
}

// lanNetworkDsModel is the model.
type lanNetworkDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	LannetworkId types.String `tfsdk:"lannetwork_id"`
	SiteId       types.String `tfsdk:"site_id"`

	// Output.
	Description      types.String                      `tfsdk:"description"`
	Etag             types.Int64                       `tfsdk:"etag"`
	Id               types.String                      `tfsdk:"id"`
	Ipv4Config       *lanNetworkDsModel_eXzfzFj_Config `tfsdk:"ipv4_config"`
	Ipv6Config       *lanNetworkDsModel_xXKbjbR_Config `tfsdk:"ipv6_config"`
	Name             types.String                      `tfsdk:"name"`
	NetworkContextId types.String                      `tfsdk:"network_context_id"`
	Scope            types.String                      `tfsdk:"scope"`
	Tags             types.List                        `tfsdk:"tags"`
	VrfContextId     types.String                      `tfsdk:"vrf_context_id"`
}

type lanNetworkDsModel_eXzfzFj_Config struct {
	DefaultRouters types.List                        `tfsdk:"default_routers"`
	DhcpRelay      *lanNetworkDsModel_mCcgFKg_Config `tfsdk:"dhcp_relay"`
	DhcpServer     *lanNetworkDsModel_jGvcCTz_Config `tfsdk:"dhcp_server"`
	Prefixes       types.List                        `tfsdk:"prefixes"`
}

type lanNetworkDsModel_mCcgFKg_Config struct {
	Enabled         types.Bool                        `tfsdk:"enabled"`
	Option82        *lanNetworkDsModel_tOChZgD_Config `tfsdk:"option_82"`
	ServerIps       types.List                        `tfsdk:"server_ips"`
	SourceInterface types.String                      `tfsdk:"source_interface"`
}

type lanNetworkDsModel_tOChZgD_Config struct {
	CircuitId          types.String `tfsdk:"circuit_id"`
	Enabled            types.Bool   `tfsdk:"enabled"`
	ReforwardingPolicy types.String `tfsdk:"reforwarding_policy"`
	RemoteId           types.String `tfsdk:"remote_id"`
}

type lanNetworkDsModel_jGvcCTz_Config struct {
	BroadcastAddress types.String                       `tfsdk:"broadcast_address"`
	CustomOptions    []lanNetworkDsModel_lrzxLXR_Config `tfsdk:"custom_options"`
	DefaultLeaseTime types.Int64                        `tfsdk:"default_lease_time"`
	Description      types.String                       `tfsdk:"description"`
	Disabled         types.Bool                         `tfsdk:"disabled"`
	DnsServers       types.List                         `tfsdk:"dns_servers"`
	DomainName       types.String                       `tfsdk:"domain_name"`
	Gateway          types.String                       `tfsdk:"gateway"`
	Id               types.String                       `tfsdk:"id"`
	IpRanges         []lanNetworkDsModel_xygFTDt_Config `tfsdk:"ip_ranges"`
	MaxLeaseTime     types.Int64                        `tfsdk:"max_lease_time"`
	NetworkContextId types.String                       `tfsdk:"network_context_id"`
	StaticMappings   []lanNetworkDsModel_yKYCDSK_Config `tfsdk:"static_mappings"`
	Subnet           types.String                       `tfsdk:"subnet"`
	Tags             types.List                         `tfsdk:"tags"`
}

type lanNetworkDsModel_lrzxLXR_Config struct {
	OptionDefinition types.String `tfsdk:"option_definition"`
	OptionValue      types.String `tfsdk:"option_value"`
}

type lanNetworkDsModel_xygFTDt_Config struct {
	EndIp   types.String `tfsdk:"end_ip"`
	StartIp types.String `tfsdk:"start_ip"`
}

type lanNetworkDsModel_yKYCDSK_Config struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Mac       types.String `tfsdk:"mac"`
	Name      types.String `tfsdk:"name"`
}

type lanNetworkDsModel_xXKbjbR_Config struct {
	DefaultRouters types.List `tfsdk:"default_routers"`
	Prefixes       types.List `tfsdk:"prefixes"`
}

// Metadata returns the data source type name.
func (d *lanNetworkDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_lan_network"
}

// Schema defines the schema for this data source.
func (d *lanNetworkDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"lannetwork_id":true, "site_id":true} outputs:map[string]bool{"description":true, "etag":true, "id":true, "ipv4_config":true, "ipv6_config":true, "name":true, "network_context_id":true, "scope":true, "tags":true, "tfid":true, "vrf_context_id":true} forceNew:map[string]bool{"lannetwork_id":true, "site_id":true}
			"description": dsschema.StringAttribute{
				Description: "Description: Size(max = 1024, error = DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds limit, min = 0) .",
				Computed:    true,
			},
			"etag": dsschema.Int64Attribute{
				Description: "Entity tag for the resource.",
				Computed:    true,
			},
			"id": dsschema.StringAttribute{
				Description: "Id.",
				Computed:    true,
			},
			"ipv4_config": dsschema.SingleNestedAttribute{
				Description: "The Ipv4Config param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"default_routers":true, "dhcp_relay":true, "dhcp_server":true, "prefixes":true} forceNew:map[string]bool(nil)
					"default_routers": dsschema.ListAttribute{
						Description: "Default Routers: ListIPAddress(bcast = DENY, listMaxSize = 0, error = LAN_CONFIG_INVALID_DEFAULT_ROUTERS: Invalid ip for default routers., required = false, type = IPCIDR_32) .",
						Computed:    true,
						ElementType: types.StringType,
					},
					"dhcp_relay": dsschema.SingleNestedAttribute{
						Description: "The DhcpRelay param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} forceNew:map[string]bool(nil)
							"enabled": dsschema.BoolAttribute{
								Description: "Enabled.",
								Computed:    true,
							},
							"option_82": dsschema.SingleNestedAttribute{
								Description: "The Option82 param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} forceNew:map[string]bool(nil)
									"circuit_id": dsschema.StringAttribute{
										Description: "Circuit Id: Size(max = 255, error = DHCPRELAY_CIRCUIT_ID_EXCEEDS_LIMIT: Option 82 Circuid ID exceeds maximum length, min = 0) .",
										Computed:    true,
									},
									"enabled": dsschema.BoolAttribute{
										Description: "Enabled.",
										Computed:    true,
									},
									"reforwarding_policy": dsschema.StringAttribute{
										Description: "Reforwarding Policy: ValidateEnum(enumClass = classOf[DHCPRelayReforwardingPolicy], error = INVALID_DHCP_RELAY_REFWDING_POLICY: Option 82 invalid reforwarding policy, nullAllowed = false) . String must be one of these: `\"REPLACE\"`, `\"KEEP\"`, `\"APPEND\"`, `\"DROP\"`.",
										Computed:    true,
									},
									"remote_id": dsschema.StringAttribute{
										Description: "Remote Id: Size(max = 255, error = DHCPRELAY_REMOTE_ID_EXCEEDS_LIMIT: Option 82 Remote ID exceeds maximum length, min = 0) .",
										Computed:    true,
									},
								},
							},
							"server_ips": dsschema.ListAttribute{
								Description: "Server Ips: ListIPAddress(bcast = DENY, listMaxSize = 0, error = INTERFACE_CONFIG_INVALID_DHCP_RELAY_LIST: DHCP Servers IP specified in the list are invalid, required = true, type = IP) Size(max = 16, error = INTERFACE_CONFIG_DHCP_RELAY_LIST_EXCEEDS_LIMIT: DHCP Servers specified in the list exceeds maximum limit, min = 0) .",
								Computed:    true,
								ElementType: types.StringType,
							},
							"source_interface": dsschema.StringAttribute{
								Description: "Source Interface.",
								Computed:    true,
							},
						},
					},
					"dhcp_server": dsschema.SingleNestedAttribute{
						Description: "The DhcpServer param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true} forceNew:map[string]bool(nil)
							"broadcast_address": dsschema.StringAttribute{
								Description: "Broadcast Address.",
								Computed:    true,
							},
							"custom_options": dsschema.ListNestedAttribute{
								Description: "Custom Options: Valid .",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"option_definition":true, "option_value":true} forceNew:map[string]bool(nil)
										"option_definition": dsschema.StringAttribute{
											Description: "Option Definition: NotEmpty(groups = [classOf[Definition]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_DEF_UNSUPPORTED: Custom option definition is not supported) Size(groups = [classOf[Definition]], max = 1024, error = DHCPSERVER_CONFIG_OPTION_DEF_EXCEEDS_LIMIT: Custom option definition length exceeeds maximum limit, min = 0) .",
											Computed:    true,
										},
										"option_value": dsschema.StringAttribute{
											Description: "Option Value: NotEmpty(groups = [classOf[Value]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_VAL_UNSUPPORTED: Custom option value is not supported) Size(groups = [classOf[Value]], max = 8192, error = DHCPSERVER_CONFIG_OPTION_VAL_EXCEEDS_LIMIT: Custom option value length exceeds maximum limit, min = 0) .",
											Computed:    true,
										},
									},
								},
							},
							"default_lease_time": dsschema.Int64Attribute{
								Description: "Default Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
								Computed:    true,
							},
							"description": dsschema.StringAttribute{
								Description: "Description: Size(max = 256, error = DHCPSERVER_CONFIG_DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds the maximum limit., min = 0) .",
								Computed:    true,
							},
							"disabled": dsschema.BoolAttribute{
								Description: "Disabled.",
								Computed:    true,
							},
							"dns_servers": dsschema.ListAttribute{
								Description: "Dns Servers: Size(max = 3, error = DHCPSERVER_CONFIG_DNS_ENTRIES_EXCEEDS_LIMIT: Name servers count exceeds the maximum limit, min = 0) .",
								Computed:    true,
								ElementType: types.StringType,
							},
							"domain_name": dsschema.StringAttribute{
								Description: "Domain Name: Size(max = 256, error = DHCPSERVER_CONFIG_INVALID_DOMAIN_NAME: Domain name exceeds the maximum limit., min = 0) .",
								Computed:    true,
							},
							"gateway": dsschema.StringAttribute{
								Description: "Gateway.",
								Computed:    true,
							},
							"id": dsschema.StringAttribute{
								Description: "Id.",
								Computed:    true,
							},
							"ip_ranges": dsschema.ListNestedAttribute{
								Description: "Ip Ranges: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) Size(max = 2147483647, error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet., min = 1) Valid .",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"end_ip":true, "start_ip":true} forceNew:map[string]bool(nil)
										"end_ip": dsschema.StringAttribute{
											Description: "End Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
											Computed:    true,
										},
										"start_ip": dsschema.StringAttribute{
											Description: "Start Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
											Computed:    true,
										},
									},
								},
							},
							"max_lease_time": dsschema.Int64Attribute{
								Description: "Max Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
								Computed:    true,
							},
							"network_context_id": dsschema.StringAttribute{
								Description: "Network Context Id: Digits(fraction = 0, integer = 50, error = INVALID_NETWORK_CTX_ID: Invalid network ctrx id.) .",
								Computed:    true,
							},
							"static_mappings": dsschema.ListNestedAttribute{
								Description: "Static Mappings: Valid .",
								Computed:    true,
								NestedObject: dsschema.NestedAttributeObject{
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"ip_address":true, "mac":true, "name":true} forceNew:map[string]bool(nil)
										"ip_address": dsschema.StringAttribute{
											Description: "Ip Address: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) .",
											Computed:    true,
										},
										"mac": dsschema.StringAttribute{
											Description: "Mac: MACAddressFiveColons(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_MAC_ADDR: Invalid mac address provided for static mapping) .",
											Computed:    true,
										},
										"name": dsschema.StringAttribute{
											Description: "Name: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) Size(max = 256, error = DHCPSERVER_CONFIG_STATIC_MAPPING_NAME_EXCEEDS_LIMIT: Static Mapping name execeeds the maximum limit, min = 0) Pattern(error = DHCPSERVER_CONFIG_STATIC_MAPPING_UNSUPPORTED_NAME: Provide valid static mapping name, regexp = ^[a-zA-Z0-9]+(([a-zA-Z0-9\\\\-_])|(\\\\.?[a-zA-Z0-9\\\\-]))*\\\\.?$) .",
											Computed:    true,
										},
									},
								},
							},
							"subnet": dsschema.StringAttribute{
								Description: "Subnet: NotNull(error = DHCPSERVER_CONFIG_INVALID_SUBNET_ADDR: Invalid IPv4 subnet address.) .",
								Computed:    true,
							},
							"tags": dsschema.ListAttribute{
								Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = DHCPSERVER_CONFIG_INVALID_TAGS: Tags config is invalid- maximum 10 tags are supported, tag should not exceed maximum limit of 128 characters, it should not have duplicates., noTrim = false, regex = [^,\\\\s]+, required = false) .",
								Computed:    true,
								ElementType: types.StringType,
							},
						},
					},
					"prefixes": dsschema.ListAttribute{
						Description: "Prefixes: ListIPAddress(bcast = DENY, listMaxSize = 0, error = LAN_CONFIG_INVALID_PREFIX: Invalid prefix ip., required = false, type = PREFIXCIDR_32) .",
						Computed:    true,
						ElementType: types.StringType,
					},
				},
			},
			"ipv6_config": dsschema.SingleNestedAttribute{
				Description: "The Ipv6Config param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"default_routers":true, "prefixes":true} forceNew:map[string]bool(nil)
					"default_routers": dsschema.ListAttribute{
						Description: "Default Routers: ListIPv6Address(bcast = DENY, listMaxSize = 0, message = LAN_CONFIG_V6_INVALID_DEFAULT_ROUTERS, required = false, type = IPCIDR_128) .",
						Computed:    true,
						ElementType: types.StringType,
					},
					"prefixes": dsschema.ListAttribute{
						Description: "Prefixes: ListIPv6Address(bcast = DENY, listMaxSize = 0, message = LAN_CONFIG_INVALID_PREFIX_V6, required = false, type = GATEWAYCIDRV6) .",
						Computed:    true,
						ElementType: types.StringType,
					},
				},
			},
			"lannetwork_id": dsschema.StringAttribute{
				Description: "Lannetwork Id.",
				Required:    true,
			},
			"name": dsschema.StringAttribute{
				Description: "Name: Required(error = NAME_REQD: Please provide resource name.) Size(max = 128, error = NAME_EXCEEDS_LIMIT: Name of the resource exceeds limit., min = 0) .",
				Computed:    true,
			},
			"network_context_id": dsschema.StringAttribute{
				Description: "Network Context Id: Digits(fraction = 0, integer = 30, error = INVALID_NETWORK_CONTEXT_ID: Specified network context is invalid.) .",
				Computed:    true,
			},
			"scope": dsschema.StringAttribute{
				Description: "Scope: ValidateEnum(enumClass = classOf[NetworkScope], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"GLOBAL\"`, `\"LOCAL\"`.",
				Computed:    true,
			},
			"site_id": dsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
			},
			"tags": dsschema.ListAttribute{
				Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 1024, listMaxSize = 10, error = INVALID_TAG: Maximum 10 Unique tags of length 1024 each are allowed, noTrim = false, regex = [^,\\\\s]+, required = false) .",
				Computed:    true,
				ElementType: types.StringType,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"vrf_context_id": dsschema.StringAttribute{
				Description: "Vrf Context Id.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *lanNetworkDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*sdwan.Client)
}

// Read performs Read for the struct.
func (d *lanNetworkDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state lanNetworkDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source read", map[string]any{
		"data_source_name":            "prismasdwan_lan_network",
		"terraform_provider_function": "Read",
		"site_id":                     state.SiteId.ValueString(),
		"lannetwork_id":               state.LannetworkId.ValueString(),
	})

	// Prepare to run the command.
	svc := wHGMtfb.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := wHGMtfb.ReadInput{}

	input.SiteId = StringValue(state.SiteId)

	input.LannetworkId = StringValue(state.LannetworkId)

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error reading config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	idBuilder.WriteString(input.LannetworkId)

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.Description = types.StringPointerValue(ans.Description)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Id = types.StringPointerValue(ans.Id)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &lanNetworkDsModel_eXzfzFj_Config{}

		var0, var1 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DefaultRouters)
		state.Ipv4Config.DefaultRouters = var0
		resp.Diagnostics.Append(var1.Errors()...)

		if ans.Ipv4Config.DhcpRelay == nil {
			state.Ipv4Config.DhcpRelay = nil
		} else {
			state.Ipv4Config.DhcpRelay = &lanNetworkDsModel_mCcgFKg_Config{}

			state.Ipv4Config.DhcpRelay.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Enabled)

			if ans.Ipv4Config.DhcpRelay.Option82 == nil {
				state.Ipv4Config.DhcpRelay.Option82 = nil
			} else {
				state.Ipv4Config.DhcpRelay.Option82 = &lanNetworkDsModel_tOChZgD_Config{}

				state.Ipv4Config.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.CircuitId)

				state.Ipv4Config.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Option82.Enabled)

				state.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

				state.Ipv4Config.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.RemoteId)
			}

			var2, var3 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpRelay.ServerIps)
			state.Ipv4Config.DhcpRelay.ServerIps = var2
			resp.Diagnostics.Append(var3.Errors()...)

			state.Ipv4Config.DhcpRelay.SourceInterface = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.SourceInterface)
		}

		if ans.Ipv4Config.DhcpServer == nil {
			state.Ipv4Config.DhcpServer = nil
		} else {
			state.Ipv4Config.DhcpServer = &lanNetworkDsModel_jGvcCTz_Config{}

			state.Ipv4Config.DhcpServer.BroadcastAddress = types.StringPointerValue(ans.Ipv4Config.DhcpServer.BroadcastAddress)

			if len(ans.Ipv4Config.DhcpServer.CustomOptions) == 0 {
				state.Ipv4Config.DhcpServer.CustomOptions = nil
			} else {
				state.Ipv4Config.DhcpServer.CustomOptions = make([]lanNetworkDsModel_lrzxLXR_Config, 0, len(ans.Ipv4Config.DhcpServer.CustomOptions))
				for _, var4 := range ans.Ipv4Config.DhcpServer.CustomOptions {
					var5 := lanNetworkDsModel_lrzxLXR_Config{}

					var5.OptionDefinition = types.StringValue(var4.OptionDefinition)

					var5.OptionValue = types.StringValue(var4.OptionValue)
					state.Ipv4Config.DhcpServer.CustomOptions = append(state.Ipv4Config.DhcpServer.CustomOptions, var5)
				}
			}

			state.Ipv4Config.DhcpServer.DefaultLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.DefaultLeaseTime)

			state.Ipv4Config.DhcpServer.Description = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Description)

			state.Ipv4Config.DhcpServer.Disabled = types.BoolPointerValue(ans.Ipv4Config.DhcpServer.Disabled)

			var6, var7 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.DnsServers)
			state.Ipv4Config.DhcpServer.DnsServers = var6
			resp.Diagnostics.Append(var7.Errors()...)

			state.Ipv4Config.DhcpServer.DomainName = types.StringPointerValue(ans.Ipv4Config.DhcpServer.DomainName)

			state.Ipv4Config.DhcpServer.Gateway = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Gateway)

			state.Ipv4Config.DhcpServer.Id = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Id)

			if len(ans.Ipv4Config.DhcpServer.IpRanges) == 0 {
				state.Ipv4Config.DhcpServer.IpRanges = nil
			} else {
				state.Ipv4Config.DhcpServer.IpRanges = make([]lanNetworkDsModel_xygFTDt_Config, 0, len(ans.Ipv4Config.DhcpServer.IpRanges))
				for _, var8 := range ans.Ipv4Config.DhcpServer.IpRanges {
					var9 := lanNetworkDsModel_xygFTDt_Config{}

					var9.EndIp = types.StringValue(var8.EndIp)

					var9.StartIp = types.StringValue(var8.StartIp)
					state.Ipv4Config.DhcpServer.IpRanges = append(state.Ipv4Config.DhcpServer.IpRanges, var9)
				}
			}

			state.Ipv4Config.DhcpServer.MaxLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.MaxLeaseTime)

			state.Ipv4Config.DhcpServer.NetworkContextId = types.StringPointerValue(ans.Ipv4Config.DhcpServer.NetworkContextId)

			if len(ans.Ipv4Config.DhcpServer.StaticMappings) == 0 {
				state.Ipv4Config.DhcpServer.StaticMappings = nil
			} else {
				state.Ipv4Config.DhcpServer.StaticMappings = make([]lanNetworkDsModel_yKYCDSK_Config, 0, len(ans.Ipv4Config.DhcpServer.StaticMappings))
				for _, var10 := range ans.Ipv4Config.DhcpServer.StaticMappings {
					var11 := lanNetworkDsModel_yKYCDSK_Config{}

					var11.IpAddress = types.StringValue(var10.IpAddress)

					var11.Mac = types.StringPointerValue(var10.Mac)

					var11.Name = types.StringValue(var10.Name)
					state.Ipv4Config.DhcpServer.StaticMappings = append(state.Ipv4Config.DhcpServer.StaticMappings, var11)
				}
			}

			state.Ipv4Config.DhcpServer.Subnet = types.StringValue(ans.Ipv4Config.DhcpServer.Subnet)

			var12, var13 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.Tags)
			state.Ipv4Config.DhcpServer.Tags = var12
			resp.Diagnostics.Append(var13.Errors()...)
		}

		var14, var15 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.Prefixes)
		state.Ipv4Config.Prefixes = var14
		resp.Diagnostics.Append(var15.Errors()...)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &lanNetworkDsModel_xXKbjbR_Config{}

		var16, var17 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DefaultRouters)
		state.Ipv6Config.DefaultRouters = var16
		resp.Diagnostics.Append(var17.Errors()...)

		var18, var19 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.Prefixes)
		state.Ipv6Config.Prefixes = var18
		resp.Diagnostics.Append(var19.Errors()...)
	}

	state.Name = types.StringValue(ans.Name)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Scope = types.StringValue(ans.Scope)

	var20, var21 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var20
	resp.Diagnostics.Append(var21.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Resource.
var (
	_ resource.Resource                = &lanNetworkResource{}
	_ resource.ResourceWithConfigure   = &lanNetworkResource{}
	_ resource.ResourceWithImportState = &lanNetworkResource{}
)

func NewLanNetworkResource() resource.Resource {
	return &lanNetworkResource{}
}

type lanNetworkResource struct {
	client *sdwan.Client
}

// lanNetworkRsModel is the model.
type lanNetworkRsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	Description      types.String                      `tfsdk:"description"`
	Etag             types.Int64                       `tfsdk:"etag"`
	Id               types.String                      `tfsdk:"id"`
	Ipv4Config       *lanNetworkRsModel_eXzfzFj_Config `tfsdk:"ipv4_config"`
	Ipv6Config       *lanNetworkRsModel_xXKbjbR_Config `tfsdk:"ipv6_config"`
	Name             types.String                      `tfsdk:"name"`
	NetworkContextId types.String                      `tfsdk:"network_context_id"`
	Scope            types.String                      `tfsdk:"scope"`
	SiteId           types.String                      `tfsdk:"site_id"`
	Tags             types.List                        `tfsdk:"tags"`
	VrfContextId     types.String                      `tfsdk:"vrf_context_id"`

	// Output.
	// omit input: description
	// omit input: etag
	// omit input: id
	// omit input: ipv4_config
	// omit input: ipv6_config
	// omit input: name
	// omit input: network_context_id
	// omit input: scope
	// omit input: tags
	// omit input: vrf_context_id
}

type lanNetworkRsModel_eXzfzFj_Config struct {
	DefaultRouters types.List                        `tfsdk:"default_routers"`
	DhcpRelay      *lanNetworkRsModel_mCcgFKg_Config `tfsdk:"dhcp_relay"`
	DhcpServer     *lanNetworkRsModel_jGvcCTz_Config `tfsdk:"dhcp_server"`
	Prefixes       types.List                        `tfsdk:"prefixes"`
}

type lanNetworkRsModel_mCcgFKg_Config struct {
	Enabled         types.Bool                        `tfsdk:"enabled"`
	Option82        *lanNetworkRsModel_tOChZgD_Config `tfsdk:"option_82"`
	ServerIps       types.List                        `tfsdk:"server_ips"`
	SourceInterface types.String                      `tfsdk:"source_interface"`
}

type lanNetworkRsModel_tOChZgD_Config struct {
	CircuitId          types.String `tfsdk:"circuit_id"`
	Enabled            types.Bool   `tfsdk:"enabled"`
	ReforwardingPolicy types.String `tfsdk:"reforwarding_policy"`
	RemoteId           types.String `tfsdk:"remote_id"`
}

type lanNetworkRsModel_jGvcCTz_Config struct {
	BroadcastAddress types.String                       `tfsdk:"broadcast_address"`
	CustomOptions    []lanNetworkRsModel_lrzxLXR_Config `tfsdk:"custom_options"`
	DefaultLeaseTime types.Int64                        `tfsdk:"default_lease_time"`
	Description      types.String                       `tfsdk:"description"`
	Disabled         types.Bool                         `tfsdk:"disabled"`
	DnsServers       types.List                         `tfsdk:"dns_servers"`
	DomainName       types.String                       `tfsdk:"domain_name"`
	Gateway          types.String                       `tfsdk:"gateway"`
	Id               types.String                       `tfsdk:"id"`
	IpRanges         []lanNetworkRsModel_xygFTDt_Config `tfsdk:"ip_ranges"`
	MaxLeaseTime     types.Int64                        `tfsdk:"max_lease_time"`
	NetworkContextId types.String                       `tfsdk:"network_context_id"`
	StaticMappings   []lanNetworkRsModel_yKYCDSK_Config `tfsdk:"static_mappings"`
	Subnet           types.String                       `tfsdk:"subnet"`
	Tags             types.List                         `tfsdk:"tags"`
}

type lanNetworkRsModel_lrzxLXR_Config struct {
	OptionDefinition types.String `tfsdk:"option_definition"`
	OptionValue      types.String `tfsdk:"option_value"`
}

type lanNetworkRsModel_xygFTDt_Config struct {
	EndIp   types.String `tfsdk:"end_ip"`
	StartIp types.String `tfsdk:"start_ip"`
}

type lanNetworkRsModel_yKYCDSK_Config struct {
	IpAddress types.String `tfsdk:"ip_address"`
	Mac       types.String `tfsdk:"mac"`
	Name      types.String `tfsdk:"name"`
}

type lanNetworkRsModel_xXKbjbR_Config struct {
	DefaultRouters types.List `tfsdk:"default_routers"`
	Prefixes       types.List `tfsdk:"prefixes"`
}

// Metadata returns the data source type name.
func (r *lanNetworkResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_lan_network"
}

// Schema defines the schema for this data source.
func (r *lanNetworkResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]rsschema.Attribute{
			// inputs:map[string]bool{"description":true, "etag":true, "id":true, "ipv4_config":true, "ipv6_config":true, "name":true, "network_context_id":true, "scope":true, "site_id":true, "tags":true, "vrf_context_id":true} outputs:map[string]bool{"description":true, "etag":true, "id":true, "ipv4_config":true, "ipv6_config":true, "name":true, "network_context_id":true, "scope":true, "tags":true, "tfid":true, "vrf_context_id":true} forceNew:map[string]bool{"site_id":true}
			"description": rsschema.StringAttribute{
				Description: "Description: Size(max = 1024, error = DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds limit, min = 0) .",
				Optional:    true,
			},
			"etag": rsschema.Int64Attribute{
				Description: "Entity tag for the resource.",
				Optional:    true,
				Computed:    true,
			},
			"id": rsschema.StringAttribute{
				Description: "Id.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ipv4_config": rsschema.SingleNestedAttribute{
				Description: "The Ipv4Config param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"default_routers":true, "dhcp_relay":true, "dhcp_server":true, "prefixes":true} outputs:map[string]bool{"default_routers":true, "dhcp_relay":true, "dhcp_server":true, "prefixes":true} forceNew:map[string]bool(nil)
					"default_routers": rsschema.ListAttribute{
						Description: "Default Routers: ListIPAddress(bcast = DENY, listMaxSize = 0, error = LAN_CONFIG_INVALID_DEFAULT_ROUTERS: Invalid ip for default routers., required = false, type = IPCIDR_32) .",
						Optional:    true,
						ElementType: types.StringType,
					},
					"dhcp_relay": rsschema.SingleNestedAttribute{
						Description: "The DhcpRelay param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} outputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} forceNew:map[string]bool(nil)
							"enabled": rsschema.BoolAttribute{
								Description: "Enabled.",
								Optional:    true,
							},
							"option_82": rsschema.SingleNestedAttribute{
								Description: "The Option82 param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} outputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} forceNew:map[string]bool(nil)
									"circuit_id": rsschema.StringAttribute{
										Description: "Circuit Id: Size(max = 255, error = DHCPRELAY_CIRCUIT_ID_EXCEEDS_LIMIT: Option 82 Circuid ID exceeds maximum length, min = 0) .",
										Optional:    true,
									},
									"enabled": rsschema.BoolAttribute{
										Description: "Enabled.",
										Optional:    true,
									},
									"reforwarding_policy": rsschema.StringAttribute{
										Description: "Reforwarding Policy: ValidateEnum(enumClass = classOf[DHCPRelayReforwardingPolicy], error = INVALID_DHCP_RELAY_REFWDING_POLICY: Option 82 invalid reforwarding policy, nullAllowed = false) . String must be one of these: `\"REPLACE\"`, `\"KEEP\"`, `\"APPEND\"`, `\"DROP\"`.",
										Required:    true,
										Validators: []validator.String{
											stringvalidator.OneOf("REPLACE", "KEEP", "APPEND", "DROP"),
										},
									},
									"remote_id": rsschema.StringAttribute{
										Description: "Remote Id: Size(max = 255, error = DHCPRELAY_REMOTE_ID_EXCEEDS_LIMIT: Option 82 Remote ID exceeds maximum length, min = 0) .",
										Optional:    true,
									},
								},
							},
							"server_ips": rsschema.ListAttribute{
								Description: "Server Ips: ListIPAddress(bcast = DENY, listMaxSize = 0, error = INTERFACE_CONFIG_INVALID_DHCP_RELAY_LIST: DHCP Servers IP specified in the list are invalid, required = true, type = IP) Size(max = 16, error = INTERFACE_CONFIG_DHCP_RELAY_LIST_EXCEEDS_LIMIT: DHCP Servers specified in the list exceeds maximum limit, min = 0) .",
								Optional:    true,
								ElementType: types.StringType,
							},
							"source_interface": rsschema.StringAttribute{
								Description: "Source Interface.",
								Optional:    true,
							},
						},
					},
					"dhcp_server": rsschema.SingleNestedAttribute{
						Description: "The DhcpServer param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true} outputs:map[string]bool{"broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true} forceNew:map[string]bool(nil)
							"broadcast_address": rsschema.StringAttribute{
								Description: "Broadcast Address.",
								Optional:    true,
							},
							"custom_options": rsschema.ListNestedAttribute{
								Description: "Custom Options: Valid .",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"option_definition":true, "option_value":true} outputs:map[string]bool{"option_definition":true, "option_value":true} forceNew:map[string]bool(nil)
										"option_definition": rsschema.StringAttribute{
											Description: "Option Definition: NotEmpty(groups = [classOf[Definition]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_DEF_UNSUPPORTED: Custom option definition is not supported) Size(groups = [classOf[Definition]], max = 1024, error = DHCPSERVER_CONFIG_OPTION_DEF_EXCEEDS_LIMIT: Custom option definition length exceeeds maximum limit, min = 0) .",
											Required:    true,
										},
										"option_value": rsschema.StringAttribute{
											Description: "Option Value: NotEmpty(groups = [classOf[Value]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_VAL_UNSUPPORTED: Custom option value is not supported) Size(groups = [classOf[Value]], max = 8192, error = DHCPSERVER_CONFIG_OPTION_VAL_EXCEEDS_LIMIT: Custom option value length exceeds maximum limit, min = 0) .",
											Required:    true,
										},
									},
								},
							},
							"default_lease_time": rsschema.Int64Attribute{
								Description: "Default Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
								Optional:    true,
							},
							"description": rsschema.StringAttribute{
								Description: "Description: Size(max = 256, error = DHCPSERVER_CONFIG_DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds the maximum limit., min = 0) .",
								Optional:    true,
							},
							"disabled": rsschema.BoolAttribute{
								Description: "Disabled.",
								Optional:    true,
							},
							"dns_servers": rsschema.ListAttribute{
								Description: "Dns Servers: Size(max = 3, error = DHCPSERVER_CONFIG_DNS_ENTRIES_EXCEEDS_LIMIT: Name servers count exceeds the maximum limit, min = 0) .",
								Optional:    true,
								ElementType: types.StringType,
							},
							"domain_name": rsschema.StringAttribute{
								Description: "Domain Name: Size(max = 256, error = DHCPSERVER_CONFIG_INVALID_DOMAIN_NAME: Domain name exceeds the maximum limit., min = 0) .",
								Optional:    true,
							},
							"gateway": rsschema.StringAttribute{
								Description: "Gateway.",
								Optional:    true,
							},
							"id": rsschema.StringAttribute{
								Description: "Id.",
								Optional:    true,
								Computed:    true,
							},
							"ip_ranges": rsschema.ListNestedAttribute{
								Description: "Ip Ranges: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) Size(max = 2147483647, error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet., min = 1) Valid .",
								Required:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"end_ip":true, "start_ip":true} outputs:map[string]bool{"end_ip":true, "start_ip":true} forceNew:map[string]bool(nil)
										"end_ip": rsschema.StringAttribute{
											Description: "End Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
											Required:    true,
										},
										"start_ip": rsschema.StringAttribute{
											Description: "Start Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
											Required:    true,
										},
									},
								},
							},
							"max_lease_time": rsschema.Int64Attribute{
								Description: "Max Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
								Optional:    true,
							},
							"network_context_id": rsschema.StringAttribute{
								Description: "Network Context Id: Digits(fraction = 0, integer = 50, error = INVALID_NETWORK_CTX_ID: Invalid network ctrx id.) .",
								Optional:    true,
							},
							"static_mappings": rsschema.ListNestedAttribute{
								Description: "Static Mappings: Valid .",
								Optional:    true,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// inputs:map[string]bool{"ip_address":true, "mac":true, "name":true} outputs:map[string]bool{"ip_address":true, "mac":true, "name":true} forceNew:map[string]bool(nil)
										"ip_address": rsschema.StringAttribute{
											Description: "Ip Address: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) .",
											Required:    true,
										},
										"mac": rsschema.StringAttribute{
											Description: "Mac: MACAddressFiveColons(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_MAC_ADDR: Invalid mac address provided for static mapping) .",
											Optional:    true,
										},
										"name": rsschema.StringAttribute{
											Description: "Name: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) Size(max = 256, error = DHCPSERVER_CONFIG_STATIC_MAPPING_NAME_EXCEEDS_LIMIT: Static Mapping name execeeds the maximum limit, min = 0) Pattern(error = DHCPSERVER_CONFIG_STATIC_MAPPING_UNSUPPORTED_NAME: Provide valid static mapping name, regexp = ^[a-zA-Z0-9]+(([a-zA-Z0-9\\\\-_])|(\\\\.?[a-zA-Z0-9\\\\-]))*\\\\.?$) .",
											Required:    true,
										},
									},
								},
							},
							"subnet": rsschema.StringAttribute{
								Description: "Subnet: NotNull(error = DHCPSERVER_CONFIG_INVALID_SUBNET_ADDR: Invalid IPv4 subnet address.) .",
								Required:    true,
							},
							"tags": rsschema.ListAttribute{
								Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = DHCPSERVER_CONFIG_INVALID_TAGS: Tags config is invalid- maximum 10 tags are supported, tag should not exceed maximum limit of 128 characters, it should not have duplicates., noTrim = false, regex = [^,\\\\s]+, required = false) .",
								Optional:    true,
								ElementType: types.StringType,
							},
						},
					},
					"prefixes": rsschema.ListAttribute{
						Description: "Prefixes: ListIPAddress(bcast = DENY, listMaxSize = 0, error = LAN_CONFIG_INVALID_PREFIX: Invalid prefix ip., required = false, type = PREFIXCIDR_32) .",
						Optional:    true,
						ElementType: types.StringType,
					},
				},
			},
			"ipv6_config": rsschema.SingleNestedAttribute{
				Description: "The Ipv6Config param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"default_routers":true, "prefixes":true} outputs:map[string]bool{"default_routers":true, "prefixes":true} forceNew:map[string]bool(nil)
					"default_routers": rsschema.ListAttribute{
						Description: "Default Routers: ListIPv6Address(bcast = DENY, listMaxSize = 0, message = LAN_CONFIG_V6_INVALID_DEFAULT_ROUTERS, required = false, type = IPCIDR_128) .",
						Optional:    true,
						ElementType: types.StringType,
					},
					"prefixes": rsschema.ListAttribute{
						Description: "Prefixes: ListIPv6Address(bcast = DENY, listMaxSize = 0, message = LAN_CONFIG_INVALID_PREFIX_V6, required = false, type = GATEWAYCIDRV6) .",
						Optional:    true,
						ElementType: types.StringType,
					},
				},
			},
			"name": rsschema.StringAttribute{
				Description: "Name: Required(error = NAME_REQD: Please provide resource name.) Size(max = 128, error = NAME_EXCEEDS_LIMIT: Name of the resource exceeds limit., min = 0) .",
				Required:    true,
			},
			"network_context_id": rsschema.StringAttribute{
				Description: "Network Context Id: Digits(fraction = 0, integer = 30, error = INVALID_NETWORK_CONTEXT_ID: Specified network context is invalid.) .",
				Optional:    true,
			},
			"scope": rsschema.StringAttribute{
				Description: "Scope: ValidateEnum(enumClass = classOf[NetworkScope], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"GLOBAL\"`, `\"LOCAL\"`.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("GLOBAL", "LOCAL"),
				},
			},
			"site_id": rsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"tags": rsschema.ListAttribute{
				Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 1024, listMaxSize = 10, error = INVALID_TAG: Maximum 10 Unique tags of length 1024 each are allowed, noTrim = false, regex = [^,\\\\s]+, required = false) .",
				Optional:    true,
				ElementType: types.StringType,
			},
			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"vrf_context_id": rsschema.StringAttribute{
				Description: "Vrf Context Id.",
				Optional:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (r *lanNetworkResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*sdwan.Client)
}

// Create resource.
func (r *lanNetworkResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state lanNetworkRsModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "prismasdwan_lan_network",
		"terraform_provider_function": "Create",
		"site_id":                     state.SiteId.ValueString(),
	})

	// Prepare to create the config.
	svc := wHGMtfb.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := wHGMtfb.CreateInput{}

	input.SiteId = StringValue(state.SiteId)
	input.Request = &yjUyRcw.Config{}

	input.Request.Description = StringValueOrNil(state.Description)

	input.Request.Etag = Int64ValueOrNil(state.Etag)

	if state.Ipv4Config != nil {
		input.Request.Ipv4Config = &eXzfzFj.Config{}

		input.Request.Ipv4Config.DefaultRouters = ListStringValueOrNil(ctx, state.Ipv4Config.DefaultRouters)

		if state.Ipv4Config.DhcpRelay != nil {
			input.Request.Ipv4Config.DhcpRelay = &mCcgFKg.Config{}

			input.Request.Ipv4Config.DhcpRelay.Enabled = BoolValueOrNil(state.Ipv4Config.DhcpRelay.Enabled)

			if state.Ipv4Config.DhcpRelay.Option82 != nil {
				input.Request.Ipv4Config.DhcpRelay.Option82 = &tOChZgD.Config{}

				input.Request.Ipv4Config.DhcpRelay.Option82.CircuitId = StringValueOrNil(state.Ipv4Config.DhcpRelay.Option82.CircuitId)

				input.Request.Ipv4Config.DhcpRelay.Option82.Enabled = BoolValueOrNil(state.Ipv4Config.DhcpRelay.Option82.Enabled)

				input.Request.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = StringValue(state.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

				input.Request.Ipv4Config.DhcpRelay.Option82.RemoteId = StringValueOrNil(state.Ipv4Config.DhcpRelay.Option82.RemoteId)
			}

			input.Request.Ipv4Config.DhcpRelay.ServerIps = ListStringValueOrNil(ctx, state.Ipv4Config.DhcpRelay.ServerIps)

			input.Request.Ipv4Config.DhcpRelay.SourceInterface = StringValueOrNil(state.Ipv4Config.DhcpRelay.SourceInterface)
		}

		if state.Ipv4Config.DhcpServer != nil {
			input.Request.Ipv4Config.DhcpServer = &jGvcCTz.Config{}

			input.Request.Ipv4Config.DhcpServer.BroadcastAddress = StringValueOrNil(state.Ipv4Config.DhcpServer.BroadcastAddress)

			if len(state.Ipv4Config.DhcpServer.CustomOptions) != 0 {
				input.Request.Ipv4Config.DhcpServer.CustomOptions = make([]lrzxLXR.Config, 0, len(state.Ipv4Config.DhcpServer.CustomOptions))
				for _, var2 := range state.Ipv4Config.DhcpServer.CustomOptions {
					var var3 lrzxLXR.Config

					var3.OptionDefinition = StringValue(var2.OptionDefinition)

					var3.OptionValue = StringValue(var2.OptionValue)
					input.Request.Ipv4Config.DhcpServer.CustomOptions = append(input.Request.Ipv4Config.DhcpServer.CustomOptions, var3)
				}
			}

			input.Request.Ipv4Config.DhcpServer.DefaultLeaseTime = Int64ValueOrNil(state.Ipv4Config.DhcpServer.DefaultLeaseTime)

			input.Request.Ipv4Config.DhcpServer.Description = StringValueOrNil(state.Ipv4Config.DhcpServer.Description)

			input.Request.Ipv4Config.DhcpServer.Disabled = BoolValueOrNil(state.Ipv4Config.DhcpServer.Disabled)

			input.Request.Ipv4Config.DhcpServer.DnsServers = ListStringValueOrNil(ctx, state.Ipv4Config.DhcpServer.DnsServers)

			input.Request.Ipv4Config.DhcpServer.DomainName = StringValueOrNil(state.Ipv4Config.DhcpServer.DomainName)

			input.Request.Ipv4Config.DhcpServer.Gateway = StringValueOrNil(state.Ipv4Config.DhcpServer.Gateway)

			input.Request.Ipv4Config.DhcpServer.Id = StringValueOrNil(state.Ipv4Config.DhcpServer.Id)

			if len(state.Ipv4Config.DhcpServer.IpRanges) != 0 {
				input.Request.Ipv4Config.DhcpServer.IpRanges = make([]xygFTDt.Config, 0, len(state.Ipv4Config.DhcpServer.IpRanges))
				for _, var5 := range state.Ipv4Config.DhcpServer.IpRanges {
					var var6 xygFTDt.Config

					var6.EndIp = StringValue(var5.EndIp)

					var6.StartIp = StringValue(var5.StartIp)
					input.Request.Ipv4Config.DhcpServer.IpRanges = append(input.Request.Ipv4Config.DhcpServer.IpRanges, var6)
				}
			}

			input.Request.Ipv4Config.DhcpServer.MaxLeaseTime = Int64ValueOrNil(state.Ipv4Config.DhcpServer.MaxLeaseTime)

			input.Request.Ipv4Config.DhcpServer.NetworkContextId = StringValueOrNil(state.Ipv4Config.DhcpServer.NetworkContextId)

			if len(state.Ipv4Config.DhcpServer.StaticMappings) != 0 {
				input.Request.Ipv4Config.DhcpServer.StaticMappings = make([]yKYCDSK.Config, 0, len(state.Ipv4Config.DhcpServer.StaticMappings))
				for _, var7 := range state.Ipv4Config.DhcpServer.StaticMappings {
					var var8 yKYCDSK.Config

					var8.IpAddress = StringValue(var7.IpAddress)

					var8.Mac = StringValueOrNil(var7.Mac)

					var8.Name = StringValue(var7.Name)
					input.Request.Ipv4Config.DhcpServer.StaticMappings = append(input.Request.Ipv4Config.DhcpServer.StaticMappings, var8)
				}
			}

			input.Request.Ipv4Config.DhcpServer.Subnet = StringValue(state.Ipv4Config.DhcpServer.Subnet)

			input.Request.Ipv4Config.DhcpServer.Tags = ListStringValueOrNil(ctx, state.Ipv4Config.DhcpServer.Tags)
		}

		input.Request.Ipv4Config.Prefixes = ListStringValueOrNil(ctx, state.Ipv4Config.Prefixes)
	}

	if state.Ipv6Config != nil {
		input.Request.Ipv6Config = &xXKbjbR.Config{}

		input.Request.Ipv6Config.DefaultRouters = ListStringValueOrNil(ctx, state.Ipv6Config.DefaultRouters)

		input.Request.Ipv6Config.Prefixes = ListStringValueOrNil(ctx, state.Ipv6Config.Prefixes)
	}

	input.Request.Name = StringValue(state.Name)

	input.Request.NetworkContextId = StringValueOrNil(state.NetworkContextId)

	input.Request.Scope = StringValue(state.Scope)

	input.Request.Tags = ListStringValueOrNil(ctx, state.Tags)

	input.Request.VrfContextId = StringValueOrNil(state.VrfContextId)

	// Perform the operation.
	ans, err := svc.Create(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error creating config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.Description = types.StringPointerValue(ans.Description)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Id = types.StringPointerValue(ans.Id)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &lanNetworkRsModel_eXzfzFj_Config{}

		var14, var15 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DefaultRouters)
		state.Ipv4Config.DefaultRouters = var14
		resp.Diagnostics.Append(var15.Errors()...)

		if ans.Ipv4Config.DhcpRelay == nil {
			state.Ipv4Config.DhcpRelay = nil
		} else {
			state.Ipv4Config.DhcpRelay = &lanNetworkRsModel_mCcgFKg_Config{}

			state.Ipv4Config.DhcpRelay.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Enabled)

			if ans.Ipv4Config.DhcpRelay.Option82 == nil {
				state.Ipv4Config.DhcpRelay.Option82 = nil
			} else {
				state.Ipv4Config.DhcpRelay.Option82 = &lanNetworkRsModel_tOChZgD_Config{}

				state.Ipv4Config.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.CircuitId)

				state.Ipv4Config.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Option82.Enabled)

				state.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

				state.Ipv4Config.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.RemoteId)
			}

			var16, var17 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpRelay.ServerIps)
			state.Ipv4Config.DhcpRelay.ServerIps = var16
			resp.Diagnostics.Append(var17.Errors()...)

			state.Ipv4Config.DhcpRelay.SourceInterface = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.SourceInterface)
		}

		if ans.Ipv4Config.DhcpServer == nil {
			state.Ipv4Config.DhcpServer = nil
		} else {
			state.Ipv4Config.DhcpServer = &lanNetworkRsModel_jGvcCTz_Config{}

			state.Ipv4Config.DhcpServer.BroadcastAddress = types.StringPointerValue(ans.Ipv4Config.DhcpServer.BroadcastAddress)

			if len(ans.Ipv4Config.DhcpServer.CustomOptions) == 0 {
				state.Ipv4Config.DhcpServer.CustomOptions = nil
			} else {
				state.Ipv4Config.DhcpServer.CustomOptions = make([]lanNetworkRsModel_lrzxLXR_Config, 0, len(ans.Ipv4Config.DhcpServer.CustomOptions))
				for _, var18 := range ans.Ipv4Config.DhcpServer.CustomOptions {
					var19 := lanNetworkRsModel_lrzxLXR_Config{}

					var19.OptionDefinition = types.StringValue(var18.OptionDefinition)

					var19.OptionValue = types.StringValue(var18.OptionValue)
					state.Ipv4Config.DhcpServer.CustomOptions = append(state.Ipv4Config.DhcpServer.CustomOptions, var19)
				}
			}

			state.Ipv4Config.DhcpServer.DefaultLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.DefaultLeaseTime)

			state.Ipv4Config.DhcpServer.Description = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Description)

			state.Ipv4Config.DhcpServer.Disabled = types.BoolPointerValue(ans.Ipv4Config.DhcpServer.Disabled)

			var20, var21 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.DnsServers)
			state.Ipv4Config.DhcpServer.DnsServers = var20
			resp.Diagnostics.Append(var21.Errors()...)

			state.Ipv4Config.DhcpServer.DomainName = types.StringPointerValue(ans.Ipv4Config.DhcpServer.DomainName)

			state.Ipv4Config.DhcpServer.Gateway = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Gateway)

			state.Ipv4Config.DhcpServer.Id = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Id)

			if len(ans.Ipv4Config.DhcpServer.IpRanges) == 0 {
				state.Ipv4Config.DhcpServer.IpRanges = nil
			} else {
				state.Ipv4Config.DhcpServer.IpRanges = make([]lanNetworkRsModel_xygFTDt_Config, 0, len(ans.Ipv4Config.DhcpServer.IpRanges))
				for _, var22 := range ans.Ipv4Config.DhcpServer.IpRanges {
					var23 := lanNetworkRsModel_xygFTDt_Config{}

					var23.EndIp = types.StringValue(var22.EndIp)

					var23.StartIp = types.StringValue(var22.StartIp)
					state.Ipv4Config.DhcpServer.IpRanges = append(state.Ipv4Config.DhcpServer.IpRanges, var23)
				}
			}

			state.Ipv4Config.DhcpServer.MaxLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.MaxLeaseTime)

			state.Ipv4Config.DhcpServer.NetworkContextId = types.StringPointerValue(ans.Ipv4Config.DhcpServer.NetworkContextId)

			if len(ans.Ipv4Config.DhcpServer.StaticMappings) == 0 {
				state.Ipv4Config.DhcpServer.StaticMappings = nil
			} else {
				state.Ipv4Config.DhcpServer.StaticMappings = make([]lanNetworkRsModel_yKYCDSK_Config, 0, len(ans.Ipv4Config.DhcpServer.StaticMappings))
				for _, var24 := range ans.Ipv4Config.DhcpServer.StaticMappings {
					var25 := lanNetworkRsModel_yKYCDSK_Config{}

					var25.IpAddress = types.StringValue(var24.IpAddress)

					var25.Mac = types.StringPointerValue(var24.Mac)

					var25.Name = types.StringValue(var24.Name)
					state.Ipv4Config.DhcpServer.StaticMappings = append(state.Ipv4Config.DhcpServer.StaticMappings, var25)
				}
			}

			state.Ipv4Config.DhcpServer.Subnet = types.StringValue(ans.Ipv4Config.DhcpServer.Subnet)

			var26, var27 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.Tags)
			state.Ipv4Config.DhcpServer.Tags = var26
			resp.Diagnostics.Append(var27.Errors()...)
		}

		var28, var29 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.Prefixes)
		state.Ipv4Config.Prefixes = var28
		resp.Diagnostics.Append(var29.Errors()...)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &lanNetworkRsModel_xXKbjbR_Config{}

		var30, var31 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DefaultRouters)
		state.Ipv6Config.DefaultRouters = var30
		resp.Diagnostics.Append(var31.Errors()...)

		var32, var33 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.Prefixes)
		state.Ipv6Config.Prefixes = var32
		resp.Diagnostics.Append(var33.Errors()...)
	}

	state.Name = types.StringValue(ans.Name)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Scope = types.StringValue(ans.Scope)

	var34, var35 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var34
	resp.Diagnostics.Append(var35.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Read performs Read for the struct.
func (r *lanNetworkResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var savestate, state lanNetworkRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := savestate.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 2 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 2 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "prismasdwan_lan_network",
		"locMap":                      map[string]int{"lannetwork_id": 1, "site_id": 0},
		"tokens":                      tokens,
	})

	// Prepare to read the config.
	svc := wHGMtfb.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := wHGMtfb.ReadInput{}

	input.SiteId = tokens[0]

	input.LannetworkId = tokens[1]

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading config", err.Error())
		}
		return
	}

	// Store the answer to state.

	if tokens[0] == "" {
		state.SiteId = types.StringNull()
	} else {
		state.SiteId = types.StringValue(tokens[0])
	}
	state.Tfid = savestate.Tfid

	state.Description = types.StringPointerValue(ans.Description)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Id = types.StringPointerValue(ans.Id)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &lanNetworkRsModel_eXzfzFj_Config{}

		var0, var1 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DefaultRouters)
		state.Ipv4Config.DefaultRouters = var0
		resp.Diagnostics.Append(var1.Errors()...)

		if ans.Ipv4Config.DhcpRelay == nil {
			state.Ipv4Config.DhcpRelay = nil
		} else {
			state.Ipv4Config.DhcpRelay = &lanNetworkRsModel_mCcgFKg_Config{}

			state.Ipv4Config.DhcpRelay.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Enabled)

			if ans.Ipv4Config.DhcpRelay.Option82 == nil {
				state.Ipv4Config.DhcpRelay.Option82 = nil
			} else {
				state.Ipv4Config.DhcpRelay.Option82 = &lanNetworkRsModel_tOChZgD_Config{}

				state.Ipv4Config.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.CircuitId)

				state.Ipv4Config.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Option82.Enabled)

				state.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

				state.Ipv4Config.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.RemoteId)
			}

			var2, var3 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpRelay.ServerIps)
			state.Ipv4Config.DhcpRelay.ServerIps = var2
			resp.Diagnostics.Append(var3.Errors()...)

			state.Ipv4Config.DhcpRelay.SourceInterface = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.SourceInterface)
		}

		if ans.Ipv4Config.DhcpServer == nil {
			state.Ipv4Config.DhcpServer = nil
		} else {
			state.Ipv4Config.DhcpServer = &lanNetworkRsModel_jGvcCTz_Config{}

			state.Ipv4Config.DhcpServer.BroadcastAddress = types.StringPointerValue(ans.Ipv4Config.DhcpServer.BroadcastAddress)

			if len(ans.Ipv4Config.DhcpServer.CustomOptions) == 0 {
				state.Ipv4Config.DhcpServer.CustomOptions = nil
			} else {
				state.Ipv4Config.DhcpServer.CustomOptions = make([]lanNetworkRsModel_lrzxLXR_Config, 0, len(ans.Ipv4Config.DhcpServer.CustomOptions))
				for _, var4 := range ans.Ipv4Config.DhcpServer.CustomOptions {
					var5 := lanNetworkRsModel_lrzxLXR_Config{}

					var5.OptionDefinition = types.StringValue(var4.OptionDefinition)

					var5.OptionValue = types.StringValue(var4.OptionValue)
					state.Ipv4Config.DhcpServer.CustomOptions = append(state.Ipv4Config.DhcpServer.CustomOptions, var5)
				}
			}

			state.Ipv4Config.DhcpServer.DefaultLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.DefaultLeaseTime)

			state.Ipv4Config.DhcpServer.Description = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Description)

			state.Ipv4Config.DhcpServer.Disabled = types.BoolPointerValue(ans.Ipv4Config.DhcpServer.Disabled)

			var6, var7 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.DnsServers)
			state.Ipv4Config.DhcpServer.DnsServers = var6
			resp.Diagnostics.Append(var7.Errors()...)

			state.Ipv4Config.DhcpServer.DomainName = types.StringPointerValue(ans.Ipv4Config.DhcpServer.DomainName)

			state.Ipv4Config.DhcpServer.Gateway = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Gateway)

			state.Ipv4Config.DhcpServer.Id = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Id)

			if len(ans.Ipv4Config.DhcpServer.IpRanges) == 0 {
				state.Ipv4Config.DhcpServer.IpRanges = nil
			} else {
				state.Ipv4Config.DhcpServer.IpRanges = make([]lanNetworkRsModel_xygFTDt_Config, 0, len(ans.Ipv4Config.DhcpServer.IpRanges))
				for _, var8 := range ans.Ipv4Config.DhcpServer.IpRanges {
					var9 := lanNetworkRsModel_xygFTDt_Config{}

					var9.EndIp = types.StringValue(var8.EndIp)

					var9.StartIp = types.StringValue(var8.StartIp)
					state.Ipv4Config.DhcpServer.IpRanges = append(state.Ipv4Config.DhcpServer.IpRanges, var9)
				}
			}

			state.Ipv4Config.DhcpServer.MaxLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.MaxLeaseTime)

			state.Ipv4Config.DhcpServer.NetworkContextId = types.StringPointerValue(ans.Ipv4Config.DhcpServer.NetworkContextId)

			if len(ans.Ipv4Config.DhcpServer.StaticMappings) == 0 {
				state.Ipv4Config.DhcpServer.StaticMappings = nil
			} else {
				state.Ipv4Config.DhcpServer.StaticMappings = make([]lanNetworkRsModel_yKYCDSK_Config, 0, len(ans.Ipv4Config.DhcpServer.StaticMappings))
				for _, var10 := range ans.Ipv4Config.DhcpServer.StaticMappings {
					var11 := lanNetworkRsModel_yKYCDSK_Config{}

					var11.IpAddress = types.StringValue(var10.IpAddress)

					var11.Mac = types.StringPointerValue(var10.Mac)

					var11.Name = types.StringValue(var10.Name)
					state.Ipv4Config.DhcpServer.StaticMappings = append(state.Ipv4Config.DhcpServer.StaticMappings, var11)
				}
			}

			state.Ipv4Config.DhcpServer.Subnet = types.StringValue(ans.Ipv4Config.DhcpServer.Subnet)

			var12, var13 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.Tags)
			state.Ipv4Config.DhcpServer.Tags = var12
			resp.Diagnostics.Append(var13.Errors()...)
		}

		var14, var15 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.Prefixes)
		state.Ipv4Config.Prefixes = var14
		resp.Diagnostics.Append(var15.Errors()...)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &lanNetworkRsModel_xXKbjbR_Config{}

		var16, var17 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DefaultRouters)
		state.Ipv6Config.DefaultRouters = var16
		resp.Diagnostics.Append(var17.Errors()...)

		var18, var19 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.Prefixes)
		state.Ipv6Config.Prefixes = var18
		resp.Diagnostics.Append(var19.Errors()...)
	}

	state.Name = types.StringValue(ans.Name)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Scope = types.StringValue(ans.Scope)

	var20, var21 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var20
	resp.Diagnostics.Append(var21.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update performs the Update for the struct.
func (r *lanNetworkResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state lanNetworkRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := state.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 2 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 2 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "prismasdwan_lan_network",
		"tfid":                        state.Tfid.ValueString(),
	})

	// Prepare to update the config.
	svc := wHGMtfb.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := wHGMtfb.UpdateInput{}

	if tokens[0] != "" {
		input.SiteId = tokens[0]
	}

	if tokens[1] != "" {
		input.LannetworkId = tokens[1]
	}
	input.Request = &yjUyRcw.Config{}

	input.Request.Description = ValueStringPointerFromPlanOrState(plan.Description, state.Description)

	input.Request.Etag = ValueInt64PointerFromPlanOrState(plan.Etag, state.Etag)

	if plan.Ipv4Config != nil {
		input.Request.Ipv4Config = &eXzfzFj.Config{}

		input.Request.Ipv4Config.DefaultRouters = ListStringValueOrNil(ctx, plan.Ipv4Config.DefaultRouters)

		if plan.Ipv4Config.DhcpRelay != nil {
			input.Request.Ipv4Config.DhcpRelay = &mCcgFKg.Config{}

			input.Request.Ipv4Config.DhcpRelay.Enabled = ValueBoolPointerFromPlanOrState(plan.Ipv4Config.DhcpRelay.Enabled, state.Ipv4Config.DhcpRelay.Enabled)

			if plan.Ipv4Config.DhcpRelay.Option82 != nil {
				input.Request.Ipv4Config.DhcpRelay.Option82 = &tOChZgD.Config{}

				input.Request.Ipv4Config.DhcpRelay.Option82.CircuitId = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpRelay.Option82.CircuitId, state.Ipv4Config.DhcpRelay.Option82.CircuitId)

				input.Request.Ipv4Config.DhcpRelay.Option82.Enabled = ValueBoolPointerFromPlanOrState(plan.Ipv4Config.DhcpRelay.Option82.Enabled, state.Ipv4Config.DhcpRelay.Option82.Enabled)

				input.Request.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = ValueStringFromPlanOrState(plan.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy, state.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

				input.Request.Ipv4Config.DhcpRelay.Option82.RemoteId = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpRelay.Option82.RemoteId, state.Ipv4Config.DhcpRelay.Option82.RemoteId)
			}

			input.Request.Ipv4Config.DhcpRelay.ServerIps = ListStringValueOrNil(ctx, plan.Ipv4Config.DhcpRelay.ServerIps)

			input.Request.Ipv4Config.DhcpRelay.SourceInterface = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpRelay.SourceInterface, state.Ipv4Config.DhcpRelay.SourceInterface)
		}

		if plan.Ipv4Config.DhcpServer != nil {
			input.Request.Ipv4Config.DhcpServer = &jGvcCTz.Config{}

			input.Request.Ipv4Config.DhcpServer.BroadcastAddress = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.BroadcastAddress, state.Ipv4Config.DhcpServer.BroadcastAddress)

			if len(plan.Ipv4Config.DhcpServer.CustomOptions) != 0 || len(state.Ipv4Config.DhcpServer.CustomOptions) != 0 {
				Ipv4ConfigDhcpServerCustomOptionsToUse := plan.Ipv4Config.DhcpServer.CustomOptions
				if len(plan.Ipv4Config.DhcpServer.CustomOptions) == 0 {
					Ipv4ConfigDhcpServerCustomOptionsToUse = state.Ipv4Config.DhcpServer.CustomOptions
				}
				input.Request.Ipv4Config.DhcpServer.CustomOptions = make([]lrzxLXR.Config, 0, len(Ipv4ConfigDhcpServerCustomOptionsToUse))
				for _, var2 := range plan.Ipv4Config.DhcpServer.CustomOptions {
					var var3 lrzxLXR.Config

					var3.OptionDefinition = StringValue(var2.OptionDefinition)

					var3.OptionValue = StringValue(var2.OptionValue)
					input.Request.Ipv4Config.DhcpServer.CustomOptions = append(input.Request.Ipv4Config.DhcpServer.CustomOptions, var3)
				}
			}

			input.Request.Ipv4Config.DhcpServer.DefaultLeaseTime = ValueInt64PointerFromPlanOrState(plan.Ipv4Config.DhcpServer.DefaultLeaseTime, state.Ipv4Config.DhcpServer.DefaultLeaseTime)

			input.Request.Ipv4Config.DhcpServer.Description = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.Description, state.Ipv4Config.DhcpServer.Description)

			input.Request.Ipv4Config.DhcpServer.Disabled = ValueBoolPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.Disabled, state.Ipv4Config.DhcpServer.Disabled)

			input.Request.Ipv4Config.DhcpServer.DnsServers = ListStringValueOrNil(ctx, plan.Ipv4Config.DhcpServer.DnsServers)

			input.Request.Ipv4Config.DhcpServer.DomainName = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.DomainName, state.Ipv4Config.DhcpServer.DomainName)

			input.Request.Ipv4Config.DhcpServer.Gateway = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.Gateway, state.Ipv4Config.DhcpServer.Gateway)

			input.Request.Ipv4Config.DhcpServer.Id = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.Id, state.Ipv4Config.DhcpServer.Id)

			if len(plan.Ipv4Config.DhcpServer.IpRanges) != 0 || len(state.Ipv4Config.DhcpServer.IpRanges) != 0 {
				Ipv4ConfigDhcpServerIpRangesToUse := plan.Ipv4Config.DhcpServer.IpRanges
				if len(plan.Ipv4Config.DhcpServer.IpRanges) == 0 {
					Ipv4ConfigDhcpServerIpRangesToUse = state.Ipv4Config.DhcpServer.IpRanges
				}
				input.Request.Ipv4Config.DhcpServer.IpRanges = make([]xygFTDt.Config, 0, len(Ipv4ConfigDhcpServerIpRangesToUse))
				for _, var5 := range plan.Ipv4Config.DhcpServer.IpRanges {
					var var6 xygFTDt.Config

					var6.EndIp = StringValue(var5.EndIp)

					var6.StartIp = StringValue(var5.StartIp)
					input.Request.Ipv4Config.DhcpServer.IpRanges = append(input.Request.Ipv4Config.DhcpServer.IpRanges, var6)
				}
			}

			input.Request.Ipv4Config.DhcpServer.MaxLeaseTime = ValueInt64PointerFromPlanOrState(plan.Ipv4Config.DhcpServer.MaxLeaseTime, state.Ipv4Config.DhcpServer.MaxLeaseTime)

			input.Request.Ipv4Config.DhcpServer.NetworkContextId = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpServer.NetworkContextId, state.Ipv4Config.DhcpServer.NetworkContextId)

			if len(plan.Ipv4Config.DhcpServer.StaticMappings) != 0 || len(state.Ipv4Config.DhcpServer.StaticMappings) != 0 {
				Ipv4ConfigDhcpServerStaticMappingsToUse := plan.Ipv4Config.DhcpServer.StaticMappings
				if len(plan.Ipv4Config.DhcpServer.StaticMappings) == 0 {
					Ipv4ConfigDhcpServerStaticMappingsToUse = state.Ipv4Config.DhcpServer.StaticMappings
				}
				input.Request.Ipv4Config.DhcpServer.StaticMappings = make([]yKYCDSK.Config, 0, len(Ipv4ConfigDhcpServerStaticMappingsToUse))
				for _, var7 := range plan.Ipv4Config.DhcpServer.StaticMappings {
					var var8 yKYCDSK.Config

					var8.IpAddress = StringValue(var7.IpAddress)

					var8.Mac = StringValueOrNil(var7.Mac)

					var8.Name = StringValue(var7.Name)
					input.Request.Ipv4Config.DhcpServer.StaticMappings = append(input.Request.Ipv4Config.DhcpServer.StaticMappings, var8)
				}
			}

			input.Request.Ipv4Config.DhcpServer.Subnet = ValueStringFromPlanOrState(plan.Ipv4Config.DhcpServer.Subnet, state.Ipv4Config.DhcpServer.Subnet)

			input.Request.Ipv4Config.DhcpServer.Tags = ListStringValueOrNil(ctx, plan.Ipv4Config.DhcpServer.Tags)
		}

		input.Request.Ipv4Config.Prefixes = ListStringValueOrNil(ctx, plan.Ipv4Config.Prefixes)
	}

	if plan.Ipv6Config != nil {
		input.Request.Ipv6Config = &xXKbjbR.Config{}

		input.Request.Ipv6Config.DefaultRouters = ListStringValueOrNil(ctx, plan.Ipv6Config.DefaultRouters)

		input.Request.Ipv6Config.Prefixes = ListStringValueOrNil(ctx, plan.Ipv6Config.Prefixes)
	}

	input.Request.Name = ValueStringFromPlanOrState(plan.Name, state.Name)

	input.Request.NetworkContextId = ValueStringPointerFromPlanOrState(plan.NetworkContextId, state.NetworkContextId)

	input.Request.Scope = ValueStringFromPlanOrState(plan.Scope, state.Scope)

	input.Request.Tags = ListStringValueOrNil(ctx, plan.Tags)

	input.Request.VrfContextId = ValueStringPointerFromPlanOrState(plan.VrfContextId, state.VrfContextId)

	// Perform the operation.
	ans, err := svc.Update(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error updating resource", err.Error())
		}
		return
	}

	// Store the answer to state.
	// Note: when supporting importing a resource, this will need to change to taking
	// values from the savestate.Tfid param and locMap.

	state.Description = types.StringPointerValue(ans.Description)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Id = types.StringPointerValue(ans.Id)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &lanNetworkRsModel_eXzfzFj_Config{}

		var14, var15 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DefaultRouters)
		state.Ipv4Config.DefaultRouters = var14
		resp.Diagnostics.Append(var15.Errors()...)

		if ans.Ipv4Config.DhcpRelay == nil {
			state.Ipv4Config.DhcpRelay = nil
		} else {
			state.Ipv4Config.DhcpRelay = &lanNetworkRsModel_mCcgFKg_Config{}

			state.Ipv4Config.DhcpRelay.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Enabled)

			if ans.Ipv4Config.DhcpRelay.Option82 == nil {
				state.Ipv4Config.DhcpRelay.Option82 = nil
			} else {
				state.Ipv4Config.DhcpRelay.Option82 = &lanNetworkRsModel_tOChZgD_Config{}

				state.Ipv4Config.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.CircuitId)

				state.Ipv4Config.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.Ipv4Config.DhcpRelay.Option82.Enabled)

				state.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.Ipv4Config.DhcpRelay.Option82.ReforwardingPolicy)

				state.Ipv4Config.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.Option82.RemoteId)
			}

			var16, var17 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpRelay.ServerIps)
			state.Ipv4Config.DhcpRelay.ServerIps = var16
			resp.Diagnostics.Append(var17.Errors()...)

			state.Ipv4Config.DhcpRelay.SourceInterface = types.StringPointerValue(ans.Ipv4Config.DhcpRelay.SourceInterface)
		}

		if ans.Ipv4Config.DhcpServer == nil {
			state.Ipv4Config.DhcpServer = nil
		} else {
			state.Ipv4Config.DhcpServer = &lanNetworkRsModel_jGvcCTz_Config{}

			state.Ipv4Config.DhcpServer.BroadcastAddress = types.StringPointerValue(ans.Ipv4Config.DhcpServer.BroadcastAddress)

			if len(ans.Ipv4Config.DhcpServer.CustomOptions) == 0 {
				state.Ipv4Config.DhcpServer.CustomOptions = nil
			} else {
				state.Ipv4Config.DhcpServer.CustomOptions = make([]lanNetworkRsModel_lrzxLXR_Config, 0, len(ans.Ipv4Config.DhcpServer.CustomOptions))
				for _, var18 := range ans.Ipv4Config.DhcpServer.CustomOptions {
					var19 := lanNetworkRsModel_lrzxLXR_Config{}

					var19.OptionDefinition = types.StringValue(var18.OptionDefinition)

					var19.OptionValue = types.StringValue(var18.OptionValue)
					state.Ipv4Config.DhcpServer.CustomOptions = append(state.Ipv4Config.DhcpServer.CustomOptions, var19)
				}
			}

			state.Ipv4Config.DhcpServer.DefaultLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.DefaultLeaseTime)

			state.Ipv4Config.DhcpServer.Description = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Description)

			state.Ipv4Config.DhcpServer.Disabled = types.BoolPointerValue(ans.Ipv4Config.DhcpServer.Disabled)

			var20, var21 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.DnsServers)
			state.Ipv4Config.DhcpServer.DnsServers = var20
			resp.Diagnostics.Append(var21.Errors()...)

			state.Ipv4Config.DhcpServer.DomainName = types.StringPointerValue(ans.Ipv4Config.DhcpServer.DomainName)

			state.Ipv4Config.DhcpServer.Gateway = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Gateway)

			state.Ipv4Config.DhcpServer.Id = types.StringPointerValue(ans.Ipv4Config.DhcpServer.Id)

			if len(ans.Ipv4Config.DhcpServer.IpRanges) == 0 {
				state.Ipv4Config.DhcpServer.IpRanges = nil
			} else {
				state.Ipv4Config.DhcpServer.IpRanges = make([]lanNetworkRsModel_xygFTDt_Config, 0, len(ans.Ipv4Config.DhcpServer.IpRanges))
				for _, var22 := range ans.Ipv4Config.DhcpServer.IpRanges {
					var23 := lanNetworkRsModel_xygFTDt_Config{}

					var23.EndIp = types.StringValue(var22.EndIp)

					var23.StartIp = types.StringValue(var22.StartIp)
					state.Ipv4Config.DhcpServer.IpRanges = append(state.Ipv4Config.DhcpServer.IpRanges, var23)
				}
			}

			state.Ipv4Config.DhcpServer.MaxLeaseTime = types.Int64PointerValue(ans.Ipv4Config.DhcpServer.MaxLeaseTime)

			state.Ipv4Config.DhcpServer.NetworkContextId = types.StringPointerValue(ans.Ipv4Config.DhcpServer.NetworkContextId)

			if len(ans.Ipv4Config.DhcpServer.StaticMappings) == 0 {
				state.Ipv4Config.DhcpServer.StaticMappings = nil
			} else {
				state.Ipv4Config.DhcpServer.StaticMappings = make([]lanNetworkRsModel_yKYCDSK_Config, 0, len(ans.Ipv4Config.DhcpServer.StaticMappings))
				for _, var24 := range ans.Ipv4Config.DhcpServer.StaticMappings {
					var25 := lanNetworkRsModel_yKYCDSK_Config{}

					var25.IpAddress = types.StringValue(var24.IpAddress)

					var25.Mac = types.StringPointerValue(var24.Mac)

					var25.Name = types.StringValue(var24.Name)
					state.Ipv4Config.DhcpServer.StaticMappings = append(state.Ipv4Config.DhcpServer.StaticMappings, var25)
				}
			}

			state.Ipv4Config.DhcpServer.Subnet = types.StringValue(ans.Ipv4Config.DhcpServer.Subnet)

			var26, var27 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DhcpServer.Tags)
			state.Ipv4Config.DhcpServer.Tags = var26
			resp.Diagnostics.Append(var27.Errors()...)
		}

		var28, var29 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.Prefixes)
		state.Ipv4Config.Prefixes = var28
		resp.Diagnostics.Append(var29.Errors()...)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &lanNetworkRsModel_xXKbjbR_Config{}

		var30, var31 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DefaultRouters)
		state.Ipv6Config.DefaultRouters = var30
		resp.Diagnostics.Append(var31.Errors()...)

		var32, var33 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.Prefixes)
		state.Ipv6Config.Prefixes = var32
		resp.Diagnostics.Append(var33.Errors()...)
	}

	state.Name = types.StringValue(ans.Name)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Scope = types.StringValue(ans.Scope)

	var34, var35 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var34
	resp.Diagnostics.Append(var35.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete performs delete for the struct.
func (r *lanNetworkResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var idType types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("tfid"), &idType)...)
	if resp.Diagnostics.HasError() {
		return
	}
	tfid := idType.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 2 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 2 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "prismasdwan_lan_network",
		"locMap":                      map[string]int{"lannetwork_id": 1, "site_id": 0},
		"tokens":                      tokens,
	})

	svc := wHGMtfb.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := wHGMtfb.DeleteInput{}

	input.SiteId = tokens[0]

	input.LannetworkId = tokens[1]

	// Perform the operation.
	if _, err := svc.Delete(ctx, input); err != nil && !IsObjectNotFound(err) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}
}

func (r *lanNetworkResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"strings"

	sdwan "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk"
	sdwan_schema "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas"
	sdwan_client "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/services"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidwall/sjson"
)

// +-----------------------------------------------------------------
// | Schema Map Summary (size=goLangStructMap=12)
// | Computed Resource Name=sites_elementshells
// +-----------------------------------------------------------------
// | IntraClusterTunnel HasID=false
// | Host HasID=false
// | Tracker HasID=false
// | HubClusterConfig HasID=false
// | LedConfig HasID=false
// | SwitchConfig HasID=false
// | TrackWANInterface HasID=false
// | TrackInterface HasID=false
// | TrackV2 HasID=false
// | SpokeHAConfigV2 HasID=false
// | Software HasID=false
// | ElementScreenV3N2 HasID=true
// +-----------------------------------------------------------------

// Resource.
var (
	_ resource.Resource                = &elementShellResource{}
	_ resource.ResourceWithConfigure   = &elementShellResource{}
	_ resource.ResourceWithImportState = &elementShellResource{}
)

// To enable this data source for TF Provider, go to `provider.go` and inject this into the function
// as below:
//
//	func (p *SdwanProvider) Resources(_ context.Context) []func() resource.Resource {
//	  	return []func() resource.Resource{
//	     ... <other existing resources>
//	     NewElementShellResource,
//	     // -- append next resource above -- //
//	     }
//	  }
func NewElementShellResource() resource.Resource {
	return &elementShellResource{}
}

type elementShellResource struct {
	client *sdwan.Client
}

type ElementShellPostBody struct {
	TenantId        *string `json:"tenant_id"`
	SiteId          *string `json:"site_id"`
	SoftwareVersion *string `json:"software_version"`
	ModelName       *string `json:"model_name"`
	Name            *string `json:"name"`
	Role            *string `json:"role"`
	ClusterId       *string `json:"cluster_id"`
}

// Metadata returns the data source type name.
func (r *elementShellResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "prismasdwan_element_shell"
}

// Schema defines the schema for this data source.
func (r *elementShellResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",
		Attributes: map[string]rsschema.Attribute{
			"tfid": rsschema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			// rest all properties to be read from GET API Schema schema=ElementScreenV3N2
			// generic x_parameters is added to accomodate path parameters
			"x_parameters": rsschema.MapAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				ElementType: types.StringType,
			},
			// property: name=_etag, type=INTEGER macro=rss_schema
			"x_etag": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=_etag, type=INTEGER macro=rss_schema
			// property: name=_schema, type=INTEGER macro=rss_schema
			"x_schema": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=_schema, type=INTEGER macro=rss_schema
			// property: name=allowed_roles, type=ARRAY_PRIMITIVE macro=rss_schema
			"allowed_roles": rsschema.ListAttribute{
				Required:    false,
				Computed:    true,
				Optional:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
			// key name holder for attribute: name=allowed_roles, type=ARRAY_PRIMITIVE macro=rss_schema
			// property: name=cluster_id, type=STRING macro=rss_schema
			"cluster_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=cluster_id, type=STRING macro=rss_schema
			// property: name=cluster_insertion_mode, type=STRING macro=rss_schema
			"cluster_insertion_mode": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=cluster_insertion_mode, type=STRING macro=rss_schema
			// property: name=cluster_member_id, type=STRING macro=rss_schema
			"cluster_member_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=cluster_member_id, type=STRING macro=rss_schema
			// property: name=description, type=STRING macro=rss_schema
			"description": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=description, type=STRING macro=rss_schema
			// property: name=device_mode, type=STRING macro=rss_schema
			"device_mode": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=device_mode, type=STRING macro=rss_schema
			// property: name=device_profile_id, type=STRING macro=rss_schema
			"device_profile_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=device_profile_id, type=STRING macro=rss_schema
			// property: name=element_id, type=STRING macro=rss_schema
			"element_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=element_id, type=STRING macro=rss_schema
			// property: name=hub_cluster_config, type=REFERENCE macro=rss_schema
			"hub_cluster_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=intra_cluster_tunnel, type=REFERENCE macro=rss_schema
					"intra_cluster_tunnel": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=destination_ip, type=STRING macro=rss_schema
							"destination_ip": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=destination_ip, type=STRING macro=rss_schema
							// property: name=source_ip, type=STRING macro=rss_schema
							"source_ip": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=source_ip, type=STRING macro=rss_schema
							// property: name=status, type=STRING macro=rss_schema
							"status": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=status, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=status, type=STRING macro=rss_schema
					// property: name=track, type=REFERENCE macro=rss_schema
					"track": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=hosts, type=ARRAY_REFERENCE macro=rss_schema
							"hosts": rsschema.ListNestedAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// property: name=address_v4, type=STRING macro=rss_schema
										"address_v4": rsschema.StringAttribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=address_v4, type=STRING macro=rss_schema
										// property: name=address_v6, type=STRING macro=rss_schema
										"address_v6": rsschema.StringAttribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=address_v6, type=STRING macro=rss_schema
										// property: name=vrf_context_id, type=STRING macro=rss_schema
										"vrf_context_id": rsschema.StringAttribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=vrf_context_id, type=STRING macro=rss_schema
									},
								},
							},
							// key name holder for attribute: name=vrf_context_id, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=vrf_context_id, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=vrf_context_id, type=STRING macro=rss_schema
			// property: name=hw_id, type=STRING macro=rss_schema
			"hw_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=hw_id, type=STRING macro=rss_schema
			// property: name=id, type=STRING macro=rss_schema
			"id": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=id, type=STRING macro=rss_schema
			// property: name=l3_direct_private_wan_forwarding, type=BOOLEAN macro=rss_schema
			"l3_direct_private_wan_forwarding": rsschema.BoolAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=l3_direct_private_wan_forwarding, type=BOOLEAN macro=rss_schema
			// property: name=l3_lan_forwarding, type=BOOLEAN macro=rss_schema
			"l3_lan_forwarding": rsschema.BoolAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=l3_lan_forwarding, type=BOOLEAN macro=rss_schema
			// property: name=led_config, type=REFERENCE macro=rss_schema
			"led_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=service_led_on, type=BOOLEAN macro=rss_schema
					"service_led_on": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=service_led_on, type=BOOLEAN macro=rss_schema
				},
			},
			// key name holder for attribute: name=service_led_on, type=BOOLEAN macro=rss_schema
			// property: name=main_power_usage_threshold, type=INTEGER macro=rss_schema
			"main_power_usage_threshold": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=main_power_usage_threshold, type=INTEGER macro=rss_schema
			// property: name=model_name, type=STRING macro=rss_schema
			"model_name": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=model_name, type=STRING macro=rss_schema
			// property: name=name, type=STRING macro=rss_schema
			"name": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=name, type=STRING macro=rss_schema
			// property: name=nat_policysetstack_id, type=STRING macro=rss_schema
			"nat_policysetstack_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=nat_policysetstack_id, type=STRING macro=rss_schema
			// property: name=network_policysetstack_id, type=STRING macro=rss_schema
			"network_policysetstack_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=network_policysetstack_id, type=STRING macro=rss_schema
			// property: name=priority_policysetstack_id, type=STRING macro=rss_schema
			"priority_policysetstack_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=priority_policysetstack_id, type=STRING macro=rss_schema
			// property: name=role, type=STRING macro=rss_schema
			"role": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=role, type=STRING macro=rss_schema
			// property: name=site_id, type=STRING macro=rss_schema
			"site_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=site_id, type=STRING macro=rss_schema
			// property: name=software_version, type=STRING macro=rss_schema
			"software_version": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=software_version, type=STRING macro=rss_schema
			// property: name=spoke_ha_config, type=REFERENCE macro=rss_schema
			"spoke_ha_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=cluster_id, type=STRING macro=rss_schema
					"cluster_id": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=cluster_id, type=STRING macro=rss_schema
					// property: name=enable, type=BOOLEAN macro=rss_schema
					"enable": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=enable, type=BOOLEAN macro=rss_schema
					// property: name=priority, type=INTEGER macro=rss_schema
					"priority": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=priority, type=INTEGER macro=rss_schema
					// property: name=source_interface, type=STRING macro=rss_schema
					"source_interface": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=source_interface, type=STRING macro=rss_schema
					// property: name=track, type=REFERENCE macro=rss_schema
					"track": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=interfaces, type=ARRAY_REFERENCE macro=rss_schema
							"interfaces": rsschema.ListNestedAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// property: name=interface_id, type=STRING macro=rss_schema
										"interface_id": rsschema.StringAttribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=interface_id, type=STRING macro=rss_schema
										// property: name=reduce_priority, type=INTEGER macro=rss_schema
										"reduce_priority": rsschema.Int64Attribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=reduce_priority, type=INTEGER macro=rss_schema
									},
								},
							},
							// key name holder for attribute: name=reduce_priority, type=INTEGER macro=rss_schema
							// property: name=waninterfaces, type=ARRAY_REFERENCE macro=rss_schema
							"waninterfaces": rsschema.ListNestedAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
								NestedObject: rsschema.NestedAttributeObject{
									Attributes: map[string]rsschema.Attribute{
										// property: name=reduce_priority, type=INTEGER macro=rss_schema
										"reduce_priority": rsschema.Int64Attribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=reduce_priority, type=INTEGER macro=rss_schema
										// property: name=wan_interface_id, type=STRING macro=rss_schema
										"wan_interface_id": rsschema.StringAttribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=wan_interface_id, type=STRING macro=rss_schema
									},
								},
							},
							// key name holder for attribute: name=wan_interface_id, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=wan_interface_id, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=wan_interface_id, type=STRING macro=rss_schema
			// property: name=state, type=STRING macro=rss_schema
			"state": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=state, type=STRING macro=rss_schema
			// property: name=sw_obj, type=REFERENCE macro=rss_schema
			"sw_obj": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=location, type=STRING macro=rss_schema
					"location": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=location, type=STRING macro=rss_schema
					// property: name=version, type=STRING macro=rss_schema
					"version": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=version, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=version, type=STRING macro=rss_schema
			// property: name=switch_config, type=REFERENCE macro=rss_schema
			"switch_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=default_vlan_id, type=INTEGER macro=rss_schema
					"default_vlan_id": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=default_vlan_id, type=INTEGER macro=rss_schema
					// property: name=mstp_enabled, type=BOOLEAN macro=rss_schema
					"mstp_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=mstp_enabled, type=BOOLEAN macro=rss_schema
					// property: name=stp_aging_timer, type=INTEGER macro=rss_schema
					"stp_aging_timer": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_aging_timer, type=INTEGER macro=rss_schema
					// property: name=stp_forward_delay, type=INTEGER macro=rss_schema
					"stp_forward_delay": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_forward_delay, type=INTEGER macro=rss_schema
					// property: name=stp_hello_time, type=INTEGER macro=rss_schema
					"stp_hello_time": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_hello_time, type=INTEGER macro=rss_schema
					// property: name=stp_max_age, type=INTEGER macro=rss_schema
					"stp_max_age": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_max_age, type=INTEGER macro=rss_schema
					// property: name=stp_mode, type=STRING macro=rss_schema
					"stp_mode": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_mode, type=STRING macro=rss_schema
					// property: name=stp_priority, type=INTEGER macro=rss_schema
					"stp_priority": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_priority, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=stp_priority, type=INTEGER macro=rss_schema
			// property: name=tags, type=SET_PRIMITIVE macro=rss_schema
			"tags": rsschema.SetAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
			// key name holder for attribute: name=tags, type=SET_PRIMITIVE macro=rss_schema
			// property: name=tenant_id, type=STRING macro=rss_schema
			"tenant_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=tenant_id, type=STRING macro=rss_schema
			// property: name=vpn_to_vpn_forwarding, type=BOOLEAN macro=rss_schema
			"vpn_to_vpn_forwarding": rsschema.BoolAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=vpn_to_vpn_forwarding, type=BOOLEAN macro=rss_schema
		},
	}
}

// Configure prepares the struct.
func (r *elementShellResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.client = req.ProviderData.(*sdwan.Client)
}

// in some apis the status code is not consistent and hence we may have to act upon
// specific error codes instead
func (r *elementShellResource) GetHttpStatusCode(request *sdwan_client.SdwanClientRequestResponse) int {
	if request.ResponseErrorCode == nil {
		return request.ResponseStatusCode
	}
	switch *request.ResponseErrorCode {
	case "OBJECT_NOT_FOUND":
		return 404
	default:
		return request.ResponseStatusCode
	}
}

func (r *elementShellResource) doPost(ctx context.Context, plan *rsModelElementScreenV3N2, state *rsModelElementScreenV3N2, resp *resource.CreateResponse) bool {
	tflog.Info(ctx, "executing http post for prismasdwan_element_shell")
	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "prismasdwan_element_shell",
		"terraform_provider_function": "Create",
	})

	create_request := &sdwan_client.SdwanClientRequestResponse{}
	create_request.ResourceType = "prismasdwan_element_shell"
	create_request.Method = "POST"
	create_request.Path = "/sdwan/v2.1/api/sites/{site_id}/elementshells"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, plan.TfParameters)
	create_request.PathParameters = &params

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// prepare request from state
	var body = &ElementShellPostBody{}

	// copy from plan to body of creation
	body.ModelName = StringValueOrNil(plan.ModelName)
	body.SoftwareVersion = StringValueOrNil(plan.SoftwareVersion)
	body.SiteId = StringValueOrNil(plan.SiteId)
	body.Role = StringValueOrNil(plan.Role)
	body.Name = StringValueOrNil(plan.Name)
	body.TenantId = StringValueOrNil(plan.TenantId)
	body.ClusterId = StringValueOrNil(plan.ClusterId)

	// convert body to map
	json_body, err := json.Marshal(body)
	if err != nil {
		resp.Diagnostics.AddError("error marshaling struct ElementScreenV3N2 to JSON:", err.Error())
		return false
	}

	// process http json path
	request_body_string := string(json_body)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete request_body_string::id")
	request_body_string, _ = sjson.Delete(request_body_string, "id")
	tflog.Debug(ctx, "http json override: delete request_body_string::_etag")
	request_body_string, _ = sjson.Delete(request_body_string, "_etag")
	tflog.Debug(ctx, "http json override: set request_body_string::_schema")
	request_body_string, _ = sjson.Set(request_body_string, "_schema", 0)
	// copy pointer
	create_request.RequestBody = &request_body_string

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, create_request)
	if create_request.ResponseErr != nil {
		tflog.Info(ctx, "create request failed for prismasdwan_element_shell", map[string]any{
			"terraform_provider_function": "Create",
			"resource_name":               "prismasdwan_element_shell",
			"path":                        create_request.FinalPath,
		})
		tflog.Debug(ctx, "create request failed for prismasdwan_element_shell", map[string]any{
			"terraform_provider_function": "Create",
			"resource_name":               "prismasdwan_element_shell",
			"path":                        create_request.FinalPath,
			"request":                     create_request.ToString(),
		})
		resp.Diagnostics.AddError("error creating prismasdwan_element_shell", (*create_request.ResponseErr).Error())
		return false
	}

	// process http json path
	response_body_string := string(*create_request.ResponseBytes)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete response_body_string::_created_on_utc")
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	tflog.Debug(ctx, "http json override: set response_body_string::_schema")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// start copying attributes
	var ans sdwan_schema.ElementScreenV3N2
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to ElementScreenV3N2 in create", json_err.Error())
		return false
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return false
	}
	// ID Format: Id:Param1=Value1:Param2=Value2:...:ParamN=ValueN
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
		for p, v := range *create_request.PathParameters {
			idBuilder.WriteString(IdSeparator)
			idBuilder.WriteString(p)
			idBuilder.WriteString("=")
			idBuilder.WriteString(*v)
		}
	}
	// set the tf id for the resource created
	state.Tfid = types.StringValue(idBuilder.String())
	state.TfParameters = plan.TfParameters
	tflog.Info(ctx, "created prismasdwan_element_shell with ID", map[string]any{"tfid": state.Tfid.ValueString()})

	// Store the answer to state. schema=ElementScreenV3N2
	// copy_to_state: state=state prefix=rsModel ans=ans properties=32
	tflog.Debug(ctx, "copy_to_state state=state prefix=rsModel ans=ans")
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=allowed_roles, type=ARRAY_PRIMITIVE macro=copy_to_state
	varAllowedRoles, errAllowedRoles := types.ListValueFrom(ctx, types.StringType, ans.AllowedRoles)
	state.AllowedRoles = varAllowedRoles
	resp.Diagnostics.Append(errAllowedRoles.Errors()...)
	// property: name=cluster_id, type=STRING macro=copy_to_state
	state.ClusterId = types.StringPointerValue(ans.ClusterId)
	// property: name=cluster_insertion_mode, type=STRING macro=copy_to_state
	state.ClusterInsertionMode = types.StringPointerValue(ans.ClusterInsertionMode)
	// property: name=cluster_member_id, type=STRING macro=copy_to_state
	state.ClusterMemberId = types.StringPointerValue(ans.ClusterMemberId)
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=device_mode, type=STRING macro=copy_to_state
	state.DeviceMode = types.StringPointerValue(ans.DeviceMode)
	// property: name=device_profile_id, type=STRING macro=copy_to_state
	state.DeviceProfileId = types.StringPointerValue(ans.DeviceProfileId)
	// property: name=element_id, type=STRING macro=copy_to_state
	state.ElementId = types.StringPointerValue(ans.ElementId)
	// property: name=hub_cluster_config, type=REFERENCE macro=copy_to_state
	if ans.HubClusterConfig == nil {
		state.HubClusterConfig = nil
	} else {
		state.HubClusterConfig = &rsModelHubClusterConfig{}
		// copy_to_state: state=state.HubClusterConfig prefix=rsModel ans=ans.HubClusterConfig properties=2
		tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig prefix=rsModel ans=ans.HubClusterConfig")
		// property: name=intra_cluster_tunnel, type=REFERENCE macro=copy_to_state
		if ans.HubClusterConfig.IntraClusterTunnel == nil {
			state.HubClusterConfig.IntraClusterTunnel = nil
		} else {
			state.HubClusterConfig.IntraClusterTunnel = &rsModelIntraClusterTunnel{}
			// copy_to_state: state=state.HubClusterConfig.IntraClusterTunnel prefix=rsModel ans=ans.HubClusterConfig.IntraClusterTunnel properties=3
			tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.IntraClusterTunnel prefix=rsModel ans=ans.HubClusterConfig.IntraClusterTunnel")
			// property: name=destination_ip, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.DestinationIp = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.DestinationIp)
			// property: name=source_ip, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.SourceIp = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.SourceIp)
			// property: name=status, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.Status = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.Status)
		}
		// property: name=track, type=REFERENCE macro=copy_to_state
		if ans.HubClusterConfig.Track == nil {
			state.HubClusterConfig.Track = nil
		} else {
			state.HubClusterConfig.Track = &rsModelTracker{}
			// copy_to_state: state=state.HubClusterConfig.Track prefix=rsModel ans=ans.HubClusterConfig.Track properties=1
			tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.Track prefix=rsModel ans=ans.HubClusterConfig.Track")
			// property: name=hosts, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.HubClusterConfig.Track.Hosts == nil {
				state.HubClusterConfig.Track.Hosts = nil
			} else if len(ans.HubClusterConfig.Track.Hosts) == 0 {
				state.HubClusterConfig.Track.Hosts = []rsModelHost{}
			} else {
				state.HubClusterConfig.Track.Hosts = make([]rsModelHost, 0, len(ans.HubClusterConfig.Track.Hosts))
				for varLoopHostsIndex, varLoopHosts := range ans.HubClusterConfig.Track.Hosts {
					// add a new item
					state.HubClusterConfig.Track.Hosts = append(state.HubClusterConfig.Track.Hosts, rsModelHost{})
					// copy_to_state: state=state.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel ans=varLoopHosts properties=3
					tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel ans=varLoopHosts")
					// property: name=address_v4, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV4 = types.StringPointerValue(varLoopHosts.AddressV4)
					// property: name=address_v6, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV6 = types.StringPointerValue(varLoopHosts.AddressV6)
					// property: name=vrf_context_id, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].VrfContextId = types.StringPointerValue(varLoopHosts.VrfContextId)
				}
			}
		}
	}
	// property: name=hw_id, type=STRING macro=copy_to_state
	state.HwId = types.StringPointerValue(ans.HwId)
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=l3_direct_private_wan_forwarding, type=BOOLEAN macro=copy_to_state
	state.L3DirectPrivateWanForwarding = types.BoolPointerValue(ans.L3DirectPrivateWanForwarding)
	// property: name=l3_lan_forwarding, type=BOOLEAN macro=copy_to_state
	state.L3LanForwarding = types.BoolPointerValue(ans.L3LanForwarding)
	// property: name=led_config, type=REFERENCE macro=copy_to_state
	if ans.LedConfig == nil {
		state.LedConfig = nil
	} else {
		state.LedConfig = &rsModelLedConfig{}
		// copy_to_state: state=state.LedConfig prefix=rsModel ans=ans.LedConfig properties=1
		tflog.Debug(ctx, "copy_to_state state=state.LedConfig prefix=rsModel ans=ans.LedConfig")
		// property: name=service_led_on, type=BOOLEAN macro=copy_to_state
		state.LedConfig.ServiceLedOn = types.BoolPointerValue(ans.LedConfig.ServiceLedOn)
	}
	// property: name=main_power_usage_threshold, type=INTEGER macro=copy_to_state
	state.MainPowerUsageThreshold = types.Int64PointerValue(ans.MainPowerUsageThreshold)
	// property: name=model_name, type=STRING macro=copy_to_state
	state.ModelName = types.StringPointerValue(ans.ModelName)
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=nat_policysetstack_id, type=STRING macro=copy_to_state
	state.NatPolicysetstackId = types.StringPointerValue(ans.NatPolicysetstackId)
	// property: name=network_policysetstack_id, type=STRING macro=copy_to_state
	state.NetworkPolicysetstackId = types.StringPointerValue(ans.NetworkPolicysetstackId)
	// property: name=priority_policysetstack_id, type=STRING macro=copy_to_state
	state.PriorityPolicysetstackId = types.StringPointerValue(ans.PriorityPolicysetstackId)
	// property: name=role, type=STRING macro=copy_to_state
	state.Role = types.StringPointerValue(ans.Role)
	// property: name=site_id, type=STRING macro=copy_to_state
	state.SiteId = types.StringPointerValue(ans.SiteId)
	// property: name=software_version, type=STRING macro=copy_to_state
	state.SoftwareVersion = types.StringPointerValue(ans.SoftwareVersion)
	// property: name=spoke_ha_config, type=REFERENCE macro=copy_to_state
	if ans.SpokeHaConfig == nil {
		state.SpokeHaConfig = nil
	} else {
		state.SpokeHaConfig = &rsModelSpokeHAConfigV2{}
		// copy_to_state: state=state.SpokeHaConfig prefix=rsModel ans=ans.SpokeHaConfig properties=5
		tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig prefix=rsModel ans=ans.SpokeHaConfig")
		// property: name=cluster_id, type=STRING macro=copy_to_state
		state.SpokeHaConfig.ClusterId = types.StringPointerValue(ans.SpokeHaConfig.ClusterId)
		// property: name=enable, type=BOOLEAN macro=copy_to_state
		state.SpokeHaConfig.Enable = types.BoolPointerValue(ans.SpokeHaConfig.Enable)
		// property: name=priority, type=INTEGER macro=copy_to_state
		state.SpokeHaConfig.Priority = types.Int64PointerValue(ans.SpokeHaConfig.Priority)
		// property: name=source_interface, type=STRING macro=copy_to_state
		state.SpokeHaConfig.SourceInterface = types.StringPointerValue(ans.SpokeHaConfig.SourceInterface)
		// property: name=track, type=REFERENCE macro=copy_to_state
		if ans.SpokeHaConfig.Track == nil {
			state.SpokeHaConfig.Track = nil
		} else {
			state.SpokeHaConfig.Track = &rsModelTrackV2{}
			// copy_to_state: state=state.SpokeHaConfig.Track prefix=rsModel ans=ans.SpokeHaConfig.Track properties=2
			tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track prefix=rsModel ans=ans.SpokeHaConfig.Track")
			// property: name=interfaces, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.SpokeHaConfig.Track.Interfaces == nil {
				state.SpokeHaConfig.Track.Interfaces = nil
			} else if len(ans.SpokeHaConfig.Track.Interfaces) == 0 {
				state.SpokeHaConfig.Track.Interfaces = []rsModelTrackInterface{}
			} else {
				state.SpokeHaConfig.Track.Interfaces = make([]rsModelTrackInterface, 0, len(ans.SpokeHaConfig.Track.Interfaces))
				for varLoopInterfacesIndex, varLoopInterfaces := range ans.SpokeHaConfig.Track.Interfaces {
					// add a new item
					state.SpokeHaConfig.Track.Interfaces = append(state.SpokeHaConfig.Track.Interfaces, rsModelTrackInterface{})
					// copy_to_state: state=state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel ans=varLoopInterfaces properties=2
					tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel ans=varLoopInterfaces")
					// property: name=interface_id, type=STRING macro=copy_to_state
					state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].InterfaceId = types.StringPointerValue(varLoopInterfaces.InterfaceId)
					// property: name=reduce_priority, type=INTEGER macro=copy_to_state
					state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].ReducePriority = types.Int64PointerValue(varLoopInterfaces.ReducePriority)
				}
			}
			// property: name=waninterfaces, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.SpokeHaConfig.Track.Waninterfaces == nil {
				state.SpokeHaConfig.Track.Waninterfaces = nil
			} else if len(ans.SpokeHaConfig.Track.Waninterfaces) == 0 {
				state.SpokeHaConfig.Track.Waninterfaces = []rsModelTrackWANInterface{}
			} else {
				state.SpokeHaConfig.Track.Waninterfaces = make([]rsModelTrackWANInterface, 0, len(ans.SpokeHaConfig.Track.Waninterfaces))
				for varLoopWaninterfacesIndex, varLoopWaninterfaces := range ans.SpokeHaConfig.Track.Waninterfaces {
					// add a new item
					state.SpokeHaConfig.Track.Waninterfaces = append(state.SpokeHaConfig.Track.Waninterfaces, rsModelTrackWANInterface{})
					// copy_to_state: state=state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel ans=varLoopWaninterfaces properties=2
					tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel ans=varLoopWaninterfaces")
					// property: name=reduce_priority, type=INTEGER macro=copy_to_state
					state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].ReducePriority = types.Int64PointerValue(varLoopWaninterfaces.ReducePriority)
					// property: name=wan_interface_id, type=STRING macro=copy_to_state
					state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].WanInterfaceId = types.StringPointerValue(varLoopWaninterfaces.WanInterfaceId)
				}
			}
		}
	}
	// property: name=state, type=STRING macro=copy_to_state
	state.State = types.StringPointerValue(ans.State)
	// property: name=sw_obj, type=REFERENCE macro=copy_to_state
	if ans.SwObj == nil {
		state.SwObj = nil
	} else {
		state.SwObj = &rsModelSoftware{}
		// copy_to_state: state=state.SwObj prefix=rsModel ans=ans.SwObj properties=2
		tflog.Debug(ctx, "copy_to_state state=state.SwObj prefix=rsModel ans=ans.SwObj")
		// property: name=location, type=STRING macro=copy_to_state
		state.SwObj.Location = types.StringPointerValue(ans.SwObj.Location)
		// property: name=version, type=STRING macro=copy_to_state
		state.SwObj.Version = types.StringPointerValue(ans.SwObj.Version)
	}
	// property: name=switch_config, type=REFERENCE macro=copy_to_state
	if ans.SwitchConfig == nil {
		state.SwitchConfig = nil
	} else {
		state.SwitchConfig = &rsModelSwitchConfig{}
		// copy_to_state: state=state.SwitchConfig prefix=rsModel ans=ans.SwitchConfig properties=8
		tflog.Debug(ctx, "copy_to_state state=state.SwitchConfig prefix=rsModel ans=ans.SwitchConfig")
		// property: name=default_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchConfig.DefaultVlanId = types.Int64PointerValue(ans.SwitchConfig.DefaultVlanId)
		// property: name=mstp_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchConfig.MstpEnabled = types.BoolPointerValue(ans.SwitchConfig.MstpEnabled)
		// property: name=stp_aging_timer, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpAgingTimer = types.Int64PointerValue(ans.SwitchConfig.StpAgingTimer)
		// property: name=stp_forward_delay, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpForwardDelay = types.Int64PointerValue(ans.SwitchConfig.StpForwardDelay)
		// property: name=stp_hello_time, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpHelloTime = types.Int64PointerValue(ans.SwitchConfig.StpHelloTime)
		// property: name=stp_max_age, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpMaxAge = types.Int64PointerValue(ans.SwitchConfig.StpMaxAge)
		// property: name=stp_mode, type=STRING macro=copy_to_state
		state.SwitchConfig.StpMode = types.StringPointerValue(ans.SwitchConfig.StpMode)
		// property: name=stp_priority, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpPriority = types.Int64PointerValue(ans.SwitchConfig.StpPriority)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	// property: name=tenant_id, type=STRING macro=copy_to_state
	state.TenantId = types.StringPointerValue(ans.TenantId)
	// property: name=vpn_to_vpn_forwarding, type=BOOLEAN macro=copy_to_state
	state.VpnToVpnForwarding = types.BoolPointerValue(ans.VpnToVpnForwarding)
	// copy tfid
	plan.Tfid = state.Tfid
	// make a put call again
	return r.doPut(ctx, plan, state, &resp.State, &resource.UpdateResponse{
		State:       resp.State,
		Diagnostics: resp.Diagnostics,
		Private:     resp.Private,
	})
}

func (r *elementShellResource) doGet(ctx context.Context, state *rsModelElementScreenV3N2, savestate *rsModelElementScreenV3N2, State *tfsdk.State, resp *resource.ReadResponse) bool {
	// Basic logging.
	tfid := savestate.Tfid.ValueString()
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "prismasdwan_element_shell",
		"tfid":                        tfid,
	})

	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) < 2 {
		resp.Diagnostics.AddError("error in prismasdwan_element_shell ID format", "Expected 2 tokens")
		return false
	}

	// Prepare to read the config.
	svc := sdwan_client.NewClient(r.client)

	// Prepare input for the API endpoint.
	read_request := &sdwan_client.SdwanClientRequestResponse{}
	read_request.ResourceType = "prismasdwan_element_shell"
	read_request.Method = "GET"
	read_request.Path = "/sdwan/v2.1/api/sites/{site_id}/elementshells/{element_shell_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, savestate.TfParameters)
	read_request.PathParameters = &params
	// add last parameter as ObjectID
	(*read_request.PathParameters)["element_shell_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*read_request.PathParameters)[param[0]] = &param[1]
	}

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, read_request)
	if read_request.ResponseErr != nil {
		if IsObjectNotFound(*read_request.ResponseErr) {
			State.RemoveResource(ctx)
		} else if r.GetHttpStatusCode(read_request) == 404 {
			State.RemoveResource(ctx)
		} else {
			tflog.Info(ctx, "read request failed for prismasdwan_element_shell", map[string]any{
				"terraform_provider_function": "Read",
				"resource_name":               "prismasdwan_element_shell",
				"path":                        read_request.FinalPath,
				"request":                     read_request.ToString(),
			})
			resp.Diagnostics.AddError("error reading prismasdwan_element_shell from sdwan servers", (*read_request.ResponseErr).Error())
		}
		return false
	}

	// process http json path
	response_body_string := string(*read_request.ResponseBytes)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete response_body_string::_created_on_utc")
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	tflog.Debug(ctx, "http json override: set response_body_string::_schema")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// Store the answer to state. schema=ElementScreenV3N2
	state.Tfid = savestate.Tfid
	// copy parameters from savestate as they are
	if savestate.TfParameters.IsNull() {
		state.TfParameters = types.MapNull(types.StringType)
	} else {
		state.TfParameters = savestate.TfParameters
	}
	// start copying attributes
	var ans sdwan_schema.ElementScreenV3N2
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to ElementScreenV3N2 in read", json_err.Error())
		return false
	}
	// lets copy all items into state
	// copy_to_state: state=state prefix=rsModel ans=ans properties=32
	tflog.Debug(ctx, "copy_to_state state=state prefix=rsModel ans=ans")
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=allowed_roles, type=ARRAY_PRIMITIVE macro=copy_to_state
	varAllowedRoles, errAllowedRoles := types.ListValueFrom(ctx, types.StringType, ans.AllowedRoles)
	state.AllowedRoles = varAllowedRoles
	resp.Diagnostics.Append(errAllowedRoles.Errors()...)
	// property: name=cluster_id, type=STRING macro=copy_to_state
	state.ClusterId = types.StringPointerValue(ans.ClusterId)
	// property: name=cluster_insertion_mode, type=STRING macro=copy_to_state
	state.ClusterInsertionMode = types.StringPointerValue(ans.ClusterInsertionMode)
	// property: name=cluster_member_id, type=STRING macro=copy_to_state
	state.ClusterMemberId = types.StringPointerValue(ans.ClusterMemberId)
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=device_mode, type=STRING macro=copy_to_state
	state.DeviceMode = types.StringPointerValue(ans.DeviceMode)
	// property: name=device_profile_id, type=STRING macro=copy_to_state
	state.DeviceProfileId = types.StringPointerValue(ans.DeviceProfileId)
	// property: name=element_id, type=STRING macro=copy_to_state
	state.ElementId = types.StringPointerValue(ans.ElementId)
	// property: name=hub_cluster_config, type=REFERENCE macro=copy_to_state
	if ans.HubClusterConfig == nil {
		state.HubClusterConfig = nil
	} else {
		state.HubClusterConfig = &rsModelHubClusterConfig{}
		// copy_to_state: state=state.HubClusterConfig prefix=rsModel ans=ans.HubClusterConfig properties=2
		tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig prefix=rsModel ans=ans.HubClusterConfig")
		// property: name=intra_cluster_tunnel, type=REFERENCE macro=copy_to_state
		if ans.HubClusterConfig.IntraClusterTunnel == nil {
			state.HubClusterConfig.IntraClusterTunnel = nil
		} else {
			state.HubClusterConfig.IntraClusterTunnel = &rsModelIntraClusterTunnel{}
			// copy_to_state: state=state.HubClusterConfig.IntraClusterTunnel prefix=rsModel ans=ans.HubClusterConfig.IntraClusterTunnel properties=3
			tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.IntraClusterTunnel prefix=rsModel ans=ans.HubClusterConfig.IntraClusterTunnel")
			// property: name=destination_ip, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.DestinationIp = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.DestinationIp)
			// property: name=source_ip, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.SourceIp = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.SourceIp)
			// property: name=status, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.Status = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.Status)
		}
		// property: name=track, type=REFERENCE macro=copy_to_state
		if ans.HubClusterConfig.Track == nil {
			state.HubClusterConfig.Track = nil
		} else {
			state.HubClusterConfig.Track = &rsModelTracker{}
			// copy_to_state: state=state.HubClusterConfig.Track prefix=rsModel ans=ans.HubClusterConfig.Track properties=1
			tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.Track prefix=rsModel ans=ans.HubClusterConfig.Track")
			// property: name=hosts, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.HubClusterConfig.Track.Hosts == nil {
				state.HubClusterConfig.Track.Hosts = nil
			} else if len(ans.HubClusterConfig.Track.Hosts) == 0 {
				state.HubClusterConfig.Track.Hosts = []rsModelHost{}
			} else {
				state.HubClusterConfig.Track.Hosts = make([]rsModelHost, 0, len(ans.HubClusterConfig.Track.Hosts))
				for varLoopHostsIndex, varLoopHosts := range ans.HubClusterConfig.Track.Hosts {
					// add a new item
					state.HubClusterConfig.Track.Hosts = append(state.HubClusterConfig.Track.Hosts, rsModelHost{})
					// copy_to_state: state=state.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel ans=varLoopHosts properties=3
					tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel ans=varLoopHosts")
					// property: name=address_v4, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV4 = types.StringPointerValue(varLoopHosts.AddressV4)
					// property: name=address_v6, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV6 = types.StringPointerValue(varLoopHosts.AddressV6)
					// property: name=vrf_context_id, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].VrfContextId = types.StringPointerValue(varLoopHosts.VrfContextId)
				}
			}
		}
	}
	// property: name=hw_id, type=STRING macro=copy_to_state
	state.HwId = types.StringPointerValue(ans.HwId)
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=l3_direct_private_wan_forwarding, type=BOOLEAN macro=copy_to_state
	state.L3DirectPrivateWanForwarding = types.BoolPointerValue(ans.L3DirectPrivateWanForwarding)
	// property: name=l3_lan_forwarding, type=BOOLEAN macro=copy_to_state
	state.L3LanForwarding = types.BoolPointerValue(ans.L3LanForwarding)
	// property: name=led_config, type=REFERENCE macro=copy_to_state
	if ans.LedConfig == nil {
		state.LedConfig = nil
	} else {
		state.LedConfig = &rsModelLedConfig{}
		// copy_to_state: state=state.LedConfig prefix=rsModel ans=ans.LedConfig properties=1
		tflog.Debug(ctx, "copy_to_state state=state.LedConfig prefix=rsModel ans=ans.LedConfig")
		// property: name=service_led_on, type=BOOLEAN macro=copy_to_state
		state.LedConfig.ServiceLedOn = types.BoolPointerValue(ans.LedConfig.ServiceLedOn)
	}
	// property: name=main_power_usage_threshold, type=INTEGER macro=copy_to_state
	state.MainPowerUsageThreshold = types.Int64PointerValue(ans.MainPowerUsageThreshold)
	// property: name=model_name, type=STRING macro=copy_to_state
	state.ModelName = types.StringPointerValue(ans.ModelName)
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=nat_policysetstack_id, type=STRING macro=copy_to_state
	state.NatPolicysetstackId = types.StringPointerValue(ans.NatPolicysetstackId)
	// property: name=network_policysetstack_id, type=STRING macro=copy_to_state
	state.NetworkPolicysetstackId = types.StringPointerValue(ans.NetworkPolicysetstackId)
	// property: name=priority_policysetstack_id, type=STRING macro=copy_to_state
	state.PriorityPolicysetstackId = types.StringPointerValue(ans.PriorityPolicysetstackId)
	// property: name=role, type=STRING macro=copy_to_state
	state.Role = types.StringPointerValue(ans.Role)
	// property: name=site_id, type=STRING macro=copy_to_state
	state.SiteId = types.StringPointerValue(ans.SiteId)
	// property: name=software_version, type=STRING macro=copy_to_state
	state.SoftwareVersion = types.StringPointerValue(ans.SoftwareVersion)
	// property: name=spoke_ha_config, type=REFERENCE macro=copy_to_state
	if ans.SpokeHaConfig == nil {
		state.SpokeHaConfig = nil
	} else {
		state.SpokeHaConfig = &rsModelSpokeHAConfigV2{}
		// copy_to_state: state=state.SpokeHaConfig prefix=rsModel ans=ans.SpokeHaConfig properties=5
		tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig prefix=rsModel ans=ans.SpokeHaConfig")
		// property: name=cluster_id, type=STRING macro=copy_to_state
		state.SpokeHaConfig.ClusterId = types.StringPointerValue(ans.SpokeHaConfig.ClusterId)
		// property: name=enable, type=BOOLEAN macro=copy_to_state
		state.SpokeHaConfig.Enable = types.BoolPointerValue(ans.SpokeHaConfig.Enable)
		// property: name=priority, type=INTEGER macro=copy_to_state
		state.SpokeHaConfig.Priority = types.Int64PointerValue(ans.SpokeHaConfig.Priority)
		// property: name=source_interface, type=STRING macro=copy_to_state
		state.SpokeHaConfig.SourceInterface = types.StringPointerValue(ans.SpokeHaConfig.SourceInterface)
		// property: name=track, type=REFERENCE macro=copy_to_state
		if ans.SpokeHaConfig.Track == nil {
			state.SpokeHaConfig.Track = nil
		} else {
			state.SpokeHaConfig.Track = &rsModelTrackV2{}
			// copy_to_state: state=state.SpokeHaConfig.Track prefix=rsModel ans=ans.SpokeHaConfig.Track properties=2
			tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track prefix=rsModel ans=ans.SpokeHaConfig.Track")
			// property: name=interfaces, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.SpokeHaConfig.Track.Interfaces == nil {
				state.SpokeHaConfig.Track.Interfaces = nil
			} else if len(ans.SpokeHaConfig.Track.Interfaces) == 0 {
				state.SpokeHaConfig.Track.Interfaces = []rsModelTrackInterface{}
			} else {
				state.SpokeHaConfig.Track.Interfaces = make([]rsModelTrackInterface, 0, len(ans.SpokeHaConfig.Track.Interfaces))
				for varLoopInterfacesIndex, varLoopInterfaces := range ans.SpokeHaConfig.Track.Interfaces {
					// add a new item
					state.SpokeHaConfig.Track.Interfaces = append(state.SpokeHaConfig.Track.Interfaces, rsModelTrackInterface{})
					// copy_to_state: state=state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel ans=varLoopInterfaces properties=2
					tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel ans=varLoopInterfaces")
					// property: name=interface_id, type=STRING macro=copy_to_state
					state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].InterfaceId = types.StringPointerValue(varLoopInterfaces.InterfaceId)
					// property: name=reduce_priority, type=INTEGER macro=copy_to_state
					state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].ReducePriority = types.Int64PointerValue(varLoopInterfaces.ReducePriority)
				}
			}
			// property: name=waninterfaces, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.SpokeHaConfig.Track.Waninterfaces == nil {
				state.SpokeHaConfig.Track.Waninterfaces = nil
			} else if len(ans.SpokeHaConfig.Track.Waninterfaces) == 0 {
				state.SpokeHaConfig.Track.Waninterfaces = []rsModelTrackWANInterface{}
			} else {
				state.SpokeHaConfig.Track.Waninterfaces = make([]rsModelTrackWANInterface, 0, len(ans.SpokeHaConfig.Track.Waninterfaces))
				for varLoopWaninterfacesIndex, varLoopWaninterfaces := range ans.SpokeHaConfig.Track.Waninterfaces {
					// add a new item
					state.SpokeHaConfig.Track.Waninterfaces = append(state.SpokeHaConfig.Track.Waninterfaces, rsModelTrackWANInterface{})
					// copy_to_state: state=state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel ans=varLoopWaninterfaces properties=2
					tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel ans=varLoopWaninterfaces")
					// property: name=reduce_priority, type=INTEGER macro=copy_to_state
					state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].ReducePriority = types.Int64PointerValue(varLoopWaninterfaces.ReducePriority)
					// property: name=wan_interface_id, type=STRING macro=copy_to_state
					state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].WanInterfaceId = types.StringPointerValue(varLoopWaninterfaces.WanInterfaceId)
				}
			}
		}
	}
	// property: name=state, type=STRING macro=copy_to_state
	state.State = types.StringPointerValue(ans.State)
	// property: name=sw_obj, type=REFERENCE macro=copy_to_state
	if ans.SwObj == nil {
		state.SwObj = nil
	} else {
		state.SwObj = &rsModelSoftware{}
		// copy_to_state: state=state.SwObj prefix=rsModel ans=ans.SwObj properties=2
		tflog.Debug(ctx, "copy_to_state state=state.SwObj prefix=rsModel ans=ans.SwObj")
		// property: name=location, type=STRING macro=copy_to_state
		state.SwObj.Location = types.StringPointerValue(ans.SwObj.Location)
		// property: name=version, type=STRING macro=copy_to_state
		state.SwObj.Version = types.StringPointerValue(ans.SwObj.Version)
	}
	// property: name=switch_config, type=REFERENCE macro=copy_to_state
	if ans.SwitchConfig == nil {
		state.SwitchConfig = nil
	} else {
		state.SwitchConfig = &rsModelSwitchConfig{}
		// copy_to_state: state=state.SwitchConfig prefix=rsModel ans=ans.SwitchConfig properties=8
		tflog.Debug(ctx, "copy_to_state state=state.SwitchConfig prefix=rsModel ans=ans.SwitchConfig")
		// property: name=default_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchConfig.DefaultVlanId = types.Int64PointerValue(ans.SwitchConfig.DefaultVlanId)
		// property: name=mstp_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchConfig.MstpEnabled = types.BoolPointerValue(ans.SwitchConfig.MstpEnabled)
		// property: name=stp_aging_timer, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpAgingTimer = types.Int64PointerValue(ans.SwitchConfig.StpAgingTimer)
		// property: name=stp_forward_delay, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpForwardDelay = types.Int64PointerValue(ans.SwitchConfig.StpForwardDelay)
		// property: name=stp_hello_time, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpHelloTime = types.Int64PointerValue(ans.SwitchConfig.StpHelloTime)
		// property: name=stp_max_age, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpMaxAge = types.Int64PointerValue(ans.SwitchConfig.StpMaxAge)
		// property: name=stp_mode, type=STRING macro=copy_to_state
		state.SwitchConfig.StpMode = types.StringPointerValue(ans.SwitchConfig.StpMode)
		// property: name=stp_priority, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpPriority = types.Int64PointerValue(ans.SwitchConfig.StpPriority)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	// property: name=tenant_id, type=STRING macro=copy_to_state
	state.TenantId = types.StringPointerValue(ans.TenantId)
	// property: name=vpn_to_vpn_forwarding, type=BOOLEAN macro=copy_to_state
	state.VpnToVpnForwarding = types.BoolPointerValue(ans.VpnToVpnForwarding)
	return true
}

func (r *elementShellResource) doPut(ctx context.Context, plan *rsModelElementScreenV3N2, state *rsModelElementScreenV3N2, State *tfsdk.State, resp *resource.UpdateResponse) bool {
	state_tfid := state.Tfid.ValueString()
	plan_tfid := plan.Tfid.ValueString()
	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "prismasdwan_element_shell",
		"state_tfid":                  state_tfid,
		"plan_tfid":                   plan_tfid,
	})

	// both TFID must be SAME!!!
	if state_tfid != plan_tfid {
		resp.Diagnostics.AddError("error updating prismasdwan_element_shell", "state and plan TFID do not match")
		return false
	}

	// split tokens
	tokens := strings.Split(state_tfid, IdSeparator)
	if len(tokens) < 2 {
		resp.Diagnostics.AddError("error in prismasdwan_element_shell ID format", "Expected 2 tokens")
		return false
	}

	// Prepare input for the API endpoint.
	put_request := &sdwan_client.SdwanClientRequestResponse{}
	put_request.ResourceType = "prismasdwan_element_shell"
	put_request.Method = "PUT"
	put_request.Path = "/sdwan/v2.1/api/sites/{site_id}/elementshells/{element_shell_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, state.TfParameters)
	put_request.PathParameters = &params
	// add last parameter as ObjectID
	(*put_request.PathParameters)["element_shell_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*put_request.PathParameters)[param[0]] = &param[1]
	}

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// prepare request from state
	var body = &sdwan_schema.ElementScreenV3N2{}

	// now we create the JSON request from the state/plan created by TF
	// below copy code generated from macro copy_from_plan_or_state
	// copy_from_plan_or_state: body=body prefix=rsModel state=state plan=plan properties=32
	tflog.Debug(ctx, "copy_from_plan_or_state body=body prefix=rsModel state=state plan=plan")
	// property: name=_etag, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Etag = ValueInt64PointerFromPlanOrState(plan.Etag, state.Etag)
	} else {
		body.Etag = Int64ValueOrNil(plan.Etag)
	}
	// property: name=_schema, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Schema = ValueInt64PointerFromPlanOrState(plan.Schema, state.Schema)
	} else {
		body.Schema = Int64ValueOrNil(plan.Schema)
	}
	// property: name=allowed_roles, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
	body.AllowedRoles = ListStringValueOrNil(ctx, plan.AllowedRoles)
	// property: name=cluster_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.ClusterId = ValueStringPointerFromPlanOrState(plan.ClusterId, state.ClusterId)
	} else {
		body.ClusterId = StringValueOrNil(plan.ClusterId)
	}
	// property: name=cluster_insertion_mode, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.ClusterInsertionMode = ValueStringPointerFromPlanOrState(plan.ClusterInsertionMode, state.ClusterInsertionMode)
	} else {
		body.ClusterInsertionMode = StringValueOrNil(plan.ClusterInsertionMode)
	}
	// property: name=cluster_member_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.ClusterMemberId = ValueStringPointerFromPlanOrState(plan.ClusterMemberId, state.ClusterMemberId)
	} else {
		body.ClusterMemberId = StringValueOrNil(plan.ClusterMemberId)
	}
	// property: name=description, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Description = ValueStringPointerFromPlanOrState(plan.Description, state.Description)
	} else {
		body.Description = StringValueOrNil(plan.Description)
	}
	// property: name=device_mode, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.DeviceMode = ValueStringPointerFromPlanOrState(plan.DeviceMode, state.DeviceMode)
	} else {
		body.DeviceMode = StringValueOrNil(plan.DeviceMode)
	}
	// property: name=device_profile_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.DeviceProfileId = ValueStringPointerFromPlanOrState(plan.DeviceProfileId, state.DeviceProfileId)
	} else {
		body.DeviceProfileId = StringValueOrNil(plan.DeviceProfileId)
	}
	// property: name=element_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.ElementId = ValueStringPointerFromPlanOrState(plan.ElementId, state.ElementId)
	} else {
		body.ElementId = StringValueOrNil(plan.ElementId)
	}
	// property: name=hub_cluster_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.HubClusterConfig == nil {
		body.HubClusterConfig = nil
	} else {
		body.HubClusterConfig = &sdwan_schema.HubClusterConfig{}
		// copy_from_plan_or_state: body=body.HubClusterConfig prefix=rsModel state=state.HubClusterConfig plan=plan.HubClusterConfig properties=2
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.HubClusterConfig prefix=rsModel state=state.HubClusterConfig plan=plan.HubClusterConfig")
		// property: name=intra_cluster_tunnel, type=REFERENCE macro=copy_from_plan_or_state
		if plan.HubClusterConfig.IntraClusterTunnel == nil {
			body.HubClusterConfig.IntraClusterTunnel = nil
		} else {
			body.HubClusterConfig.IntraClusterTunnel = &sdwan_schema.IntraClusterTunnel{}
			// copy_from_plan_or_state: body=body.HubClusterConfig.IntraClusterTunnel prefix=rsModel state=state.HubClusterConfig.IntraClusterTunnel plan=plan.HubClusterConfig.IntraClusterTunnel properties=3
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.HubClusterConfig.IntraClusterTunnel prefix=rsModel state=state.HubClusterConfig.IntraClusterTunnel plan=plan.HubClusterConfig.IntraClusterTunnel")
			// property: name=destination_ip, type=STRING macro=copy_from_plan_or_state
			if state.HubClusterConfig.IntraClusterTunnel != nil {
				body.HubClusterConfig.IntraClusterTunnel.DestinationIp = ValueStringPointerFromPlanOrState(plan.HubClusterConfig.IntraClusterTunnel.DestinationIp, state.HubClusterConfig.IntraClusterTunnel.DestinationIp)
			} else {
				body.HubClusterConfig.IntraClusterTunnel.DestinationIp = StringValueOrNil(plan.HubClusterConfig.IntraClusterTunnel.DestinationIp)
			}
			// property: name=source_ip, type=STRING macro=copy_from_plan_or_state
			if state.HubClusterConfig.IntraClusterTunnel != nil {
				body.HubClusterConfig.IntraClusterTunnel.SourceIp = ValueStringPointerFromPlanOrState(plan.HubClusterConfig.IntraClusterTunnel.SourceIp, state.HubClusterConfig.IntraClusterTunnel.SourceIp)
			} else {
				body.HubClusterConfig.IntraClusterTunnel.SourceIp = StringValueOrNil(plan.HubClusterConfig.IntraClusterTunnel.SourceIp)
			}
			// property: name=status, type=STRING macro=copy_from_plan_or_state
			if state.HubClusterConfig.IntraClusterTunnel != nil {
				body.HubClusterConfig.IntraClusterTunnel.Status = ValueStringPointerFromPlanOrState(plan.HubClusterConfig.IntraClusterTunnel.Status, state.HubClusterConfig.IntraClusterTunnel.Status)
			} else {
				body.HubClusterConfig.IntraClusterTunnel.Status = StringValueOrNil(plan.HubClusterConfig.IntraClusterTunnel.Status)
			}
		}
		// property: name=track, type=REFERENCE macro=copy_from_plan_or_state
		if plan.HubClusterConfig.Track == nil {
			body.HubClusterConfig.Track = nil
		} else {
			body.HubClusterConfig.Track = &sdwan_schema.Tracker{}
			// copy_from_plan_or_state: body=body.HubClusterConfig.Track prefix=rsModel state=state.HubClusterConfig.Track plan=plan.HubClusterConfig.Track properties=1
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.HubClusterConfig.Track prefix=rsModel state=state.HubClusterConfig.Track plan=plan.HubClusterConfig.Track")
			// property: name=hosts, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
			if plan.HubClusterConfig.Track.Hosts == nil && (state.HubClusterConfig.Track == nil || state.HubClusterConfig.Track.Hosts == nil) {
				body.HubClusterConfig.Track.Hosts = nil
			} else if len(plan.HubClusterConfig.Track.Hosts) == 0 && (state.HubClusterConfig.Track == nil || len(state.HubClusterConfig.Track.Hosts) == 0) {
				body.HubClusterConfig.Track.Hosts = []sdwan_schema.Host{}
			} else if len(plan.HubClusterConfig.Track.Hosts) != 0 || (state.HubClusterConfig.Track != nil && len(state.HubClusterConfig.Track.Hosts) != 0) {
				HostsToUse := plan.HubClusterConfig.Track.Hosts
				if len(plan.HubClusterConfig.Track.Hosts) == 0 {
					HostsToUse = state.HubClusterConfig.Track.Hosts
				}
				body.HubClusterConfig.Track.Hosts = make([]sdwan_schema.Host, 0, len(HostsToUse))
				for varLoopHostsIndex, varLoopHosts := range HostsToUse {
					// add a new item
					body.HubClusterConfig.Track.Hosts = append(body.HubClusterConfig.Track.Hosts, sdwan_schema.Host{})
					// since we have chosen to stick with either the plan or state, we need to simply copy child properties
					// copy_from_plan: body=body.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel plan=varLoopHosts properties=3
					tflog.Debug(ctx, "copy_from_plan body=body.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel plan=varLoopHosts")
					// property: name=address_v4, type=STRING macro=copy_from_plan
					body.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV4 = StringValueOrNil(varLoopHosts.AddressV4)
					// property: name=address_v6, type=STRING macro=copy_from_plan
					body.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV6 = StringValueOrNil(varLoopHosts.AddressV6)
					// property: name=vrf_context_id, type=STRING macro=copy_from_plan
					body.HubClusterConfig.Track.Hosts[varLoopHostsIndex].VrfContextId = StringValueOrNil(varLoopHosts.VrfContextId)
				}
			}
		}
	}
	// property: name=hw_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.HwId = ValueStringPointerFromPlanOrState(plan.HwId, state.HwId)
	} else {
		body.HwId = StringValueOrNil(plan.HwId)
	}
	// property: name=id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Id = ValueStringPointerFromPlanOrState(plan.Id, state.Id)
	} else {
		body.Id = StringValueOrNil(plan.Id)
	}
	// property: name=l3_direct_private_wan_forwarding, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.L3DirectPrivateWanForwarding = ValueBoolPointerFromPlanOrState(plan.L3DirectPrivateWanForwarding, state.L3DirectPrivateWanForwarding)
	} else {
		body.L3DirectPrivateWanForwarding = BoolValueOrNil(plan.L3DirectPrivateWanForwarding)
	}
	// property: name=l3_lan_forwarding, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.L3LanForwarding = ValueBoolPointerFromPlanOrState(plan.L3LanForwarding, state.L3LanForwarding)
	} else {
		body.L3LanForwarding = BoolValueOrNil(plan.L3LanForwarding)
	}
	// property: name=led_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.LedConfig == nil {
		body.LedConfig = nil
	} else {
		body.LedConfig = &sdwan_schema.LedConfig{}
		// copy_from_plan_or_state: body=body.LedConfig prefix=rsModel state=state.LedConfig plan=plan.LedConfig properties=1
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.LedConfig prefix=rsModel state=state.LedConfig plan=plan.LedConfig")
		// property: name=service_led_on, type=BOOLEAN macro=copy_from_plan_or_state
		if state.LedConfig != nil {
			body.LedConfig.ServiceLedOn = ValueBoolPointerFromPlanOrState(plan.LedConfig.ServiceLedOn, state.LedConfig.ServiceLedOn)
		} else {
			body.LedConfig.ServiceLedOn = BoolValueOrNil(plan.LedConfig.ServiceLedOn)
		}
	}
	// property: name=main_power_usage_threshold, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.MainPowerUsageThreshold = ValueInt64PointerFromPlanOrState(plan.MainPowerUsageThreshold, state.MainPowerUsageThreshold)
	} else {
		body.MainPowerUsageThreshold = Int64ValueOrNil(plan.MainPowerUsageThreshold)
	}
	// property: name=model_name, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.ModelName = ValueStringPointerFromPlanOrState(plan.ModelName, state.ModelName)
	} else {
		body.ModelName = StringValueOrNil(plan.ModelName)
	}
	// property: name=name, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Name = ValueStringPointerFromPlanOrState(plan.Name, state.Name)
	} else {
		body.Name = StringValueOrNil(plan.Name)
	}
	// property: name=nat_policysetstack_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.NatPolicysetstackId = ValueStringPointerFromPlanOrState(plan.NatPolicysetstackId, state.NatPolicysetstackId)
	} else {
		body.NatPolicysetstackId = StringValueOrNil(plan.NatPolicysetstackId)
	}
	// property: name=network_policysetstack_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.NetworkPolicysetstackId = ValueStringPointerFromPlanOrState(plan.NetworkPolicysetstackId, state.NetworkPolicysetstackId)
	} else {
		body.NetworkPolicysetstackId = StringValueOrNil(plan.NetworkPolicysetstackId)
	}
	// property: name=priority_policysetstack_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.PriorityPolicysetstackId = ValueStringPointerFromPlanOrState(plan.PriorityPolicysetstackId, state.PriorityPolicysetstackId)
	} else {
		body.PriorityPolicysetstackId = StringValueOrNil(plan.PriorityPolicysetstackId)
	}
	// property: name=role, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Role = ValueStringPointerFromPlanOrState(plan.Role, state.Role)
	} else {
		body.Role = StringValueOrNil(plan.Role)
	}
	// property: name=site_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.SiteId = ValueStringPointerFromPlanOrState(plan.SiteId, state.SiteId)
	} else {
		body.SiteId = StringValueOrNil(plan.SiteId)
	}
	// property: name=software_version, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.SoftwareVersion = ValueStringPointerFromPlanOrState(plan.SoftwareVersion, state.SoftwareVersion)
	} else {
		body.SoftwareVersion = StringValueOrNil(plan.SoftwareVersion)
	}
	// property: name=spoke_ha_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.SpokeHaConfig == nil {
		body.SpokeHaConfig = nil
	} else {
		body.SpokeHaConfig = &sdwan_schema.SpokeHAConfigV2{}
		// copy_from_plan_or_state: body=body.SpokeHaConfig prefix=rsModel state=state.SpokeHaConfig plan=plan.SpokeHaConfig properties=5
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.SpokeHaConfig prefix=rsModel state=state.SpokeHaConfig plan=plan.SpokeHaConfig")
		// property: name=cluster_id, type=STRING macro=copy_from_plan_or_state
		if state.SpokeHaConfig != nil {
			body.SpokeHaConfig.ClusterId = ValueStringPointerFromPlanOrState(plan.SpokeHaConfig.ClusterId, state.SpokeHaConfig.ClusterId)
		} else {
			body.SpokeHaConfig.ClusterId = StringValueOrNil(plan.SpokeHaConfig.ClusterId)
		}
		// property: name=enable, type=BOOLEAN macro=copy_from_plan_or_state
		if state.SpokeHaConfig != nil {
			body.SpokeHaConfig.Enable = ValueBoolPointerFromPlanOrState(plan.SpokeHaConfig.Enable, state.SpokeHaConfig.Enable)
		} else {
			body.SpokeHaConfig.Enable = BoolValueOrNil(plan.SpokeHaConfig.Enable)
		}
		// property: name=priority, type=INTEGER macro=copy_from_plan_or_state
		if state.SpokeHaConfig != nil {
			body.SpokeHaConfig.Priority = ValueInt64PointerFromPlanOrState(plan.SpokeHaConfig.Priority, state.SpokeHaConfig.Priority)
		} else {
			body.SpokeHaConfig.Priority = Int64ValueOrNil(plan.SpokeHaConfig.Priority)
		}
		// property: name=source_interface, type=STRING macro=copy_from_plan_or_state
		if state.SpokeHaConfig != nil {
			body.SpokeHaConfig.SourceInterface = ValueStringPointerFromPlanOrState(plan.SpokeHaConfig.SourceInterface, state.SpokeHaConfig.SourceInterface)
		} else {
			body.SpokeHaConfig.SourceInterface = StringValueOrNil(plan.SpokeHaConfig.SourceInterface)
		}
		// property: name=track, type=REFERENCE macro=copy_from_plan_or_state
		if plan.SpokeHaConfig.Track == nil {
			body.SpokeHaConfig.Track = nil
		} else {
			body.SpokeHaConfig.Track = &sdwan_schema.TrackV2{}
			// copy_from_plan_or_state: body=body.SpokeHaConfig.Track prefix=rsModel state=state.SpokeHaConfig.Track plan=plan.SpokeHaConfig.Track properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.SpokeHaConfig.Track prefix=rsModel state=state.SpokeHaConfig.Track plan=plan.SpokeHaConfig.Track")
			// property: name=interfaces, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
			if plan.SpokeHaConfig.Track.Interfaces == nil && (state.SpokeHaConfig.Track == nil || state.SpokeHaConfig.Track.Interfaces == nil) {
				body.SpokeHaConfig.Track.Interfaces = nil
			} else if len(plan.SpokeHaConfig.Track.Interfaces) == 0 && (state.SpokeHaConfig.Track == nil || len(state.SpokeHaConfig.Track.Interfaces) == 0) {
				body.SpokeHaConfig.Track.Interfaces = []sdwan_schema.TrackInterface{}
			} else if len(plan.SpokeHaConfig.Track.Interfaces) != 0 || (state.SpokeHaConfig.Track != nil && len(state.SpokeHaConfig.Track.Interfaces) != 0) {
				InterfacesToUse := plan.SpokeHaConfig.Track.Interfaces
				if len(plan.SpokeHaConfig.Track.Interfaces) == 0 {
					InterfacesToUse = state.SpokeHaConfig.Track.Interfaces
				}
				body.SpokeHaConfig.Track.Interfaces = make([]sdwan_schema.TrackInterface, 0, len(InterfacesToUse))
				for varLoopInterfacesIndex, varLoopInterfaces := range InterfacesToUse {
					// add a new item
					body.SpokeHaConfig.Track.Interfaces = append(body.SpokeHaConfig.Track.Interfaces, sdwan_schema.TrackInterface{})
					// since we have chosen to stick with either the plan or state, we need to simply copy child properties
					// copy_from_plan: body=body.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel plan=varLoopInterfaces properties=2
					tflog.Debug(ctx, "copy_from_plan body=body.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel plan=varLoopInterfaces")
					// property: name=interface_id, type=STRING macro=copy_from_plan
					body.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].InterfaceId = StringValueOrNil(varLoopInterfaces.InterfaceId)
					// property: name=reduce_priority, type=INTEGER macro=copy_from_plan
					body.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].ReducePriority = Int64ValueOrNil(varLoopInterfaces.ReducePriority)
				}
			}
			// property: name=waninterfaces, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
			if plan.SpokeHaConfig.Track.Waninterfaces == nil && (state.SpokeHaConfig.Track == nil || state.SpokeHaConfig.Track.Waninterfaces == nil) {
				body.SpokeHaConfig.Track.Waninterfaces = nil
			} else if len(plan.SpokeHaConfig.Track.Waninterfaces) == 0 && (state.SpokeHaConfig.Track == nil || len(state.SpokeHaConfig.Track.Waninterfaces) == 0) {
				body.SpokeHaConfig.Track.Waninterfaces = []sdwan_schema.TrackWANInterface{}
			} else if len(plan.SpokeHaConfig.Track.Waninterfaces) != 0 || (state.SpokeHaConfig.Track != nil && len(state.SpokeHaConfig.Track.Waninterfaces) != 0) {
				WaninterfacesToUse := plan.SpokeHaConfig.Track.Waninterfaces
				if len(plan.SpokeHaConfig.Track.Waninterfaces) == 0 {
					WaninterfacesToUse = state.SpokeHaConfig.Track.Waninterfaces
				}
				body.SpokeHaConfig.Track.Waninterfaces = make([]sdwan_schema.TrackWANInterface, 0, len(WaninterfacesToUse))
				for varLoopWaninterfacesIndex, varLoopWaninterfaces := range WaninterfacesToUse {
					// add a new item
					body.SpokeHaConfig.Track.Waninterfaces = append(body.SpokeHaConfig.Track.Waninterfaces, sdwan_schema.TrackWANInterface{})
					// since we have chosen to stick with either the plan or state, we need to simply copy child properties
					// copy_from_plan: body=body.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel plan=varLoopWaninterfaces properties=2
					tflog.Debug(ctx, "copy_from_plan body=body.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel plan=varLoopWaninterfaces")
					// property: name=reduce_priority, type=INTEGER macro=copy_from_plan
					body.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].ReducePriority = Int64ValueOrNil(varLoopWaninterfaces.ReducePriority)
					// property: name=wan_interface_id, type=STRING macro=copy_from_plan
					body.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].WanInterfaceId = StringValueOrNil(varLoopWaninterfaces.WanInterfaceId)
				}
			}
		}
	}
	// property: name=state, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.State = ValueStringPointerFromPlanOrState(plan.State, state.State)
	} else {
		body.State = StringValueOrNil(plan.State)
	}
	// property: name=sw_obj, type=REFERENCE macro=copy_from_plan_or_state
	if plan.SwObj == nil {
		body.SwObj = nil
	} else {
		body.SwObj = &sdwan_schema.Software{}
		// copy_from_plan_or_state: body=body.SwObj prefix=rsModel state=state.SwObj plan=plan.SwObj properties=2
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.SwObj prefix=rsModel state=state.SwObj plan=plan.SwObj")
		// property: name=location, type=STRING macro=copy_from_plan_or_state
		if state.SwObj != nil {
			body.SwObj.Location = ValueStringPointerFromPlanOrState(plan.SwObj.Location, state.SwObj.Location)
		} else {
			body.SwObj.Location = StringValueOrNil(plan.SwObj.Location)
		}
		// property: name=version, type=STRING macro=copy_from_plan_or_state
		if state.SwObj != nil {
			body.SwObj.Version = ValueStringPointerFromPlanOrState(plan.SwObj.Version, state.SwObj.Version)
		} else {
			body.SwObj.Version = StringValueOrNil(plan.SwObj.Version)
		}
	}
	// property: name=switch_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.SwitchConfig == nil {
		body.SwitchConfig = nil
	} else {
		body.SwitchConfig = &sdwan_schema.SwitchConfig{}
		// copy_from_plan_or_state: body=body.SwitchConfig prefix=rsModel state=state.SwitchConfig plan=plan.SwitchConfig properties=8
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.SwitchConfig prefix=rsModel state=state.SwitchConfig plan=plan.SwitchConfig")
		// property: name=default_vlan_id, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.DefaultVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchConfig.DefaultVlanId, state.SwitchConfig.DefaultVlanId)
		} else {
			body.SwitchConfig.DefaultVlanId = Int64ValueOrNil(plan.SwitchConfig.DefaultVlanId)
		}
		// property: name=mstp_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.MstpEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchConfig.MstpEnabled, state.SwitchConfig.MstpEnabled)
		} else {
			body.SwitchConfig.MstpEnabled = BoolValueOrNil(plan.SwitchConfig.MstpEnabled)
		}
		// property: name=stp_aging_timer, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.StpAgingTimer = ValueInt64PointerFromPlanOrState(plan.SwitchConfig.StpAgingTimer, state.SwitchConfig.StpAgingTimer)
		} else {
			body.SwitchConfig.StpAgingTimer = Int64ValueOrNil(plan.SwitchConfig.StpAgingTimer)
		}
		// property: name=stp_forward_delay, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.StpForwardDelay = ValueInt64PointerFromPlanOrState(plan.SwitchConfig.StpForwardDelay, state.SwitchConfig.StpForwardDelay)
		} else {
			body.SwitchConfig.StpForwardDelay = Int64ValueOrNil(plan.SwitchConfig.StpForwardDelay)
		}
		// property: name=stp_hello_time, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.StpHelloTime = ValueInt64PointerFromPlanOrState(plan.SwitchConfig.StpHelloTime, state.SwitchConfig.StpHelloTime)
		} else {
			body.SwitchConfig.StpHelloTime = Int64ValueOrNil(plan.SwitchConfig.StpHelloTime)
		}
		// property: name=stp_max_age, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.StpMaxAge = ValueInt64PointerFromPlanOrState(plan.SwitchConfig.StpMaxAge, state.SwitchConfig.StpMaxAge)
		} else {
			body.SwitchConfig.StpMaxAge = Int64ValueOrNil(plan.SwitchConfig.StpMaxAge)
		}
		// property: name=stp_mode, type=STRING macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.StpMode = ValueStringPointerFromPlanOrState(plan.SwitchConfig.StpMode, state.SwitchConfig.StpMode)
		} else {
			body.SwitchConfig.StpMode = StringValueOrNil(plan.SwitchConfig.StpMode)
		}
		// property: name=stp_priority, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchConfig != nil {
			body.SwitchConfig.StpPriority = ValueInt64PointerFromPlanOrState(plan.SwitchConfig.StpPriority, state.SwitchConfig.StpPriority)
		} else {
			body.SwitchConfig.StpPriority = Int64ValueOrNil(plan.SwitchConfig.StpPriority)
		}
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_from_plan_or_state
	body.Tags = SetStringValueOrNil(ctx, plan.Tags)
	// property: name=tenant_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.TenantId = ValueStringPointerFromPlanOrState(plan.TenantId, state.TenantId)
	} else {
		body.TenantId = StringValueOrNil(plan.TenantId)
	}
	// property: name=vpn_to_vpn_forwarding, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.VpnToVpnForwarding = ValueBoolPointerFromPlanOrState(plan.VpnToVpnForwarding, state.VpnToVpnForwarding)
	} else {
		body.VpnToVpnForwarding = BoolValueOrNil(plan.VpnToVpnForwarding)
	}

	// convert body to map
	json_body, err := json.Marshal(body)
	if err != nil {
		resp.Diagnostics.AddError("error marshaling struct ElementScreenV3N2 to JSON:", err.Error())
		return false
	}

	// process http json path
	request_body_string := string(json_body)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete request_body_string::sw_obj")
	request_body_string, _ = sjson.Delete(request_body_string, "sw_obj")
	// copy pointer
	put_request.RequestBody = &request_body_string

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, put_request)
	if put_request.ResponseErr != nil {
		if IsObjectNotFound(*put_request.ResponseErr) {
			State.RemoveResource(ctx)
		} else if r.GetHttpStatusCode(put_request) == 404 {
			State.RemoveResource(ctx)
		} else {
			tflog.Info(ctx, "update request failed for prismasdwan_element_shell", map[string]any{
				"terraform_provider_function": "Update",
				"resource_name":               "prismasdwan_element_shell",
				"path":                        put_request.FinalPath,
			})
			tflog.Debug(ctx, "update request failed for prismasdwan_element_shell", map[string]any{
				"terraform_provider_function": "Update",
				"resource_name":               "prismasdwan_element_shell",
				"path":                        put_request.FinalPath,
				"request":                     put_request.ToString(),
			})
			resp.Diagnostics.AddError("error updating prismasdwan_element_shell", (*put_request.ResponseErr).Error())
		}
		return false
	}

	// process http json path
	response_body_string := string(*put_request.ResponseBytes)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete response_body_string::_created_on_utc")
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	tflog.Debug(ctx, "http json override: set response_body_string::_schema")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// start copying attributes
	var ans sdwan_schema.ElementScreenV3N2
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to ElementScreenV3N2 in update", json_err.Error())
		return false
	}

	// Store the answer to state. schema=ElementScreenV3N2
	// copy_to_state: state=state prefix=rsModel ans=ans properties=32
	tflog.Debug(ctx, "copy_to_state state=state prefix=rsModel ans=ans")
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=allowed_roles, type=ARRAY_PRIMITIVE macro=copy_to_state
	varAllowedRoles, errAllowedRoles := types.ListValueFrom(ctx, types.StringType, ans.AllowedRoles)
	state.AllowedRoles = varAllowedRoles
	resp.Diagnostics.Append(errAllowedRoles.Errors()...)
	// property: name=cluster_id, type=STRING macro=copy_to_state
	state.ClusterId = types.StringPointerValue(ans.ClusterId)
	// property: name=cluster_insertion_mode, type=STRING macro=copy_to_state
	state.ClusterInsertionMode = types.StringPointerValue(ans.ClusterInsertionMode)
	// property: name=cluster_member_id, type=STRING macro=copy_to_state
	state.ClusterMemberId = types.StringPointerValue(ans.ClusterMemberId)
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=device_mode, type=STRING macro=copy_to_state
	state.DeviceMode = types.StringPointerValue(ans.DeviceMode)
	// property: name=device_profile_id, type=STRING macro=copy_to_state
	state.DeviceProfileId = types.StringPointerValue(ans.DeviceProfileId)
	// property: name=element_id, type=STRING macro=copy_to_state
	state.ElementId = types.StringPointerValue(ans.ElementId)
	// property: name=hub_cluster_config, type=REFERENCE macro=copy_to_state
	if ans.HubClusterConfig == nil {
		state.HubClusterConfig = nil
	} else {
		state.HubClusterConfig = &rsModelHubClusterConfig{}
		// copy_to_state: state=state.HubClusterConfig prefix=rsModel ans=ans.HubClusterConfig properties=2
		tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig prefix=rsModel ans=ans.HubClusterConfig")
		// property: name=intra_cluster_tunnel, type=REFERENCE macro=copy_to_state
		if ans.HubClusterConfig.IntraClusterTunnel == nil {
			state.HubClusterConfig.IntraClusterTunnel = nil
		} else {
			state.HubClusterConfig.IntraClusterTunnel = &rsModelIntraClusterTunnel{}
			// copy_to_state: state=state.HubClusterConfig.IntraClusterTunnel prefix=rsModel ans=ans.HubClusterConfig.IntraClusterTunnel properties=3
			tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.IntraClusterTunnel prefix=rsModel ans=ans.HubClusterConfig.IntraClusterTunnel")
			// property: name=destination_ip, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.DestinationIp = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.DestinationIp)
			// property: name=source_ip, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.SourceIp = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.SourceIp)
			// property: name=status, type=STRING macro=copy_to_state
			state.HubClusterConfig.IntraClusterTunnel.Status = types.StringPointerValue(ans.HubClusterConfig.IntraClusterTunnel.Status)
		}
		// property: name=track, type=REFERENCE macro=copy_to_state
		if ans.HubClusterConfig.Track == nil {
			state.HubClusterConfig.Track = nil
		} else {
			state.HubClusterConfig.Track = &rsModelTracker{}
			// copy_to_state: state=state.HubClusterConfig.Track prefix=rsModel ans=ans.HubClusterConfig.Track properties=1
			tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.Track prefix=rsModel ans=ans.HubClusterConfig.Track")
			// property: name=hosts, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.HubClusterConfig.Track.Hosts == nil {
				state.HubClusterConfig.Track.Hosts = nil
			} else if len(ans.HubClusterConfig.Track.Hosts) == 0 {
				state.HubClusterConfig.Track.Hosts = []rsModelHost{}
			} else {
				state.HubClusterConfig.Track.Hosts = make([]rsModelHost, 0, len(ans.HubClusterConfig.Track.Hosts))
				for varLoopHostsIndex, varLoopHosts := range ans.HubClusterConfig.Track.Hosts {
					// add a new item
					state.HubClusterConfig.Track.Hosts = append(state.HubClusterConfig.Track.Hosts, rsModelHost{})
					// copy_to_state: state=state.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel ans=varLoopHosts properties=3
					tflog.Debug(ctx, "copy_to_state state=state.HubClusterConfig.Track.Hosts[varLoopHostsIndex] prefix=rsModel ans=varLoopHosts")
					// property: name=address_v4, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV4 = types.StringPointerValue(varLoopHosts.AddressV4)
					// property: name=address_v6, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].AddressV6 = types.StringPointerValue(varLoopHosts.AddressV6)
					// property: name=vrf_context_id, type=STRING macro=copy_to_state
					state.HubClusterConfig.Track.Hosts[varLoopHostsIndex].VrfContextId = types.StringPointerValue(varLoopHosts.VrfContextId)
				}
			}
		}
	}
	// property: name=hw_id, type=STRING macro=copy_to_state
	state.HwId = types.StringPointerValue(ans.HwId)
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=l3_direct_private_wan_forwarding, type=BOOLEAN macro=copy_to_state
	state.L3DirectPrivateWanForwarding = types.BoolPointerValue(ans.L3DirectPrivateWanForwarding)
	// property: name=l3_lan_forwarding, type=BOOLEAN macro=copy_to_state
	state.L3LanForwarding = types.BoolPointerValue(ans.L3LanForwarding)
	// property: name=led_config, type=REFERENCE macro=copy_to_state
	if ans.LedConfig == nil {
		state.LedConfig = nil
	} else {
		state.LedConfig = &rsModelLedConfig{}
		// copy_to_state: state=state.LedConfig prefix=rsModel ans=ans.LedConfig properties=1
		tflog.Debug(ctx, "copy_to_state state=state.LedConfig prefix=rsModel ans=ans.LedConfig")
		// property: name=service_led_on, type=BOOLEAN macro=copy_to_state
		state.LedConfig.ServiceLedOn = types.BoolPointerValue(ans.LedConfig.ServiceLedOn)
	}
	// property: name=main_power_usage_threshold, type=INTEGER macro=copy_to_state
	state.MainPowerUsageThreshold = types.Int64PointerValue(ans.MainPowerUsageThreshold)
	// property: name=model_name, type=STRING macro=copy_to_state
	state.ModelName = types.StringPointerValue(ans.ModelName)
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=nat_policysetstack_id, type=STRING macro=copy_to_state
	state.NatPolicysetstackId = types.StringPointerValue(ans.NatPolicysetstackId)
	// property: name=network_policysetstack_id, type=STRING macro=copy_to_state
	state.NetworkPolicysetstackId = types.StringPointerValue(ans.NetworkPolicysetstackId)
	// property: name=priority_policysetstack_id, type=STRING macro=copy_to_state
	state.PriorityPolicysetstackId = types.StringPointerValue(ans.PriorityPolicysetstackId)
	// property: name=role, type=STRING macro=copy_to_state
	state.Role = types.StringPointerValue(ans.Role)
	// property: name=site_id, type=STRING macro=copy_to_state
	state.SiteId = types.StringPointerValue(ans.SiteId)
	// property: name=software_version, type=STRING macro=copy_to_state
	state.SoftwareVersion = types.StringPointerValue(ans.SoftwareVersion)
	// property: name=spoke_ha_config, type=REFERENCE macro=copy_to_state
	if ans.SpokeHaConfig == nil {
		state.SpokeHaConfig = nil
	} else {
		state.SpokeHaConfig = &rsModelSpokeHAConfigV2{}
		// copy_to_state: state=state.SpokeHaConfig prefix=rsModel ans=ans.SpokeHaConfig properties=5
		tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig prefix=rsModel ans=ans.SpokeHaConfig")
		// property: name=cluster_id, type=STRING macro=copy_to_state
		state.SpokeHaConfig.ClusterId = types.StringPointerValue(ans.SpokeHaConfig.ClusterId)
		// property: name=enable, type=BOOLEAN macro=copy_to_state
		state.SpokeHaConfig.Enable = types.BoolPointerValue(ans.SpokeHaConfig.Enable)
		// property: name=priority, type=INTEGER macro=copy_to_state
		state.SpokeHaConfig.Priority = types.Int64PointerValue(ans.SpokeHaConfig.Priority)
		// property: name=source_interface, type=STRING macro=copy_to_state
		state.SpokeHaConfig.SourceInterface = types.StringPointerValue(ans.SpokeHaConfig.SourceInterface)
		// property: name=track, type=REFERENCE macro=copy_to_state
		if ans.SpokeHaConfig.Track == nil {
			state.SpokeHaConfig.Track = nil
		} else {
			state.SpokeHaConfig.Track = &rsModelTrackV2{}
			// copy_to_state: state=state.SpokeHaConfig.Track prefix=rsModel ans=ans.SpokeHaConfig.Track properties=2
			tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track prefix=rsModel ans=ans.SpokeHaConfig.Track")
			// property: name=interfaces, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.SpokeHaConfig.Track.Interfaces == nil {
				state.SpokeHaConfig.Track.Interfaces = nil
			} else if len(ans.SpokeHaConfig.Track.Interfaces) == 0 {
				state.SpokeHaConfig.Track.Interfaces = []rsModelTrackInterface{}
			} else {
				state.SpokeHaConfig.Track.Interfaces = make([]rsModelTrackInterface, 0, len(ans.SpokeHaConfig.Track.Interfaces))
				for varLoopInterfacesIndex, varLoopInterfaces := range ans.SpokeHaConfig.Track.Interfaces {
					// add a new item
					state.SpokeHaConfig.Track.Interfaces = append(state.SpokeHaConfig.Track.Interfaces, rsModelTrackInterface{})
					// copy_to_state: state=state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel ans=varLoopInterfaces properties=2
					tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex] prefix=rsModel ans=varLoopInterfaces")
					// property: name=interface_id, type=STRING macro=copy_to_state
					state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].InterfaceId = types.StringPointerValue(varLoopInterfaces.InterfaceId)
					// property: name=reduce_priority, type=INTEGER macro=copy_to_state
					state.SpokeHaConfig.Track.Interfaces[varLoopInterfacesIndex].ReducePriority = types.Int64PointerValue(varLoopInterfaces.ReducePriority)
				}
			}
			// property: name=waninterfaces, type=ARRAY_REFERENCE macro=copy_to_state
			if ans.SpokeHaConfig.Track.Waninterfaces == nil {
				state.SpokeHaConfig.Track.Waninterfaces = nil
			} else if len(ans.SpokeHaConfig.Track.Waninterfaces) == 0 {
				state.SpokeHaConfig.Track.Waninterfaces = []rsModelTrackWANInterface{}
			} else {
				state.SpokeHaConfig.Track.Waninterfaces = make([]rsModelTrackWANInterface, 0, len(ans.SpokeHaConfig.Track.Waninterfaces))
				for varLoopWaninterfacesIndex, varLoopWaninterfaces := range ans.SpokeHaConfig.Track.Waninterfaces {
					// add a new item
					state.SpokeHaConfig.Track.Waninterfaces = append(state.SpokeHaConfig.Track.Waninterfaces, rsModelTrackWANInterface{})
					// copy_to_state: state=state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel ans=varLoopWaninterfaces properties=2
					tflog.Debug(ctx, "copy_to_state state=state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex] prefix=rsModel ans=varLoopWaninterfaces")
					// property: name=reduce_priority, type=INTEGER macro=copy_to_state
					state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].ReducePriority = types.Int64PointerValue(varLoopWaninterfaces.ReducePriority)
					// property: name=wan_interface_id, type=STRING macro=copy_to_state
					state.SpokeHaConfig.Track.Waninterfaces[varLoopWaninterfacesIndex].WanInterfaceId = types.StringPointerValue(varLoopWaninterfaces.WanInterfaceId)
				}
			}
		}
	}
	// property: name=state, type=STRING macro=copy_to_state
	state.State = types.StringPointerValue(ans.State)
	// property: name=sw_obj, type=REFERENCE macro=copy_to_state
	if ans.SwObj == nil {
		state.SwObj = nil
	} else {
		state.SwObj = &rsModelSoftware{}
		// copy_to_state: state=state.SwObj prefix=rsModel ans=ans.SwObj properties=2
		tflog.Debug(ctx, "copy_to_state state=state.SwObj prefix=rsModel ans=ans.SwObj")
		// property: name=location, type=STRING macro=copy_to_state
		state.SwObj.Location = types.StringPointerValue(ans.SwObj.Location)
		// property: name=version, type=STRING macro=copy_to_state
		state.SwObj.Version = types.StringPointerValue(ans.SwObj.Version)
	}
	// property: name=switch_config, type=REFERENCE macro=copy_to_state
	if ans.SwitchConfig == nil {
		state.SwitchConfig = nil
	} else {
		state.SwitchConfig = &rsModelSwitchConfig{}
		// copy_to_state: state=state.SwitchConfig prefix=rsModel ans=ans.SwitchConfig properties=8
		tflog.Debug(ctx, "copy_to_state state=state.SwitchConfig prefix=rsModel ans=ans.SwitchConfig")
		// property: name=default_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchConfig.DefaultVlanId = types.Int64PointerValue(ans.SwitchConfig.DefaultVlanId)
		// property: name=mstp_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchConfig.MstpEnabled = types.BoolPointerValue(ans.SwitchConfig.MstpEnabled)
		// property: name=stp_aging_timer, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpAgingTimer = types.Int64PointerValue(ans.SwitchConfig.StpAgingTimer)
		// property: name=stp_forward_delay, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpForwardDelay = types.Int64PointerValue(ans.SwitchConfig.StpForwardDelay)
		// property: name=stp_hello_time, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpHelloTime = types.Int64PointerValue(ans.SwitchConfig.StpHelloTime)
		// property: name=stp_max_age, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpMaxAge = types.Int64PointerValue(ans.SwitchConfig.StpMaxAge)
		// property: name=stp_mode, type=STRING macro=copy_to_state
		state.SwitchConfig.StpMode = types.StringPointerValue(ans.SwitchConfig.StpMode)
		// property: name=stp_priority, type=INTEGER macro=copy_to_state
		state.SwitchConfig.StpPriority = types.Int64PointerValue(ans.SwitchConfig.StpPriority)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	// property: name=tenant_id, type=STRING macro=copy_to_state
	state.TenantId = types.StringPointerValue(ans.TenantId)
	// property: name=vpn_to_vpn_forwarding, type=BOOLEAN macro=copy_to_state
	state.VpnToVpnForwarding = types.BoolPointerValue(ans.VpnToVpnForwarding)
	return true
}

func (r *elementShellResource) doDelete(ctx context.Context, state *rsModelElementScreenV3N2, resp *resource.DeleteResponse) bool {
	// read object id
	tfid := state.Tfid.ValueString()
	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "prismasdwan_element_shell",
		"locMap":                      map[string]int{"prefix_id": 0},
	})

	// tokens must match
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) < 2 {
		resp.Diagnostics.AddError("error in prismasdwan_element_shell ID format", "Expected 2 tokens")
		return false
	}

	// Prepare input for the API endpoint.
	delete_request := &sdwan_client.SdwanClientRequestResponse{}
	delete_request.ResourceType = "prismasdwan_element_shell"
	delete_request.Method = "DELETE"
	delete_request.Path = "/sdwan/v2.1/api/sites/{site_id}/elementshells/{element_shell_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, state.TfParameters)
	delete_request.PathParameters = &params
	// add last parameter as ObjectID
	(*delete_request.PathParameters)["element_shell_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*delete_request.PathParameters)[param[0]] = &param[1]
	}

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, delete_request)
	if delete_request.ResponseErr != nil {
		if !IsObjectNotFound(*delete_request.ResponseErr) {
			resp.Diagnostics.AddError("error deleting prismasdwan_element_shell", (*delete_request.ResponseErr).Error())
			return false
		}
	}
	return true
}

// Performs the Create(POST) Operation on the Resource
// TfID is pulled from plan to use in the creation request
// Path Parameters are encoded into TfID itself
func (r *elementShellResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "executing resource create for prismasdwan_element_shell")
	var plan rsModelElementScreenV3N2
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make post call
	var state rsModelElementScreenV3N2
	if r.doPost(ctx, &plan, &state, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Read(GET) Operation on the Resource
// TfID is pulled from state to use in the read request
// Path Parameters are extracted TfID itself
func (r *elementShellResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	tflog.Info(ctx, "executing resource read for prismasdwan_element_shell")
	var savestate, state rsModelElementScreenV3N2
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// for shell, hw_id is always null
	if savestate.HwId.IsNull() {
		tflog.Debug(ctx, "hw_id was found to be null, reading as shell")
		if r.doGet(ctx, &state, &savestate, &resp.State, resp) {
			resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
		} else {
			tflog.Debug(ctx, "reading as shell failed, reading as element")
			e_r := &elementResource{
				client: r.client,
			}
			savestate.Tfid = savestate.ElementId
			if e_r.doGet(ctx, &state, &savestate, &resp.State, resp) {
				resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
			}
		}
	} else {
		tflog.Debug(ctx, "hw_id was found to be non-null, reading as element")
		e_r := &elementResource{
			client: r.client,
		}
		if e_r.doGet(ctx, &state, &savestate, &resp.State, resp) {
			resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
		}
	}
}

// Performs the Update(PUT) Operation on the Resource
// TfID is pulled from state to use in the read request
// Path Parameters are extracted TfID itself
// TfID must match in state and plan, else error is thrown
func (r *elementShellResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	tflog.Info(ctx, "executing resource update for prismasdwan_element_shell")
	var plan, state rsModelElementScreenV3N2
	// copy state from TF
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// copy plan from TF
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// for shell, hw_id is always null
	if state.HwId.IsNull() {
		// make a put call
		tflog.Debug(ctx, "hw_id was found to be null, updating as shell")
		if r.doPut(ctx, &plan, &state, &resp.State, resp) {
			resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
		} else {
			tflog.Debug(ctx, "updating as shell failed, updating as element")
			e_r := &elementResource{
				client: r.client,
			}
			state.Tfid = state.ElementId
			if e_r.doPut(ctx, &plan, &state, &resp.State, resp) {
				resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
			}
		}
	} else {
		tflog.Debug(ctx, "hw_id was found to be non-null, updating as element")
		e_r := &elementResource{
			client: r.client,
		}
		if e_r.doPut(ctx, &plan, &state, &resp.State, resp) {
			resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
		}
	}
}

// Performs the Delete Operation on the Resource
// TfID is pulled from state to use in the deletion request
// Path Parameters are extracted from the TfID itself
func (r *elementShellResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	tflog.Info(ctx, "executing resource delete for prismasdwan_element_shell")
	var state rsModelElementScreenV3N2
	// copy state from TF
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a delete call
	if r.doDelete(ctx, &state, resp) {
		resp.State.RemoveResource(ctx)
	}
}

func (r *elementShellResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

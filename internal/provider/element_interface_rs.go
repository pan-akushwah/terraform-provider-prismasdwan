package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"strings"

	sdwan "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk"
	sdwan_schema "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas"
	sdwan_client "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/services"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidwall/sjson"
)

// +-----------------------------------------------------------------
// | Schema Map Summary (size=goLangStructMap=38)
// | Computed Resource Name=sites_elements_interfaces
// +-----------------------------------------------------------------
// | APNConfig HasID=false
// | CellularInterfaceConfig HasID=false
// | PortChannelConfig HasID=false
// | PassiveMode HasID=false
// | IKEV1Params HasID=false
// | IPSECAuthenticationV1 HasID=false
// | IPSECConfigV1 HasID=false
// | GREConfig HasID=false
// | PeerInfo HasID=false
// | ServiceLinkV4 HasID=false
// | VlanConfig HasID=false
// | AuthenticationInterfaceConfig HasID=false
// | Ipv6StaticV1 HasID=false
// | Route HasID=false
// | DNS HasID=false
// | Ipv6Dhcp HasID=false
// | Ipv6ConfigV1 HasID=false
// | PppoEInterfaceConfig HasID=false
// | StormControlConfig HasID=false
// | SwitchPortConfig HasID=false
// | MulticastIgmpStaticJoin HasID=false
// | MulticastInterfaceConfig HasID=false
// | StaticARPConfig HasID=false
// | SecondaryIPConfig HasID=false
// | IPv4Range HasID=false
// | NatPool HasID=false
// | BypassPairV2 HasID=false
// | SubInterface HasID=false
// | Ethernet HasID=true
// | EthernetPort HasID=false
// | DHCPRelayOption82 HasID=false
// | DHCPRelay HasID=false
// | Ipv4Pppoe HasID=false
// | Ipv4Dhcp HasID=false
// | Ipv4Static HasID=false
// | Ipv4Config HasID=false
// | LanNetworkVlanMapping HasID=false
// | InterfaceScreenV4N20 HasID=true
// +-----------------------------------------------------------------

// Resource.
var (
	_ resource.Resource                = &elementInterfaceResource{}
	_ resource.ResourceWithConfigure   = &elementInterfaceResource{}
	_ resource.ResourceWithImportState = &elementInterfaceResource{}
)

// To enable this data source for TF Provider, go to `provider.go` and inject this into the function
// as below:
//
//	func (p *SdwanProvider) Resources(_ context.Context) []func() resource.Resource {
//	  	return []func() resource.Resource{
//	     ... <other existing resources>
//	     NewElementInterfaceResource,
//	     // -- append next resource above -- //
//	     }
//	  }
func NewElementInterfaceResource() resource.Resource {
	return &elementInterfaceResource{}
}

type elementInterfaceResource struct {
	client *sdwan.Client
}

// Metadata returns the data source type name.
func (r *elementInterfaceResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "prismasdwan_element_interface"
}

// Schema defines the schema for this data source.
func (r *elementInterfaceResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",
		Attributes: map[string]rsschema.Attribute{
			"tfid": rsschema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			// rest all properties to be read from GET API Schema schema=InterfaceScreenV4N20
			// generic x_parameters is added to accomodate path parameters
			"x_parameters": rsschema.MapAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				ElementType: types.StringType,
			},
			// property: name=_etag, type=INTEGER macro=rss_schema
			"x_etag": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=_etag, type=INTEGER macro=rss_schema
			// property: name=_schema, type=INTEGER macro=rss_schema
			"x_schema": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=_schema, type=INTEGER macro=rss_schema
			// property: name=admin_up, type=BOOLEAN macro=rss_schema
			"admin_up": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=admin_up, type=BOOLEAN macro=rss_schema
			// property: name=attached_lan_networks, type=ARRAY_REFERENCE macro=rss_schema
			"attached_lan_networks": rsschema.ListNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// property: name=lan_network_id, type=STRING macro=rss_schema
						"lan_network_id": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=lan_network_id, type=STRING macro=rss_schema
						// property: name=vlan_id, type=INTEGER macro=rss_schema
						"vlan_id": rsschema.Int64Attribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=vlan_id, type=INTEGER macro=rss_schema
					},
				},
			},
			// key name holder for attribute: name=vlan_id, type=INTEGER macro=rss_schema
			// property: name=authentication_config, type=REFERENCE macro=rss_schema
			"authentication_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=fallback_retry_count, type=INTEGER macro=rss_schema
					"fallback_retry_count": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=fallback_retry_count, type=INTEGER macro=rss_schema
					// property: name=mode, type=STRING macro=rss_schema
					"mode": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=mode, type=STRING macro=rss_schema
					// property: name=reauthentication_timeout, type=INTEGER macro=rss_schema
					"reauthentication_timeout": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=reauthentication_timeout, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=reauthentication_timeout, type=INTEGER macro=rss_schema
			// property: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=rss_schema
			"bound_interfaces": rsschema.ListAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
			// key name holder for attribute: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=rss_schema
			// property: name=bypass_pair, type=REFERENCE macro=rss_schema
			"bypass_pair": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=lan, type=STRING macro=rss_schema
					"lan": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=lan, type=STRING macro=rss_schema
					// property: name=lan_state_propagation, type=BOOLEAN macro=rss_schema
					"lan_state_propagation": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=lan_state_propagation, type=BOOLEAN macro=rss_schema
					// property: name=use_relay, type=BOOLEAN macro=rss_schema
					"use_relay": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=use_relay, type=BOOLEAN macro=rss_schema
					// property: name=wan, type=STRING macro=rss_schema
					"wan": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=wan, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=wan, type=STRING macro=rss_schema
			// property: name=cellular_config, type=REFERENCE macro=rss_schema
			"cellular_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=apn_config, type=REFERENCE macro=rss_schema
					"apn_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=apn, type=STRING macro=rss_schema
							"apn": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=apn, type=STRING macro=rss_schema
							// property: name=authentication, type=STRING macro=rss_schema
							"authentication": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=authentication, type=STRING macro=rss_schema
							// property: name=clear_password, type=BOOLEAN macro=rss_schema
							"clear_password": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=clear_password, type=BOOLEAN macro=rss_schema
							// property: name=password, type=STRING macro=rss_schema
							"password": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: true,
							},
							// key name holder for attribute: name=password, type=STRING macro=rss_schema
							"password_internal_key_name": rsschema.StringAttribute{
								Required:  false,
								Computed:  true,
								Optional:  true,
								Sensitive: false,
							},
							// property: name=password_encrypted, type=STRING macro=rss_schema
							"password_encrypted": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: true,
							},
							// key name holder for attribute: name=password_encrypted, type=STRING macro=rss_schema
							"password_encrypted_internal_key_name": rsschema.StringAttribute{
								Required:  false,
								Computed:  true,
								Optional:  true,
								Sensitive: false,
							},
							// property: name=user_name, type=STRING macro=rss_schema
							"user_name": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=user_name, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=user_name, type=STRING macro=rss_schema
					// property: name=apnprofile_id, type=STRING macro=rss_schema
					"apnprofile_id": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=apnprofile_id, type=STRING macro=rss_schema
					// property: name=auto_apn, type=BOOLEAN macro=rss_schema
					"auto_apn": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=auto_apn, type=BOOLEAN macro=rss_schema
					// property: name=parent_module_id, type=STRING macro=rss_schema
					"parent_module_id": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=parent_module_id, type=STRING macro=rss_schema
					// property: name=parent_sim_slot_number, type=INTEGER macro=rss_schema
					"parent_sim_slot_number": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=parent_sim_slot_number, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=parent_sim_slot_number, type=INTEGER macro=rss_schema
			// property: name=description, type=STRING macro=rss_schema
			"description": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=description, type=STRING macro=rss_schema
			// property: name=devicemgmt_policysetstack_id, type=STRING macro=rss_schema
			"devicemgmt_policysetstack_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=devicemgmt_policysetstack_id, type=STRING macro=rss_schema
			// property: name=dhcp_relay, type=REFERENCE macro=rss_schema
			"dhcp_relay": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=enabled, type=BOOLEAN macro=rss_schema
					"enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=enabled, type=BOOLEAN macro=rss_schema
					// property: name=option_82, type=REFERENCE macro=rss_schema
					"option_82": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=circuit_id, type=STRING macro=rss_schema
							"circuit_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=circuit_id, type=STRING macro=rss_schema
							// property: name=enabled, type=BOOLEAN macro=rss_schema
							"enabled": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=enabled, type=BOOLEAN macro=rss_schema
							// property: name=reforwarding_policy, type=STRING macro=rss_schema
							"reforwarding_policy": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=reforwarding_policy, type=STRING macro=rss_schema
							// property: name=remote_id, type=STRING macro=rss_schema
							"remote_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=remote_id, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=remote_id, type=STRING macro=rss_schema
					// property: name=server_ips, type=ARRAY_PRIMITIVE macro=rss_schema
					"server_ips": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=server_ips, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=source_interface, type=STRING macro=rss_schema
					"source_interface": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=source_interface, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=source_interface, type=STRING macro=rss_schema
			// property: name=directed_broadcast, type=BOOLEAN macro=rss_schema
			"directed_broadcast": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=directed_broadcast, type=BOOLEAN macro=rss_schema
			// property: name=ethernet_port, type=REFERENCE macro=rss_schema
			"ethernet_port": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=full_duplex, type=BOOLEAN macro=rss_schema
					"full_duplex": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=full_duplex, type=BOOLEAN macro=rss_schema
					// property: name=port_id, type=REFERENCE macro=rss_schema
					"port_id": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// generic x_parameters is added to accomodate path parameters
							"x_parameters": rsschema.MapAttribute{
								Required:    false,
								Computed:    false,
								Optional:    true,
								ElementType: types.StringType,
							},
							// property: name=_etag, type=INTEGER macro=rss_schema
							"x_etag": rsschema.Int64Attribute{
								Required:  false,
								Computed:  true,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=_etag, type=INTEGER macro=rss_schema
							// property: name=_schema, type=INTEGER macro=rss_schema
							"x_schema": rsschema.Int64Attribute{
								Required:  false,
								Computed:  true,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=_schema, type=INTEGER macro=rss_schema
							// property: name=connector, type=STRING macro=rss_schema
							"connector": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=connector, type=STRING macro=rss_schema
							// property: name=device, type=STRING macro=rss_schema
							"device": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=device, type=STRING macro=rss_schema
							// property: name=disabled, type=BOOLEAN macro=rss_schema
							"disabled": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=disabled, type=BOOLEAN macro=rss_schema
							// property: name=disabled_reason, type=STRING macro=rss_schema
							"disabled_reason": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=disabled_reason, type=STRING macro=rss_schema
							// property: name=element_id, type=STRING macro=rss_schema
							"element_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=element_id, type=STRING macro=rss_schema
							// property: name=id, type=STRING macro=rss_schema
							"id": rsschema.StringAttribute{
								Required:  false,
								Computed:  true,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=id, type=STRING macro=rss_schema
							// property: name=inactive, type=BOOLEAN macro=rss_schema
							"inactive": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=inactive, type=BOOLEAN macro=rss_schema
							// property: name=inactive_reason, type=STRING macro=rss_schema
							"inactive_reason": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=inactive_reason, type=STRING macro=rss_schema
							// property: name=max_mtu, type=INTEGER macro=rss_schema
							"max_mtu": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=max_mtu, type=INTEGER macro=rss_schema
							// property: name=max_speed, type=INTEGER macro=rss_schema
							"max_speed": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=max_speed, type=INTEGER macro=rss_schema
							// property: name=name, type=STRING macro=rss_schema
							"name": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=name, type=STRING macro=rss_schema
							// property: name=original_mac_address, type=STRING macro=rss_schema
							"original_mac_address": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=original_mac_address, type=STRING macro=rss_schema
							// property: name=region, type=STRING macro=rss_schema
							"region": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=region, type=STRING macro=rss_schema
							// property: name=site_id, type=STRING macro=rss_schema
							"site_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=site_id, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=site_id, type=STRING macro=rss_schema
					// property: name=port_name, type=STRING macro=rss_schema
					"port_name": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=port_name, type=STRING macro=rss_schema
					// property: name=speed, type=INTEGER macro=rss_schema
					"speed": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=speed, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=speed, type=INTEGER macro=rss_schema
			// property: name=id, type=STRING macro=rss_schema
			"id": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=id, type=STRING macro=rss_schema
			// property: name=interface_profile_id, type=STRING macro=rss_schema
			"interface_profile_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=interface_profile_id, type=STRING macro=rss_schema
			// property: name=ipfixcollectorcontext_id, type=STRING macro=rss_schema
			"ipfixcollectorcontext_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=ipfixcollectorcontext_id, type=STRING macro=rss_schema
			// property: name=ipfixfiltercontext_id, type=STRING macro=rss_schema
			"ipfixfiltercontext_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=ipfixfiltercontext_id, type=STRING macro=rss_schema
			// property: name=ipv4_config, type=REFERENCE macro=rss_schema
			"ipv4_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=dhcp_config, type=REFERENCE macro=rss_schema
					"dhcp_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=client_id, type=STRING macro=rss_schema
							"client_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=client_id, type=STRING macro=rss_schema
							// property: name=hostname, type=STRING macro=rss_schema
							"hostname": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=hostname, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=hostname, type=STRING macro=rss_schema
					// property: name=dns_v4_config, type=REFERENCE macro=rss_schema
					"dns_v4_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=name_servers, type=ARRAY_PRIMITIVE macro=rss_schema
							"name_servers": rsschema.ListAttribute{
								Required:    false,
								Computed:    false,
								Optional:    true,
								Sensitive:   false,
								ElementType: types.StringType,
							},
							// key name holder for attribute: name=name_servers, type=ARRAY_PRIMITIVE macro=rss_schema
							// property: name=search, type=ARRAY_PRIMITIVE macro=rss_schema
							"search": rsschema.ListAttribute{
								Required:    false,
								Computed:    false,
								Optional:    true,
								Sensitive:   false,
								ElementType: types.StringType,
							},
							// key name holder for attribute: name=search, type=ARRAY_PRIMITIVE macro=rss_schema
						},
					},
					// key name holder for attribute: name=search, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=pppoe_config, type=REFERENCE macro=rss_schema
					"pppoe_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=chap_passwd, type=STRING macro=rss_schema
							"chap_passwd": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=chap_passwd, type=STRING macro=rss_schema
							// property: name=chap_user, type=STRING macro=rss_schema
							"chap_user": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=chap_user, type=STRING macro=rss_schema
							// property: name=set_route, type=BOOLEAN macro=rss_schema
							"set_route": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=set_route, type=BOOLEAN macro=rss_schema
						},
					},
					// key name holder for attribute: name=set_route, type=BOOLEAN macro=rss_schema
					// property: name=routes, type=ARRAY_REFERENCE macro=rss_schema
					"routes": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=destination, type=STRING macro=rss_schema
								"destination": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=destination, type=STRING macro=rss_schema
								// property: name=via, type=STRING macro=rss_schema
								"via": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=via, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=via, type=STRING macro=rss_schema
					// property: name=static_config, type=REFERENCE macro=rss_schema
					"static_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=address, type=STRING macro=rss_schema
							"address": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=address, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=address, type=STRING macro=rss_schema
					// property: name=type, type=STRING macro=rss_schema
					"type": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=type, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=type, type=STRING macro=rss_schema
			// property: name=ipv6_config, type=REFERENCE macro=rss_schema
			"ipv6_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=dhcp_config, type=REFERENCE macro=rss_schema
					"dhcp_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=client_id, type=STRING macro=rss_schema
							"client_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=client_id, type=STRING macro=rss_schema
							// property: name=hostname, type=STRING macro=rss_schema
							"hostname": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=hostname, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=hostname, type=STRING macro=rss_schema
					// property: name=dns_v6_config, type=REFERENCE macro=rss_schema
					"dns_v6_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=name_servers, type=ARRAY_PRIMITIVE macro=rss_schema
							"name_servers": rsschema.ListAttribute{
								Required:    false,
								Computed:    false,
								Optional:    true,
								Sensitive:   false,
								ElementType: types.StringType,
							},
							// key name holder for attribute: name=name_servers, type=ARRAY_PRIMITIVE macro=rss_schema
							// property: name=search, type=ARRAY_PRIMITIVE macro=rss_schema
							"search": rsschema.ListAttribute{
								Required:    false,
								Computed:    false,
								Optional:    true,
								Sensitive:   false,
								ElementType: types.StringType,
							},
							// key name holder for attribute: name=search, type=ARRAY_PRIMITIVE macro=rss_schema
						},
					},
					// key name holder for attribute: name=search, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=routes, type=ARRAY_REFERENCE macro=rss_schema
					"routes": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=destination, type=STRING macro=rss_schema
								"destination": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=destination, type=STRING macro=rss_schema
								// property: name=via, type=STRING macro=rss_schema
								"via": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=via, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=via, type=STRING macro=rss_schema
					// property: name=static_config, type=REFERENCE macro=rss_schema
					"static_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=address, type=STRING macro=rss_schema
							"address": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=address, type=STRING macro=rss_schema
							// property: name=enable_prefix_distribution, type=BOOLEAN macro=rss_schema
							"enable_prefix_distribution": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=enable_prefix_distribution, type=BOOLEAN macro=rss_schema
						},
					},
					// key name holder for attribute: name=enable_prefix_distribution, type=BOOLEAN macro=rss_schema
					// property: name=type, type=STRING macro=rss_schema
					"type": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=type, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=type, type=STRING macro=rss_schema
			// property: name=lldp_enabled, type=BOOLEAN macro=rss_schema
			"lldp_enabled": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=lldp_enabled, type=BOOLEAN macro=rss_schema
			// property: name=mac_address, type=STRING macro=rss_schema
			"mac_address": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=mac_address, type=STRING macro=rss_schema
			// property: name=mtu, type=INTEGER macro=rss_schema
			"mtu": rsschema.Int64Attribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=mtu, type=INTEGER macro=rss_schema
			// property: name=multicast_config, type=REFERENCE macro=rss_schema
			"multicast_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=dr_priority, type=INTEGER macro=rss_schema
					"dr_priority": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=dr_priority, type=INTEGER macro=rss_schema
					// property: name=igmp_static_joins, type=ARRAY_REFERENCE macro=rss_schema
					"igmp_static_joins": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=igmp_static_grp_ipv4, type=STRING macro=rss_schema
								"igmp_static_grp_ipv4": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=igmp_static_grp_ipv4, type=STRING macro=rss_schema
								// property: name=igmp_static_src_ipv4, type=STRING macro=rss_schema
								"igmp_static_src_ipv4": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=igmp_static_src_ipv4, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=igmp_static_src_ipv4, type=STRING macro=rss_schema
					// property: name=igmp_version, type=STRING macro=rss_schema
					"igmp_version": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=igmp_version, type=STRING macro=rss_schema
					// property: name=multicast_enabled, type=BOOLEAN macro=rss_schema
					"multicast_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=multicast_enabled, type=BOOLEAN macro=rss_schema
				},
			},
			// key name holder for attribute: name=multicast_enabled, type=BOOLEAN macro=rss_schema
			// property: name=name, type=STRING macro=rss_schema
			"name": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=name, type=STRING macro=rss_schema
			// property: name=nat_address, type=STRING macro=rss_schema
			"nat_address": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=nat_address, type=STRING macro=rss_schema
			// property: name=nat_address_v6, type=STRING macro=rss_schema
			"nat_address_v6": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=nat_address_v6, type=STRING macro=rss_schema
			// property: name=nat_pools, type=ARRAY_REFERENCE macro=rss_schema
			"nat_pools": rsschema.ListNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// property: name=ipv4_ranges, type=ARRAY_REFERENCE macro=rss_schema
						"ipv4_ranges": rsschema.ListNestedAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
							NestedObject: rsschema.NestedAttributeObject{
								Attributes: map[string]rsschema.Attribute{
									// property: name=end, type=STRING macro=rss_schema
									"end": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=end, type=STRING macro=rss_schema
									// property: name=start, type=STRING macro=rss_schema
									"start": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=start, type=STRING macro=rss_schema
								},
							},
						},
						// key name holder for attribute: name=start, type=STRING macro=rss_schema
						// property: name=nat_pool_id, type=STRING macro=rss_schema
						"nat_pool_id": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=nat_pool_id, type=STRING macro=rss_schema
					},
				},
			},
			// key name holder for attribute: name=nat_pool_id, type=STRING macro=rss_schema
			// property: name=nat_port, type=INTEGER macro=rss_schema
			"nat_port": rsschema.Int64Attribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=nat_port, type=INTEGER macro=rss_schema
			// property: name=nat_port_v6, type=INTEGER macro=rss_schema
			"nat_port_v6": rsschema.Int64Attribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=nat_port_v6, type=INTEGER macro=rss_schema
			// property: name=nat_zone_id, type=STRING macro=rss_schema
			"nat_zone_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=nat_zone_id, type=STRING macro=rss_schema
			// property: name=network_context_id, type=STRING macro=rss_schema
			"network_context_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=network_context_id, type=STRING macro=rss_schema
			// property: name=parent, type=STRING macro=rss_schema
			"parent": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=parent, type=STRING macro=rss_schema
			// property: name=peer_bypasspair_wan_port_type, type=STRING macro=rss_schema
			"peer_bypasspair_wan_port_type": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=peer_bypasspair_wan_port_type, type=STRING macro=rss_schema
			// property: name=poe_enabled, type=BOOLEAN macro=rss_schema
			"poe_enabled": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=poe_enabled, type=BOOLEAN macro=rss_schema
			// property: name=port_channel_config, type=REFERENCE macro=rss_schema
			"port_channel_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=lacp_enabled, type=BOOLEAN macro=rss_schema
					"lacp_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=lacp_enabled, type=BOOLEAN macro=rss_schema
					// property: name=transmission_mode, type=STRING macro=rss_schema
					"transmission_mode": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=transmission_mode, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=transmission_mode, type=STRING macro=rss_schema
			// property: name=power_usage_threshold, type=INTEGER macro=rss_schema
			"power_usage_threshold": rsschema.Int64Attribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=power_usage_threshold, type=INTEGER macro=rss_schema
			// property: name=pppoe_config, type=REFERENCE macro=rss_schema
			"pppoe_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=host_uniq, type=STRING macro=rss_schema
					"host_uniq": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=host_uniq, type=STRING macro=rss_schema
					// property: name=ip_address_type, type=STRING macro=rss_schema
					"ip_address_type": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=ip_address_type, type=STRING macro=rss_schema
					// property: name=password, type=STRING macro=rss_schema
					"password": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: true,
					},
					// key name holder for attribute: name=password, type=STRING macro=rss_schema
					"password_internal_key_name": rsschema.StringAttribute{
						Required:  false,
						Computed:  true,
						Optional:  true,
						Sensitive: false,
					},
					// property: name=reconnection_delay, type=INTEGER macro=rss_schema
					"reconnection_delay": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=reconnection_delay, type=INTEGER macro=rss_schema
					// property: name=service_name, type=STRING macro=rss_schema
					"service_name": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=service_name, type=STRING macro=rss_schema
					// property: name=username, type=STRING macro=rss_schema
					"username": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=username, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=username, type=STRING macro=rss_schema
			// property: name=scope, type=STRING macro=rss_schema
			"scope": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=scope, type=STRING macro=rss_schema
			// property: name=secondary_ip_configs, type=ARRAY_REFERENCE macro=rss_schema
			"secondary_ip_configs": rsschema.ListNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// property: name=ipv4_address, type=STRING macro=rss_schema
						"ipv4_address": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=ipv4_address, type=STRING macro=rss_schema
						// property: name=scope, type=STRING macro=rss_schema
						"scope": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=scope, type=STRING macro=rss_schema
					},
				},
			},
			// key name holder for attribute: name=scope, type=STRING macro=rss_schema
			// property: name=service_link_config, type=REFERENCE macro=rss_schema
			"service_link_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=gre_config, type=REFERENCE macro=rss_schema
					"gre_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=csum, type=BOOLEAN macro=rss_schema
							"csum": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=csum, type=BOOLEAN macro=rss_schema
							// property: name=keepalive_enable, type=BOOLEAN macro=rss_schema
							"keepalive_enable": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=keepalive_enable, type=BOOLEAN macro=rss_schema
							// property: name=keepalive_fail_count, type=INTEGER macro=rss_schema
							"keepalive_fail_count": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=keepalive_fail_count, type=INTEGER macro=rss_schema
							// property: name=keepalive_interval, type=INTEGER macro=rss_schema
							"keepalive_interval": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=keepalive_interval, type=INTEGER macro=rss_schema
						},
					},
					// key name holder for attribute: name=keepalive_interval, type=INTEGER macro=rss_schema
					// property: name=ipsec_config, type=REFERENCE macro=rss_schema
					"ipsec_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=authentication, type=REFERENCE macro=rss_schema
							"authentication": rsschema.SingleNestedAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
								Attributes: map[string]rsschema.Attribute{
									// property: name=certificate, type=STRING macro=rss_schema
									"certificate": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=certificate, type=STRING macro=rss_schema
									// property: name=certificate_profile_id, type=STRING macro=rss_schema
									"certificate_profile_id": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=certificate_profile_id, type=STRING macro=rss_schema
									// property: name=comment, type=STRING macro=rss_schema
									"comment": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=comment, type=STRING macro=rss_schema
									// property: name=ikev1_params, type=REFERENCE macro=rss_schema
									"ikev1_params": rsschema.SingleNestedAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
										Attributes: map[string]rsschema.Attribute{
											// property: name=xauth_id, type=STRING macro=rss_schema
											"xauth_id": rsschema.StringAttribute{
												Required:  false,
												Computed:  false,
												Optional:  true,
												Sensitive: false,
											},
											// key name holder for attribute: name=xauth_id, type=STRING macro=rss_schema
											// property: name=xauth_secret, type=STRING macro=rss_schema
											"xauth_secret": rsschema.StringAttribute{
												Required:  false,
												Computed:  false,
												Optional:  true,
												Sensitive: true,
											},
											// key name holder for attribute: name=xauth_secret, type=STRING macro=rss_schema
											"xauth_secret_internal_key_name": rsschema.StringAttribute{
												Required:  false,
												Computed:  true,
												Optional:  true,
												Sensitive: false,
											},
											// property: name=xauth_secret_encrypted, type=STRING macro=rss_schema
											"xauth_secret_encrypted": rsschema.StringAttribute{
												Required:  false,
												Computed:  false,
												Optional:  true,
												Sensitive: true,
											},
											// key name holder for attribute: name=xauth_secret_encrypted, type=STRING macro=rss_schema
											"xauth_secret_encrypted_internal_key_name": rsschema.StringAttribute{
												Required:  false,
												Computed:  true,
												Optional:  true,
												Sensitive: false,
											},
											// property: name=xauth_secret_hash, type=STRING macro=rss_schema
											"xauth_secret_hash": rsschema.StringAttribute{
												Required:  false,
												Computed:  false,
												Optional:  true,
												Sensitive: true,
											},
											// key name holder for attribute: name=xauth_secret_hash, type=STRING macro=rss_schema
											"xauth_secret_hash_internal_key_name": rsschema.StringAttribute{
												Required:  false,
												Computed:  true,
												Optional:  true,
												Sensitive: false,
											},
											// property: name=xauth_type, type=STRING macro=rss_schema
											"xauth_type": rsschema.StringAttribute{
												Required:  false,
												Computed:  false,
												Optional:  true,
												Sensitive: false,
											},
											// key name holder for attribute: name=xauth_type, type=STRING macro=rss_schema
										},
									},
									// key name holder for attribute: name=xauth_type, type=STRING macro=rss_schema
									// property: name=local_ca_certificate, type=STRING macro=rss_schema
									"local_ca_certificate": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=local_ca_certificate, type=STRING macro=rss_schema
									// property: name=local_id, type=STRING macro=rss_schema
									"local_id": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=local_id, type=STRING macro=rss_schema
									// property: name=local_id_custom, type=STRING macro=rss_schema
									"local_id_custom": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=local_id_custom, type=STRING macro=rss_schema
									// property: name=local_pa_certificate_id, type=STRING macro=rss_schema
									"local_pa_certificate_id": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=local_pa_certificate_id, type=STRING macro=rss_schema
									// property: name=pa_master_key_id, type=STRING macro=rss_schema
									"pa_master_key_id": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=pa_master_key_id, type=STRING macro=rss_schema
									// property: name=passphrase, type=STRING macro=rss_schema
									"passphrase": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=passphrase, type=STRING macro=rss_schema
									// property: name=passphrase_encrypted, type=STRING macro=rss_schema
									"passphrase_encrypted": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=passphrase_encrypted, type=STRING macro=rss_schema
									// property: name=peer_id_check, type=STRING macro=rss_schema
									"peer_id_check": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=peer_id_check, type=STRING macro=rss_schema
									// property: name=permit_peer_id_mismatch, type=BOOLEAN macro=rss_schema
									"permit_peer_id_mismatch": rsschema.BoolAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=permit_peer_id_mismatch, type=BOOLEAN macro=rss_schema
									// property: name=private_key, type=STRING macro=rss_schema
									"private_key": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=private_key, type=STRING macro=rss_schema
									// property: name=private_key_encrypted, type=STRING macro=rss_schema
									"private_key_encrypted": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=private_key_encrypted, type=STRING macro=rss_schema
									// property: name=remote_ca_certificate, type=STRING macro=rss_schema
									"remote_ca_certificate": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=remote_ca_certificate, type=STRING macro=rss_schema
									// property: name=remote_id, type=STRING macro=rss_schema
									"remote_id": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=remote_id, type=STRING macro=rss_schema
									// property: name=secret, type=STRING macro=rss_schema
									"secret": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: true,
									},
									// key name holder for attribute: name=secret, type=STRING macro=rss_schema
									"secret_internal_key_name": rsschema.StringAttribute{
										Required:  false,
										Computed:  true,
										Optional:  true,
										Sensitive: false,
									},
									// property: name=secret_encrypted, type=STRING macro=rss_schema
									"secret_encrypted": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: true,
									},
									// key name holder for attribute: name=secret_encrypted, type=STRING macro=rss_schema
									"secret_encrypted_internal_key_name": rsschema.StringAttribute{
										Required:  false,
										Computed:  true,
										Optional:  true,
										Sensitive: false,
									},
									// property: name=secret_hash, type=STRING macro=rss_schema
									"secret_hash": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: true,
									},
									// key name holder for attribute: name=secret_hash, type=STRING macro=rss_schema
									"secret_hash_internal_key_name": rsschema.StringAttribute{
										Required:  false,
										Computed:  true,
										Optional:  true,
										Sensitive: false,
									},
									// property: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=rss_schema
									"strict_validation_peer_extended_key_use": rsschema.BoolAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=rss_schema
									// property: name=type, type=STRING macro=rss_schema
									"type": rsschema.StringAttribute{
										Required:  false,
										Computed:  false,
										Optional:  true,
										Sensitive: false,
									},
									// key name holder for attribute: name=type, type=STRING macro=rss_schema
								},
							},
							// key name holder for attribute: name=type, type=STRING macro=rss_schema
							// property: name=ipsec_profile_id, type=STRING macro=rss_schema
							"ipsec_profile_id": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=ipsec_profile_id, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=ipsec_profile_id, type=STRING macro=rss_schema
					// property: name=last_parent, type=STRING macro=rss_schema
					"last_parent": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=last_parent, type=STRING macro=rss_schema
					// property: name=parent, type=STRING macro=rss_schema
					"parent": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=parent, type=STRING macro=rss_schema
					// property: name=passive_mode, type=REFERENCE macro=rss_schema
					"passive_mode": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=enable, type=BOOLEAN macro=rss_schema
							"enable": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=enable, type=BOOLEAN macro=rss_schema
							// property: name=peer_ip_dynamic, type=BOOLEAN macro=rss_schema
							"peer_ip_dynamic": rsschema.BoolAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=peer_ip_dynamic, type=BOOLEAN macro=rss_schema
						},
					},
					// key name holder for attribute: name=peer_ip_dynamic, type=BOOLEAN macro=rss_schema
					// property: name=peer, type=REFERENCE macro=rss_schema
					"peer": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=hostname, type=STRING macro=rss_schema
							"hostname": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=hostname, type=STRING macro=rss_schema
							// property: name=ip_addresses, type=ARRAY_PRIMITIVE macro=rss_schema
							"ip_addresses": rsschema.ListAttribute{
								Required:    false,
								Computed:    false,
								Optional:    true,
								Sensitive:   false,
								ElementType: types.StringType,
							},
							// key name holder for attribute: name=ip_addresses, type=ARRAY_PRIMITIVE macro=rss_schema
						},
					},
					// key name holder for attribute: name=ip_addresses, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=service_endpoint_id, type=STRING macro=rss_schema
					"service_endpoint_id": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=service_endpoint_id, type=STRING macro=rss_schema
					// property: name=type, type=STRING macro=rss_schema
					"type": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=type, type=STRING macro=rss_schema
				},
			},
			// key name holder for attribute: name=type, type=STRING macro=rss_schema
			// property: name=sgi_apply_static_tag, type=BOOLEAN macro=rss_schema
			"sgi_apply_static_tag": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=sgi_apply_static_tag, type=BOOLEAN macro=rss_schema
			// property: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=rss_schema
			"site_wan_interface_ids": rsschema.ListAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
			// key name holder for attribute: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=rss_schema
			// property: name=static_arp_configs, type=ARRAY_REFERENCE macro=rss_schema
			"static_arp_configs": rsschema.ListNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// property: name=ipv4_address, type=STRING macro=rss_schema
						"ipv4_address": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=ipv4_address, type=STRING macro=rss_schema
						// property: name=mac_address, type=STRING macro=rss_schema
						"mac_address": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=mac_address, type=STRING macro=rss_schema
					},
				},
			},
			// key name holder for attribute: name=mac_address, type=STRING macro=rss_schema
			// property: name=sub_interface, type=REFERENCE macro=rss_schema
			"sub_interface": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=vlan_id, type=INTEGER macro=rss_schema
					"vlan_id": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=vlan_id, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=vlan_id, type=INTEGER macro=rss_schema
			// property: name=switch_port_config, type=REFERENCE macro=rss_schema
			"switch_port_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=access_vlan_id, type=INTEGER macro=rss_schema
					"access_vlan_id": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=access_vlan_id, type=INTEGER macro=rss_schema
					// property: name=bpdu_guard_enabled, type=BOOLEAN macro=rss_schema
					"bpdu_guard_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=bpdu_guard_enabled, type=BOOLEAN macro=rss_schema
					// property: name=forward_fast_enabled, type=BOOLEAN macro=rss_schema
					"forward_fast_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=forward_fast_enabled, type=BOOLEAN macro=rss_schema
					// property: name=native_vlan_id, type=INTEGER macro=rss_schema
					"native_vlan_id": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=native_vlan_id, type=INTEGER macro=rss_schema
					// property: name=root_guard_enabled, type=BOOLEAN macro=rss_schema
					"root_guard_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=root_guard_enabled, type=BOOLEAN macro=rss_schema
					// property: name=storm_control_config, type=REFERENCE macro=rss_schema
					"storm_control_config": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=broadcast_threshold, type=INTEGER macro=rss_schema
							"broadcast_threshold": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=broadcast_threshold, type=INTEGER macro=rss_schema
							// property: name=multicast_threshold, type=INTEGER macro=rss_schema
							"multicast_threshold": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=multicast_threshold, type=INTEGER macro=rss_schema
							// property: name=unicast_threshold, type=INTEGER macro=rss_schema
							"unicast_threshold": rsschema.Int64Attribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=unicast_threshold, type=INTEGER macro=rss_schema
						},
					},
					// key name holder for attribute: name=unicast_threshold, type=INTEGER macro=rss_schema
					// property: name=stp_port_cost, type=INTEGER macro=rss_schema
					"stp_port_cost": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_port_cost, type=INTEGER macro=rss_schema
					// property: name=stp_port_enabled, type=BOOLEAN macro=rss_schema
					"stp_port_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_port_enabled, type=BOOLEAN macro=rss_schema
					// property: name=stp_port_priority, type=INTEGER macro=rss_schema
					"stp_port_priority": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stp_port_priority, type=INTEGER macro=rss_schema
					// property: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=rss_schema
					"trunk_vlans": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=vlan_mode, type=STRING macro=rss_schema
					"vlan_mode": rsschema.StringAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=vlan_mode, type=STRING macro=rss_schema
					// property: name=voice_vlan_id, type=INTEGER macro=rss_schema
					"voice_vlan_id": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=voice_vlan_id, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=voice_vlan_id, type=INTEGER macro=rss_schema
			// property: name=tags, type=SET_PRIMITIVE macro=rss_schema
			"tags": rsschema.SetAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
			// key name holder for attribute: name=tags, type=SET_PRIMITIVE macro=rss_schema
			// property: name=type, type=STRING macro=rss_schema
			"type": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=type, type=STRING macro=rss_schema
			// property: name=used_for, type=STRING macro=rss_schema
			"used_for": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=used_for, type=STRING macro=rss_schema
			// property: name=vlan_config, type=REFERENCE macro=rss_schema
			"vlan_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=mstp_instance, type=INTEGER macro=rss_schema
					"mstp_instance": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=mstp_instance, type=INTEGER macro=rss_schema
					// property: name=vlan_id, type=INTEGER macro=rss_schema
					"vlan_id": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=vlan_id, type=INTEGER macro=rss_schema
					// property: name=voice_enabled, type=BOOLEAN macro=rss_schema
					"voice_enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=voice_enabled, type=BOOLEAN macro=rss_schema
				},
			},
			// key name holder for attribute: name=voice_enabled, type=BOOLEAN macro=rss_schema
			// property: name=vrf_context_id, type=STRING macro=rss_schema
			"vrf_context_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=vrf_context_id, type=STRING macro=rss_schema
		},
	}
}

// Configure prepares the struct.
func (r *elementInterfaceResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.client = req.ProviderData.(*sdwan.Client)
}

// in some apis the status code is not consistent and hence we may have to act upon
// specific error codes instead
func (r *elementInterfaceResource) GetHttpStatusCode(request *sdwan_client.SdwanClientRequestResponse) int {
	if request.ResponseErrorCode == nil {
		return request.ResponseStatusCode
	}
	switch *request.ResponseErrorCode {
	case "OBJECT_NOT_FOUND":
		return 404
	default:
		return request.ResponseStatusCode
	}
}

func (r *elementInterfaceResource) doPost(ctx context.Context, plan *rsModelInterfaceScreenV4N20, state *rsModelInterfaceScreenV4N20, resp *resource.CreateResponse) bool {
	tflog.Info(ctx, "executing http post for prismasdwan_element_interface")
	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "prismasdwan_element_interface",
		"terraform_provider_function": "Create",
	})

	// Prepare input for the API endpoint.
	create_request := &sdwan_client.SdwanClientRequestResponse{}
	create_request.ResourceType = "prismasdwan_element_interface"
	create_request.Method = "POST"
	create_request.Path = "/sdwan/v4.20/api/sites/{site_id}/elements/{element_id}/interfaces"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, plan.TfParameters)
	create_request.PathParameters = &params

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// prepare request from state
	var body = &sdwan_schema.InterfaceScreenV4N20{}

	// copy from plan to body
	// copy_from_plan: body=body prefix=rsModel plan=plan properties=50
	tflog.Debug(ctx, "copy_from_plan body=body prefix=rsModel plan=plan")
	// property: name=_etag, type=INTEGER macro=copy_from_plan
	body.Etag = Int64ValueOrNil(plan.Etag)
	// property: name=_schema, type=INTEGER macro=copy_from_plan
	body.Schema = Int64ValueOrNil(plan.Schema)
	// property: name=admin_up, type=BOOLEAN macro=copy_from_plan
	body.AdminUp = BoolValueOrNil(plan.AdminUp)
	// property: name=attached_lan_networks, type=ARRAY_REFERENCE macro=copy_from_plan
	if plan.AttachedLanNetworks == nil {
		body.AttachedLanNetworks = nil
	} else if len(plan.AttachedLanNetworks) == 0 {
		body.AttachedLanNetworks = []sdwan_schema.LanNetworkVlanMapping{}
	} else {
		body.AttachedLanNetworks = make([]sdwan_schema.LanNetworkVlanMapping, 0, len(plan.AttachedLanNetworks))
		for varLoopAttachedLanNetworksIndex, varLoopAttachedLanNetworks := range plan.AttachedLanNetworks {
			// add a new item
			body.AttachedLanNetworks = append(body.AttachedLanNetworks, sdwan_schema.LanNetworkVlanMapping{})
			// copy_from_plan: body=body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel plan=varLoopAttachedLanNetworks properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel plan=varLoopAttachedLanNetworks")
			// property: name=lan_network_id, type=STRING macro=copy_from_plan
			body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].LanNetworkId = StringValueOrNil(varLoopAttachedLanNetworks.LanNetworkId)
			// property: name=vlan_id, type=INTEGER macro=copy_from_plan
			body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].VlanId = Int64ValueOrNil(varLoopAttachedLanNetworks.VlanId)
		}
	}
	// property: name=authentication_config, type=REFERENCE macro=copy_from_plan
	if plan.AuthenticationConfig != nil {
		body.AuthenticationConfig = &sdwan_schema.AuthenticationInterfaceConfig{}
		// copy_from_plan: body=body.AuthenticationConfig prefix=rsModel plan=plan.AuthenticationConfig properties=3
		tflog.Debug(ctx, "copy_from_plan body=body.AuthenticationConfig prefix=rsModel plan=plan.AuthenticationConfig")
		// property: name=fallback_retry_count, type=INTEGER macro=copy_from_plan
		body.AuthenticationConfig.FallbackRetryCount = Int64ValueOrNil(plan.AuthenticationConfig.FallbackRetryCount)
		// property: name=mode, type=STRING macro=copy_from_plan
		body.AuthenticationConfig.Mode = StringValueOrNil(plan.AuthenticationConfig.Mode)
		// property: name=reauthentication_timeout, type=INTEGER macro=copy_from_plan
		body.AuthenticationConfig.ReauthenticationTimeout = Int64ValueOrNil(plan.AuthenticationConfig.ReauthenticationTimeout)
	}
	// property: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=copy_from_plan
	body.BoundInterfaces = ListStringValueOrNil(ctx, plan.BoundInterfaces)
	// property: name=bypass_pair, type=REFERENCE macro=copy_from_plan
	if plan.BypassPair != nil {
		body.BypassPair = &sdwan_schema.BypassPairV2{}
		// copy_from_plan: body=body.BypassPair prefix=rsModel plan=plan.BypassPair properties=4
		tflog.Debug(ctx, "copy_from_plan body=body.BypassPair prefix=rsModel plan=plan.BypassPair")
		// property: name=lan, type=STRING macro=copy_from_plan
		body.BypassPair.Lan = StringValueOrNil(plan.BypassPair.Lan)
		// property: name=lan_state_propagation, type=BOOLEAN macro=copy_from_plan
		body.BypassPair.LanStatePropagation = BoolValueOrNil(plan.BypassPair.LanStatePropagation)
		// property: name=use_relay, type=BOOLEAN macro=copy_from_plan
		body.BypassPair.UseRelay = BoolValueOrNil(plan.BypassPair.UseRelay)
		// property: name=wan, type=STRING macro=copy_from_plan
		body.BypassPair.Wan = StringValueOrNil(plan.BypassPair.Wan)
	}
	// property: name=cellular_config, type=REFERENCE macro=copy_from_plan
	if plan.CellularConfig != nil {
		body.CellularConfig = &sdwan_schema.CellularInterfaceConfig{}
		// copy_from_plan: body=body.CellularConfig prefix=rsModel plan=plan.CellularConfig properties=5
		tflog.Debug(ctx, "copy_from_plan body=body.CellularConfig prefix=rsModel plan=plan.CellularConfig")
		// property: name=apn_config, type=REFERENCE macro=copy_from_plan
		if plan.CellularConfig.ApnConfig != nil {
			body.CellularConfig.ApnConfig = &sdwan_schema.APNConfig{}
			// copy_from_plan: body=body.CellularConfig.ApnConfig prefix=rsModel plan=plan.CellularConfig.ApnConfig properties=6
			tflog.Debug(ctx, "copy_from_plan body=body.CellularConfig.ApnConfig prefix=rsModel plan=plan.CellularConfig.ApnConfig")
			// property: name=apn, type=STRING macro=copy_from_plan
			body.CellularConfig.ApnConfig.Apn = StringValueOrNil(plan.CellularConfig.ApnConfig.Apn)
			// property: name=authentication, type=STRING macro=copy_from_plan
			body.CellularConfig.ApnConfig.Authentication = StringValueOrNil(plan.CellularConfig.ApnConfig.Authentication)
			// property: name=clear_password, type=BOOLEAN macro=copy_from_plan
			body.CellularConfig.ApnConfig.ClearPassword = BoolValueOrNil(plan.CellularConfig.ApnConfig.ClearPassword)
			// property: name=password, type=STRING macro=copy_from_plan
			body.CellularConfig.ApnConfig.Password = StringValueOrNil(plan.CellularConfig.ApnConfig.Password)
			// property: name=password_encrypted, type=STRING macro=copy_from_plan
			body.CellularConfig.ApnConfig.PasswordEncrypted = StringValueOrNil(plan.CellularConfig.ApnConfig.PasswordEncrypted)
			// property: name=user_name, type=STRING macro=copy_from_plan
			body.CellularConfig.ApnConfig.UserName = StringValueOrNil(plan.CellularConfig.ApnConfig.UserName)
		}
		// property: name=apnprofile_id, type=STRING macro=copy_from_plan
		body.CellularConfig.ApnprofileId = StringValueOrNil(plan.CellularConfig.ApnprofileId)
		// property: name=auto_apn, type=BOOLEAN macro=copy_from_plan
		body.CellularConfig.AutoApn = BoolValueOrNil(plan.CellularConfig.AutoApn)
		// property: name=parent_module_id, type=STRING macro=copy_from_plan
		body.CellularConfig.ParentModuleId = StringValueOrNil(plan.CellularConfig.ParentModuleId)
		// property: name=parent_sim_slot_number, type=INTEGER macro=copy_from_plan
		body.CellularConfig.ParentSimSlotNumber = Int64ValueOrNil(plan.CellularConfig.ParentSimSlotNumber)
	}
	// property: name=description, type=STRING macro=copy_from_plan
	body.Description = StringValueOrNil(plan.Description)
	// property: name=devicemgmt_policysetstack_id, type=STRING macro=copy_from_plan
	body.DevicemgmtPolicysetstackId = StringValueOrNil(plan.DevicemgmtPolicysetstackId)
	// property: name=dhcp_relay, type=REFERENCE macro=copy_from_plan
	if plan.DhcpRelay != nil {
		body.DhcpRelay = &sdwan_schema.DHCPRelay{}
		// copy_from_plan: body=body.DhcpRelay prefix=rsModel plan=plan.DhcpRelay properties=4
		tflog.Debug(ctx, "copy_from_plan body=body.DhcpRelay prefix=rsModel plan=plan.DhcpRelay")
		// property: name=enabled, type=BOOLEAN macro=copy_from_plan
		body.DhcpRelay.Enabled = BoolValueOrNil(plan.DhcpRelay.Enabled)
		// property: name=option_82, type=REFERENCE macro=copy_from_plan
		if plan.DhcpRelay.Option82 != nil {
			body.DhcpRelay.Option82 = &sdwan_schema.DHCPRelayOption82{}
			// copy_from_plan: body=body.DhcpRelay.Option82 prefix=rsModel plan=plan.DhcpRelay.Option82 properties=4
			tflog.Debug(ctx, "copy_from_plan body=body.DhcpRelay.Option82 prefix=rsModel plan=plan.DhcpRelay.Option82")
			// property: name=circuit_id, type=STRING macro=copy_from_plan
			body.DhcpRelay.Option82.CircuitId = StringValueOrNil(plan.DhcpRelay.Option82.CircuitId)
			// property: name=enabled, type=BOOLEAN macro=copy_from_plan
			body.DhcpRelay.Option82.Enabled = BoolValueOrNil(plan.DhcpRelay.Option82.Enabled)
			// property: name=reforwarding_policy, type=STRING macro=copy_from_plan
			body.DhcpRelay.Option82.ReforwardingPolicy = StringValueOrNil(plan.DhcpRelay.Option82.ReforwardingPolicy)
			// property: name=remote_id, type=STRING macro=copy_from_plan
			body.DhcpRelay.Option82.RemoteId = StringValueOrNil(plan.DhcpRelay.Option82.RemoteId)
		}
		// property: name=server_ips, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.DhcpRelay.ServerIps = ListStringValueOrNil(ctx, plan.DhcpRelay.ServerIps)
		// property: name=source_interface, type=STRING macro=copy_from_plan
		body.DhcpRelay.SourceInterface = StringValueOrNil(plan.DhcpRelay.SourceInterface)
	}
	// property: name=directed_broadcast, type=BOOLEAN macro=copy_from_plan
	body.DirectedBroadcast = BoolValueOrNil(plan.DirectedBroadcast)
	// property: name=ethernet_port, type=REFERENCE macro=copy_from_plan
	if plan.EthernetPort != nil {
		body.EthernetPort = &sdwan_schema.EthernetPort{}
		// copy_from_plan: body=body.EthernetPort prefix=rsModel plan=plan.EthernetPort properties=4
		tflog.Debug(ctx, "copy_from_plan body=body.EthernetPort prefix=rsModel plan=plan.EthernetPort")
		// property: name=full_duplex, type=BOOLEAN macro=copy_from_plan
		body.EthernetPort.FullDuplex = BoolValueOrNil(plan.EthernetPort.FullDuplex)
		// property: name=port_id, type=REFERENCE macro=copy_from_plan
		if plan.EthernetPort.PortId != nil {
			body.EthernetPort.PortId = &sdwan_schema.Ethernet{}
			// copy_from_plan: body=body.EthernetPort.PortId prefix=rsModel plan=plan.EthernetPort.PortId properties=16
			tflog.Debug(ctx, "copy_from_plan body=body.EthernetPort.PortId prefix=rsModel plan=plan.EthernetPort.PortId")
			// property: name=_etag, type=INTEGER macro=copy_from_plan
			body.EthernetPort.PortId.Etag = Int64ValueOrNil(plan.EthernetPort.PortId.Etag)
			// property: name=_schema, type=INTEGER macro=copy_from_plan
			body.EthernetPort.PortId.Schema = Int64ValueOrNil(plan.EthernetPort.PortId.Schema)
			// property: name=connector, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.Connector = StringValueOrNil(plan.EthernetPort.PortId.Connector)
			// property: name=device, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.Device = StringValueOrNil(plan.EthernetPort.PortId.Device)
			// property: name=disabled, type=BOOLEAN macro=copy_from_plan
			body.EthernetPort.PortId.Disabled = BoolValueOrNil(plan.EthernetPort.PortId.Disabled)
			// property: name=disabled_reason, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.DisabledReason = StringValueOrNil(plan.EthernetPort.PortId.DisabledReason)
			// property: name=element_id, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.ElementId = StringValueOrNil(plan.EthernetPort.PortId.ElementId)
			// property: name=id, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.Id = StringValueOrNil(plan.EthernetPort.PortId.Id)
			// property: name=inactive, type=BOOLEAN macro=copy_from_plan
			body.EthernetPort.PortId.Inactive = BoolValueOrNil(plan.EthernetPort.PortId.Inactive)
			// property: name=inactive_reason, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.InactiveReason = StringValueOrNil(plan.EthernetPort.PortId.InactiveReason)
			// property: name=max_mtu, type=INTEGER macro=copy_from_plan
			body.EthernetPort.PortId.MaxMtu = Int64ValueOrNil(plan.EthernetPort.PortId.MaxMtu)
			// property: name=max_speed, type=INTEGER macro=copy_from_plan
			body.EthernetPort.PortId.MaxSpeed = Int64ValueOrNil(plan.EthernetPort.PortId.MaxSpeed)
			// property: name=name, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.Name = StringValueOrNil(plan.EthernetPort.PortId.Name)
			// property: name=original_mac_address, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.OriginalMacAddress = StringValueOrNil(plan.EthernetPort.PortId.OriginalMacAddress)
			// property: name=region, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.Region = StringValueOrNil(plan.EthernetPort.PortId.Region)
			// property: name=site_id, type=STRING macro=copy_from_plan
			body.EthernetPort.PortId.SiteId = StringValueOrNil(plan.EthernetPort.PortId.SiteId)
		}
		// property: name=port_name, type=STRING macro=copy_from_plan
		body.EthernetPort.PortName = StringValueOrNil(plan.EthernetPort.PortName)
		// property: name=speed, type=INTEGER macro=copy_from_plan
		body.EthernetPort.Speed = Int64ValueOrNil(plan.EthernetPort.Speed)
	}
	// property: name=id, type=STRING macro=copy_from_plan
	body.Id = StringValueOrNil(plan.Id)
	// property: name=interface_profile_id, type=STRING macro=copy_from_plan
	body.InterfaceProfileId = StringValueOrNil(plan.InterfaceProfileId)
	// property: name=ipfixcollectorcontext_id, type=STRING macro=copy_from_plan
	body.IpfixcollectorcontextId = StringValueOrNil(plan.IpfixcollectorcontextId)
	// property: name=ipfixfiltercontext_id, type=STRING macro=copy_from_plan
	body.IpfixfiltercontextId = StringValueOrNil(plan.IpfixfiltercontextId)
	// property: name=ipv4_config, type=REFERENCE macro=copy_from_plan
	if plan.Ipv4Config != nil {
		body.Ipv4Config = &sdwan_schema.Ipv4Config{}
		// copy_from_plan: body=body.Ipv4Config prefix=rsModel plan=plan.Ipv4Config properties=6
		tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config prefix=rsModel plan=plan.Ipv4Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv4Config.DhcpConfig != nil {
			body.Ipv4Config.DhcpConfig = &sdwan_schema.Ipv4Dhcp{}
			// copy_from_plan: body=body.Ipv4Config.DhcpConfig prefix=rsModel plan=plan.Ipv4Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config.DhcpConfig prefix=rsModel plan=plan.Ipv4Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_from_plan
			body.Ipv4Config.DhcpConfig.ClientId = StringValueOrNil(plan.Ipv4Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_from_plan
			body.Ipv4Config.DhcpConfig.Hostname = StringValueOrNil(plan.Ipv4Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v4_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv4Config.DnsV4Config != nil {
			body.Ipv4Config.DnsV4Config = &sdwan_schema.DNS{}
			// copy_from_plan: body=body.Ipv4Config.DnsV4Config prefix=rsModel plan=plan.Ipv4Config.DnsV4Config properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config.DnsV4Config prefix=rsModel plan=plan.Ipv4Config.DnsV4Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.Ipv4Config.DnsV4Config.NameServers = ListStringValueOrNil(ctx, plan.Ipv4Config.DnsV4Config.NameServers)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.Ipv4Config.DnsV4Config.Search = ListStringValueOrNil(ctx, plan.Ipv4Config.DnsV4Config.Search)
		}
		// property: name=pppoe_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv4Config.PppoeConfig != nil {
			body.Ipv4Config.PppoeConfig = &sdwan_schema.Ipv4Pppoe{}
			// copy_from_plan: body=body.Ipv4Config.PppoeConfig prefix=rsModel plan=plan.Ipv4Config.PppoeConfig properties=3
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config.PppoeConfig prefix=rsModel plan=plan.Ipv4Config.PppoeConfig")
			// property: name=chap_passwd, type=STRING macro=copy_from_plan
			body.Ipv4Config.PppoeConfig.ChapPasswd = StringValueOrNil(plan.Ipv4Config.PppoeConfig.ChapPasswd)
			// property: name=chap_user, type=STRING macro=copy_from_plan
			body.Ipv4Config.PppoeConfig.ChapUser = StringValueOrNil(plan.Ipv4Config.PppoeConfig.ChapUser)
			// property: name=set_route, type=BOOLEAN macro=copy_from_plan
			body.Ipv4Config.PppoeConfig.SetRoute = BoolValueOrNil(plan.Ipv4Config.PppoeConfig.SetRoute)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.Ipv4Config.Routes == nil {
			body.Ipv4Config.Routes = nil
		} else if len(plan.Ipv4Config.Routes) == 0 {
			body.Ipv4Config.Routes = []sdwan_schema.Route{}
		} else {
			body.Ipv4Config.Routes = make([]sdwan_schema.Route, 0, len(plan.Ipv4Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range plan.Ipv4Config.Routes {
				// add a new item
				body.Ipv4Config.Routes = append(body.Ipv4Config.Routes, sdwan_schema.Route{})
				// copy_from_plan: body=body.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_from_plan
				body.Ipv4Config.Routes[varLoopRoutesIndex].Destination = StringValueOrNil(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_from_plan
				body.Ipv4Config.Routes[varLoopRoutesIndex].Via = StringValueOrNil(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv4Config.StaticConfig != nil {
			body.Ipv4Config.StaticConfig = &sdwan_schema.Ipv4Static{}
			// copy_from_plan: body=body.Ipv4Config.StaticConfig prefix=rsModel plan=plan.Ipv4Config.StaticConfig properties=1
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config.StaticConfig prefix=rsModel plan=plan.Ipv4Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_from_plan
			body.Ipv4Config.StaticConfig.Address = StringValueOrNil(plan.Ipv4Config.StaticConfig.Address)
		}
		// property: name=type, type=STRING macro=copy_from_plan
		body.Ipv4Config.Type = StringValueOrNil(plan.Ipv4Config.Type)
	}
	// property: name=ipv6_config, type=REFERENCE macro=copy_from_plan
	if plan.Ipv6Config != nil {
		body.Ipv6Config = &sdwan_schema.Ipv6ConfigV1{}
		// copy_from_plan: body=body.Ipv6Config prefix=rsModel plan=plan.Ipv6Config properties=5
		tflog.Debug(ctx, "copy_from_plan body=body.Ipv6Config prefix=rsModel plan=plan.Ipv6Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv6Config.DhcpConfig != nil {
			body.Ipv6Config.DhcpConfig = &sdwan_schema.Ipv6Dhcp{}
			// copy_from_plan: body=body.Ipv6Config.DhcpConfig prefix=rsModel plan=plan.Ipv6Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv6Config.DhcpConfig prefix=rsModel plan=plan.Ipv6Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_from_plan
			body.Ipv6Config.DhcpConfig.ClientId = StringValueOrNil(plan.Ipv6Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_from_plan
			body.Ipv6Config.DhcpConfig.Hostname = StringValueOrNil(plan.Ipv6Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v6_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv6Config.DnsV6Config != nil {
			body.Ipv6Config.DnsV6Config = &sdwan_schema.DNS{}
			// copy_from_plan: body=body.Ipv6Config.DnsV6Config prefix=rsModel plan=plan.Ipv6Config.DnsV6Config properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv6Config.DnsV6Config prefix=rsModel plan=plan.Ipv6Config.DnsV6Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.Ipv6Config.DnsV6Config.NameServers = ListStringValueOrNil(ctx, plan.Ipv6Config.DnsV6Config.NameServers)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.Ipv6Config.DnsV6Config.Search = ListStringValueOrNil(ctx, plan.Ipv6Config.DnsV6Config.Search)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.Ipv6Config.Routes == nil {
			body.Ipv6Config.Routes = nil
		} else if len(plan.Ipv6Config.Routes) == 0 {
			body.Ipv6Config.Routes = []sdwan_schema.Route{}
		} else {
			body.Ipv6Config.Routes = make([]sdwan_schema.Route, 0, len(plan.Ipv6Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range plan.Ipv6Config.Routes {
				// add a new item
				body.Ipv6Config.Routes = append(body.Ipv6Config.Routes, sdwan_schema.Route{})
				// copy_from_plan: body=body.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_from_plan body=body.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_from_plan
				body.Ipv6Config.Routes[varLoopRoutesIndex].Destination = StringValueOrNil(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_from_plan
				body.Ipv6Config.Routes[varLoopRoutesIndex].Via = StringValueOrNil(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_from_plan
		if plan.Ipv6Config.StaticConfig != nil {
			body.Ipv6Config.StaticConfig = &sdwan_schema.Ipv6StaticV1{}
			// copy_from_plan: body=body.Ipv6Config.StaticConfig prefix=rsModel plan=plan.Ipv6Config.StaticConfig properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.Ipv6Config.StaticConfig prefix=rsModel plan=plan.Ipv6Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_from_plan
			body.Ipv6Config.StaticConfig.Address = StringValueOrNil(plan.Ipv6Config.StaticConfig.Address)
			// property: name=enable_prefix_distribution, type=BOOLEAN macro=copy_from_plan
			body.Ipv6Config.StaticConfig.EnablePrefixDistribution = BoolValueOrNil(plan.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}
		// property: name=type, type=STRING macro=copy_from_plan
		body.Ipv6Config.Type = StringValueOrNil(plan.Ipv6Config.Type)
	}
	// property: name=lldp_enabled, type=BOOLEAN macro=copy_from_plan
	body.LldpEnabled = BoolValueOrNil(plan.LldpEnabled)
	// property: name=mac_address, type=STRING macro=copy_from_plan
	body.MacAddress = StringValueOrNil(plan.MacAddress)
	// property: name=mtu, type=INTEGER macro=copy_from_plan
	body.Mtu = Int64ValueOrNil(plan.Mtu)
	// property: name=multicast_config, type=REFERENCE macro=copy_from_plan
	if plan.MulticastConfig != nil {
		body.MulticastConfig = &sdwan_schema.MulticastInterfaceConfig{}
		// copy_from_plan: body=body.MulticastConfig prefix=rsModel plan=plan.MulticastConfig properties=4
		tflog.Debug(ctx, "copy_from_plan body=body.MulticastConfig prefix=rsModel plan=plan.MulticastConfig")
		// property: name=dr_priority, type=INTEGER macro=copy_from_plan
		body.MulticastConfig.DrPriority = Int64ValueOrNil(plan.MulticastConfig.DrPriority)
		// property: name=igmp_static_joins, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.MulticastConfig.IgmpStaticJoins == nil {
			body.MulticastConfig.IgmpStaticJoins = nil
		} else if len(plan.MulticastConfig.IgmpStaticJoins) == 0 {
			body.MulticastConfig.IgmpStaticJoins = []sdwan_schema.MulticastIgmpStaticJoin{}
		} else {
			body.MulticastConfig.IgmpStaticJoins = make([]sdwan_schema.MulticastIgmpStaticJoin, 0, len(plan.MulticastConfig.IgmpStaticJoins))
			for varLoopIgmpStaticJoinsIndex, varLoopIgmpStaticJoins := range plan.MulticastConfig.IgmpStaticJoins {
				// add a new item
				body.MulticastConfig.IgmpStaticJoins = append(body.MulticastConfig.IgmpStaticJoins, sdwan_schema.MulticastIgmpStaticJoin{})
				// copy_from_plan: body=body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel plan=varLoopIgmpStaticJoins properties=2
				tflog.Debug(ctx, "copy_from_plan body=body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel plan=varLoopIgmpStaticJoins")
				// property: name=igmp_static_grp_ipv4, type=STRING macro=copy_from_plan
				body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticGrpIpv4 = StringValueOrNil(varLoopIgmpStaticJoins.IgmpStaticGrpIpv4)
				// property: name=igmp_static_src_ipv4, type=STRING macro=copy_from_plan
				body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticSrcIpv4 = StringValueOrNil(varLoopIgmpStaticJoins.IgmpStaticSrcIpv4)
			}
		}
		// property: name=igmp_version, type=STRING macro=copy_from_plan
		body.MulticastConfig.IgmpVersion = StringValueOrNil(plan.MulticastConfig.IgmpVersion)
		// property: name=multicast_enabled, type=BOOLEAN macro=copy_from_plan
		body.MulticastConfig.MulticastEnabled = BoolValueOrNil(plan.MulticastConfig.MulticastEnabled)
	}
	// property: name=name, type=STRING macro=copy_from_plan
	body.Name = StringValueOrNil(plan.Name)
	// property: name=nat_address, type=STRING macro=copy_from_plan
	body.NatAddress = StringValueOrNil(plan.NatAddress)
	// property: name=nat_address_v6, type=STRING macro=copy_from_plan
	body.NatAddressV6 = StringValueOrNil(plan.NatAddressV6)
	// property: name=nat_pools, type=ARRAY_REFERENCE macro=copy_from_plan
	if plan.NatPools == nil {
		body.NatPools = nil
	} else if len(plan.NatPools) == 0 {
		body.NatPools = []sdwan_schema.NatPool{}
	} else {
		body.NatPools = make([]sdwan_schema.NatPool, 0, len(plan.NatPools))
		for varLoopNatPoolsIndex, varLoopNatPools := range plan.NatPools {
			// add a new item
			body.NatPools = append(body.NatPools, sdwan_schema.NatPool{})
			// copy_from_plan: body=body.NatPools[varLoopNatPoolsIndex] prefix=rsModel plan=varLoopNatPools properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.NatPools[varLoopNatPoolsIndex] prefix=rsModel plan=varLoopNatPools")
			// property: name=ipv4_ranges, type=ARRAY_REFERENCE macro=copy_from_plan
			if varLoopNatPools.Ipv4Ranges == nil {
				body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = nil
			} else if len(varLoopNatPools.Ipv4Ranges) == 0 {
				body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = []sdwan_schema.IPv4Range{}
			} else {
				body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = make([]sdwan_schema.IPv4Range, 0, len(varLoopNatPools.Ipv4Ranges))
				for varLoopIpv4RangesIndex, varLoopIpv4Ranges := range varLoopNatPools.Ipv4Ranges {
					// add a new item
					body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = append(body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges, sdwan_schema.IPv4Range{})
					// copy_from_plan: body=body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel plan=varLoopIpv4Ranges properties=2
					tflog.Debug(ctx, "copy_from_plan body=body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel plan=varLoopIpv4Ranges")
					// property: name=end, type=STRING macro=copy_from_plan
					body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].End = StringValueOrNil(varLoopIpv4Ranges.End)
					// property: name=start, type=STRING macro=copy_from_plan
					body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].Start = StringValueOrNil(varLoopIpv4Ranges.Start)
				}
			}
			// property: name=nat_pool_id, type=STRING macro=copy_from_plan
			body.NatPools[varLoopNatPoolsIndex].NatPoolId = StringValueOrNil(varLoopNatPools.NatPoolId)
		}
	}
	// property: name=nat_port, type=INTEGER macro=copy_from_plan
	body.NatPort = Int64ValueOrNil(plan.NatPort)
	// property: name=nat_port_v6, type=INTEGER macro=copy_from_plan
	body.NatPortV6 = Int64ValueOrNil(plan.NatPortV6)
	// property: name=nat_zone_id, type=STRING macro=copy_from_plan
	body.NatZoneId = StringValueOrNil(plan.NatZoneId)
	// property: name=network_context_id, type=STRING macro=copy_from_plan
	body.NetworkContextId = StringValueOrNil(plan.NetworkContextId)
	// property: name=parent, type=STRING macro=copy_from_plan
	body.Parent = StringValueOrNil(plan.Parent)
	// property: name=peer_bypasspair_wan_port_type, type=STRING macro=copy_from_plan
	body.PeerBypasspairWanPortType = StringValueOrNil(plan.PeerBypasspairWanPortType)
	// property: name=poe_enabled, type=BOOLEAN macro=copy_from_plan
	body.PoeEnabled = BoolValueOrNil(plan.PoeEnabled)
	// property: name=port_channel_config, type=REFERENCE macro=copy_from_plan
	if plan.PortChannelConfig != nil {
		body.PortChannelConfig = &sdwan_schema.PortChannelConfig{}
		// copy_from_plan: body=body.PortChannelConfig prefix=rsModel plan=plan.PortChannelConfig properties=2
		tflog.Debug(ctx, "copy_from_plan body=body.PortChannelConfig prefix=rsModel plan=plan.PortChannelConfig")
		// property: name=lacp_enabled, type=BOOLEAN macro=copy_from_plan
		body.PortChannelConfig.LacpEnabled = BoolValueOrNil(plan.PortChannelConfig.LacpEnabled)
		// property: name=transmission_mode, type=STRING macro=copy_from_plan
		body.PortChannelConfig.TransmissionMode = StringValueOrNil(plan.PortChannelConfig.TransmissionMode)
	}
	// property: name=power_usage_threshold, type=INTEGER macro=copy_from_plan
	body.PowerUsageThreshold = Int64ValueOrNil(plan.PowerUsageThreshold)
	// property: name=pppoe_config, type=REFERENCE macro=copy_from_plan
	if plan.PppoeConfig != nil {
		body.PppoeConfig = &sdwan_schema.PppoEInterfaceConfig{}
		// copy_from_plan: body=body.PppoeConfig prefix=rsModel plan=plan.PppoeConfig properties=6
		tflog.Debug(ctx, "copy_from_plan body=body.PppoeConfig prefix=rsModel plan=plan.PppoeConfig")
		// property: name=host_uniq, type=STRING macro=copy_from_plan
		body.PppoeConfig.HostUniq = StringValueOrNil(plan.PppoeConfig.HostUniq)
		// property: name=ip_address_type, type=STRING macro=copy_from_plan
		body.PppoeConfig.IpAddressType = StringValueOrNil(plan.PppoeConfig.IpAddressType)
		// property: name=password, type=STRING macro=copy_from_plan
		body.PppoeConfig.Password = StringValueOrNil(plan.PppoeConfig.Password)
		// property: name=reconnection_delay, type=INTEGER macro=copy_from_plan
		body.PppoeConfig.ReconnectionDelay = Int64ValueOrNil(plan.PppoeConfig.ReconnectionDelay)
		// property: name=service_name, type=STRING macro=copy_from_plan
		body.PppoeConfig.ServiceName = StringValueOrNil(plan.PppoeConfig.ServiceName)
		// property: name=username, type=STRING macro=copy_from_plan
		body.PppoeConfig.Username = StringValueOrNil(plan.PppoeConfig.Username)
	}
	// property: name=scope, type=STRING macro=copy_from_plan
	body.Scope = StringValueOrNil(plan.Scope)
	// property: name=secondary_ip_configs, type=ARRAY_REFERENCE macro=copy_from_plan
	if plan.SecondaryIpConfigs == nil {
		body.SecondaryIpConfigs = nil
	} else if len(plan.SecondaryIpConfigs) == 0 {
		body.SecondaryIpConfigs = []sdwan_schema.SecondaryIPConfig{}
	} else {
		body.SecondaryIpConfigs = make([]sdwan_schema.SecondaryIPConfig, 0, len(plan.SecondaryIpConfigs))
		for varLoopSecondaryIpConfigsIndex, varLoopSecondaryIpConfigs := range plan.SecondaryIpConfigs {
			// add a new item
			body.SecondaryIpConfigs = append(body.SecondaryIpConfigs, sdwan_schema.SecondaryIPConfig{})
			// copy_from_plan: body=body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel plan=varLoopSecondaryIpConfigs properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel plan=varLoopSecondaryIpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_from_plan
			body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Ipv4Address = StringValueOrNil(varLoopSecondaryIpConfigs.Ipv4Address)
			// property: name=scope, type=STRING macro=copy_from_plan
			body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Scope = StringValueOrNil(varLoopSecondaryIpConfigs.Scope)
		}
	}
	// property: name=service_link_config, type=REFERENCE macro=copy_from_plan
	if plan.ServiceLinkConfig != nil {
		body.ServiceLinkConfig = &sdwan_schema.ServiceLinkV4{}
		// copy_from_plan: body=body.ServiceLinkConfig prefix=rsModel plan=plan.ServiceLinkConfig properties=8
		tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig prefix=rsModel plan=plan.ServiceLinkConfig")
		// property: name=gre_config, type=REFERENCE macro=copy_from_plan
		if plan.ServiceLinkConfig.GreConfig != nil {
			body.ServiceLinkConfig.GreConfig = &sdwan_schema.GREConfig{}
			// copy_from_plan: body=body.ServiceLinkConfig.GreConfig prefix=rsModel plan=plan.ServiceLinkConfig.GreConfig properties=4
			tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig.GreConfig prefix=rsModel plan=plan.ServiceLinkConfig.GreConfig")
			// property: name=csum, type=BOOLEAN macro=copy_from_plan
			body.ServiceLinkConfig.GreConfig.Csum = BoolValueOrNil(plan.ServiceLinkConfig.GreConfig.Csum)
			// property: name=keepalive_enable, type=BOOLEAN macro=copy_from_plan
			body.ServiceLinkConfig.GreConfig.KeepaliveEnable = BoolValueOrNil(plan.ServiceLinkConfig.GreConfig.KeepaliveEnable)
			// property: name=keepalive_fail_count, type=INTEGER macro=copy_from_plan
			body.ServiceLinkConfig.GreConfig.KeepaliveFailCount = Int64ValueOrNil(plan.ServiceLinkConfig.GreConfig.KeepaliveFailCount)
			// property: name=keepalive_interval, type=INTEGER macro=copy_from_plan
			body.ServiceLinkConfig.GreConfig.KeepaliveInterval = Int64ValueOrNil(plan.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}
		// property: name=ipsec_config, type=REFERENCE macro=copy_from_plan
		if plan.ServiceLinkConfig.IpsecConfig != nil {
			body.ServiceLinkConfig.IpsecConfig = &sdwan_schema.IPSECConfigV1{}
			// copy_from_plan: body=body.ServiceLinkConfig.IpsecConfig prefix=rsModel plan=plan.ServiceLinkConfig.IpsecConfig properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig.IpsecConfig prefix=rsModel plan=plan.ServiceLinkConfig.IpsecConfig")
			// property: name=authentication, type=REFERENCE macro=copy_from_plan
			if plan.ServiceLinkConfig.IpsecConfig.Authentication != nil {
				body.ServiceLinkConfig.IpsecConfig.Authentication = &sdwan_schema.IPSECAuthenticationV1{}
				// copy_from_plan: body=body.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel plan=plan.ServiceLinkConfig.IpsecConfig.Authentication properties=22
				tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel plan=plan.ServiceLinkConfig.IpsecConfig.Authentication")
				// property: name=certificate, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)
				// property: name=certificate_profile_id, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)
				// property: name=comment, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.Comment = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Comment)
				// property: name=ikev1_params, type=REFERENCE macro=copy_from_plan
				if plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &sdwan_schema.IKEV1Params{}
					// copy_from_plan: body=body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel plan=plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params properties=5
					tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel plan=plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params")
					// property: name=xauth_id, type=STRING macro=copy_from_plan
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)
					// property: name=xauth_secret, type=STRING macro=copy_from_plan
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)
					// property: name=xauth_secret_encrypted, type=STRING macro=copy_from_plan
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)
					// property: name=xauth_secret_hash, type=STRING macro=copy_from_plan
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)
					// property: name=xauth_type, type=STRING macro=copy_from_plan
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}
				// property: name=local_ca_certificate, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)
				// property: name=local_id, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)
				// property: name=local_id_custom, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)
				// property: name=local_pa_certificate_id, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)
				// property: name=pa_master_key_id, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)
				// property: name=passphrase, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)
				// property: name=passphrase_encrypted, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)
				// property: name=peer_id_check, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)
				// property: name=permit_peer_id_mismatch, type=BOOLEAN macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = BoolValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)
				// property: name=private_key, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)
				// property: name=private_key_encrypted, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)
				// property: name=remote_ca_certificate, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)
				// property: name=remote_id, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)
				// property: name=secret, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.Secret = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Secret)
				// property: name=secret_encrypted, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)
				// property: name=secret_hash, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)
				// property: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = BoolValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)
				// property: name=type, type=STRING macro=copy_from_plan
				body.ServiceLinkConfig.IpsecConfig.Authentication.Type = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Type)
			}
			// property: name=ipsec_profile_id, type=STRING macro=copy_from_plan
			body.ServiceLinkConfig.IpsecConfig.IpsecProfileId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}
		// property: name=last_parent, type=STRING macro=copy_from_plan
		body.ServiceLinkConfig.LastParent = StringValueOrNil(plan.ServiceLinkConfig.LastParent)
		// property: name=parent, type=STRING macro=copy_from_plan
		body.ServiceLinkConfig.Parent = StringValueOrNil(plan.ServiceLinkConfig.Parent)
		// property: name=passive_mode, type=REFERENCE macro=copy_from_plan
		if plan.ServiceLinkConfig.PassiveMode != nil {
			body.ServiceLinkConfig.PassiveMode = &sdwan_schema.PassiveMode{}
			// copy_from_plan: body=body.ServiceLinkConfig.PassiveMode prefix=rsModel plan=plan.ServiceLinkConfig.PassiveMode properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig.PassiveMode prefix=rsModel plan=plan.ServiceLinkConfig.PassiveMode")
			// property: name=enable, type=BOOLEAN macro=copy_from_plan
			body.ServiceLinkConfig.PassiveMode.Enable = BoolValueOrNil(plan.ServiceLinkConfig.PassiveMode.Enable)
			// property: name=peer_ip_dynamic, type=BOOLEAN macro=copy_from_plan
			body.ServiceLinkConfig.PassiveMode.PeerIpDynamic = BoolValueOrNil(plan.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}
		// property: name=peer, type=REFERENCE macro=copy_from_plan
		if plan.ServiceLinkConfig.Peer != nil {
			body.ServiceLinkConfig.Peer = &sdwan_schema.PeerInfo{}
			// copy_from_plan: body=body.ServiceLinkConfig.Peer prefix=rsModel plan=plan.ServiceLinkConfig.Peer properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.ServiceLinkConfig.Peer prefix=rsModel plan=plan.ServiceLinkConfig.Peer")
			// property: name=hostname, type=STRING macro=copy_from_plan
			body.ServiceLinkConfig.Peer.Hostname = StringValueOrNil(plan.ServiceLinkConfig.Peer.Hostname)
			// property: name=ip_addresses, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.ServiceLinkConfig.Peer.IpAddresses = ListStringValueOrNil(ctx, plan.ServiceLinkConfig.Peer.IpAddresses)
		}
		// property: name=service_endpoint_id, type=STRING macro=copy_from_plan
		body.ServiceLinkConfig.ServiceEndpointId = StringValueOrNil(plan.ServiceLinkConfig.ServiceEndpointId)
		// property: name=type, type=STRING macro=copy_from_plan
		body.ServiceLinkConfig.Type = StringValueOrNil(plan.ServiceLinkConfig.Type)
	}
	// property: name=sgi_apply_static_tag, type=BOOLEAN macro=copy_from_plan
	body.SgiApplyStaticTag = BoolValueOrNil(plan.SgiApplyStaticTag)
	// property: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=copy_from_plan
	body.SiteWanInterfaceIds = ListStringValueOrNil(ctx, plan.SiteWanInterfaceIds)
	// property: name=static_arp_configs, type=ARRAY_REFERENCE macro=copy_from_plan
	if plan.StaticArpConfigs == nil {
		body.StaticArpConfigs = nil
	} else if len(plan.StaticArpConfigs) == 0 {
		body.StaticArpConfigs = []sdwan_schema.StaticARPConfig{}
	} else {
		body.StaticArpConfigs = make([]sdwan_schema.StaticARPConfig, 0, len(plan.StaticArpConfigs))
		for varLoopStaticArpConfigsIndex, varLoopStaticArpConfigs := range plan.StaticArpConfigs {
			// add a new item
			body.StaticArpConfigs = append(body.StaticArpConfigs, sdwan_schema.StaticARPConfig{})
			// copy_from_plan: body=body.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel plan=varLoopStaticArpConfigs properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel plan=varLoopStaticArpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_from_plan
			body.StaticArpConfigs[varLoopStaticArpConfigsIndex].Ipv4Address = StringValueOrNil(varLoopStaticArpConfigs.Ipv4Address)
			// property: name=mac_address, type=STRING macro=copy_from_plan
			body.StaticArpConfigs[varLoopStaticArpConfigsIndex].MacAddress = StringValueOrNil(varLoopStaticArpConfigs.MacAddress)
		}
	}
	// property: name=sub_interface, type=REFERENCE macro=copy_from_plan
	if plan.SubInterface != nil {
		body.SubInterface = &sdwan_schema.SubInterface{}
		// copy_from_plan: body=body.SubInterface prefix=rsModel plan=plan.SubInterface properties=1
		tflog.Debug(ctx, "copy_from_plan body=body.SubInterface prefix=rsModel plan=plan.SubInterface")
		// property: name=vlan_id, type=INTEGER macro=copy_from_plan
		body.SubInterface.VlanId = Int64ValueOrNil(plan.SubInterface.VlanId)
	}
	// property: name=switch_port_config, type=REFERENCE macro=copy_from_plan
	if plan.SwitchPortConfig != nil {
		body.SwitchPortConfig = &sdwan_schema.SwitchPortConfig{}
		// copy_from_plan: body=body.SwitchPortConfig prefix=rsModel plan=plan.SwitchPortConfig properties=12
		tflog.Debug(ctx, "copy_from_plan body=body.SwitchPortConfig prefix=rsModel plan=plan.SwitchPortConfig")
		// property: name=access_vlan_id, type=INTEGER macro=copy_from_plan
		body.SwitchPortConfig.AccessVlanId = Int64ValueOrNil(plan.SwitchPortConfig.AccessVlanId)
		// property: name=bpdu_guard_enabled, type=BOOLEAN macro=copy_from_plan
		body.SwitchPortConfig.BpduGuardEnabled = BoolValueOrNil(plan.SwitchPortConfig.BpduGuardEnabled)
		// property: name=forward_fast_enabled, type=BOOLEAN macro=copy_from_plan
		body.SwitchPortConfig.ForwardFastEnabled = BoolValueOrNil(plan.SwitchPortConfig.ForwardFastEnabled)
		// property: name=native_vlan_id, type=INTEGER macro=copy_from_plan
		body.SwitchPortConfig.NativeVlanId = Int64ValueOrNil(plan.SwitchPortConfig.NativeVlanId)
		// property: name=root_guard_enabled, type=BOOLEAN macro=copy_from_plan
		body.SwitchPortConfig.RootGuardEnabled = BoolValueOrNil(plan.SwitchPortConfig.RootGuardEnabled)
		// property: name=storm_control_config, type=REFERENCE macro=copy_from_plan
		if plan.SwitchPortConfig.StormControlConfig != nil {
			body.SwitchPortConfig.StormControlConfig = &sdwan_schema.StormControlConfig{}
			// copy_from_plan: body=body.SwitchPortConfig.StormControlConfig prefix=rsModel plan=plan.SwitchPortConfig.StormControlConfig properties=3
			tflog.Debug(ctx, "copy_from_plan body=body.SwitchPortConfig.StormControlConfig prefix=rsModel plan=plan.SwitchPortConfig.StormControlConfig")
			// property: name=broadcast_threshold, type=INTEGER macro=copy_from_plan
			body.SwitchPortConfig.StormControlConfig.BroadcastThreshold = Int64ValueOrNil(plan.SwitchPortConfig.StormControlConfig.BroadcastThreshold)
			// property: name=multicast_threshold, type=INTEGER macro=copy_from_plan
			body.SwitchPortConfig.StormControlConfig.MulticastThreshold = Int64ValueOrNil(plan.SwitchPortConfig.StormControlConfig.MulticastThreshold)
			// property: name=unicast_threshold, type=INTEGER macro=copy_from_plan
			body.SwitchPortConfig.StormControlConfig.UnicastThreshold = Int64ValueOrNil(plan.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}
		// property: name=stp_port_cost, type=INTEGER macro=copy_from_plan
		body.SwitchPortConfig.StpPortCost = Int64ValueOrNil(plan.SwitchPortConfig.StpPortCost)
		// property: name=stp_port_enabled, type=BOOLEAN macro=copy_from_plan
		body.SwitchPortConfig.StpPortEnabled = BoolValueOrNil(plan.SwitchPortConfig.StpPortEnabled)
		// property: name=stp_port_priority, type=INTEGER macro=copy_from_plan
		body.SwitchPortConfig.StpPortPriority = Int64ValueOrNil(plan.SwitchPortConfig.StpPortPriority)
		// property: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.SwitchPortConfig.TrunkVlans = ListStringValueOrNil(ctx, plan.SwitchPortConfig.TrunkVlans)
		// property: name=vlan_mode, type=STRING macro=copy_from_plan
		body.SwitchPortConfig.VlanMode = StringValueOrNil(plan.SwitchPortConfig.VlanMode)
		// property: name=voice_vlan_id, type=INTEGER macro=copy_from_plan
		body.SwitchPortConfig.VoiceVlanId = Int64ValueOrNil(plan.SwitchPortConfig.VoiceVlanId)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_from_plan
	body.Tags = SetStringValueOrNil(ctx, plan.Tags)
	// property: name=type, type=STRING macro=copy_from_plan
	body.Type = StringValueOrNil(plan.Type)
	// property: name=used_for, type=STRING macro=copy_from_plan
	body.UsedFor = StringValueOrNil(plan.UsedFor)
	// property: name=vlan_config, type=REFERENCE macro=copy_from_plan
	if plan.VlanConfig != nil {
		body.VlanConfig = &sdwan_schema.VlanConfig{}
		// copy_from_plan: body=body.VlanConfig prefix=rsModel plan=plan.VlanConfig properties=3
		tflog.Debug(ctx, "copy_from_plan body=body.VlanConfig prefix=rsModel plan=plan.VlanConfig")
		// property: name=mstp_instance, type=INTEGER macro=copy_from_plan
		body.VlanConfig.MstpInstance = Int64ValueOrNil(plan.VlanConfig.MstpInstance)
		// property: name=vlan_id, type=INTEGER macro=copy_from_plan
		body.VlanConfig.VlanId = Int64ValueOrNil(plan.VlanConfig.VlanId)
		// property: name=voice_enabled, type=BOOLEAN macro=copy_from_plan
		body.VlanConfig.VoiceEnabled = BoolValueOrNil(plan.VlanConfig.VoiceEnabled)
	}
	// property: name=vrf_context_id, type=STRING macro=copy_from_plan
	body.VrfContextId = StringValueOrNil(plan.VrfContextId)

	// convert body to map
	json_body, err := json.Marshal(body)
	if err != nil {
		resp.Diagnostics.AddError("error marshaling struct InterfaceScreenV4N20 to JSON:", err.Error())
		return false
	}

	// process http json path
	request_body_string := string(json_body)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete request_body_string::id")
	request_body_string, _ = sjson.Delete(request_body_string, "id")
	tflog.Debug(ctx, "http json override: delete request_body_string::_etag")
	request_body_string, _ = sjson.Delete(request_body_string, "_etag")
	tflog.Debug(ctx, "http json override: set request_body_string::_schema")
	request_body_string, _ = sjson.Set(request_body_string, "_schema", 0)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete request_body_string::ethernet_port.port_id")
	request_body_string, _ = sjson.Delete(request_body_string, "ethernet_port.port_id")
	tflog.Debug(ctx, "http json override: delete request_body_string::ethernet_port.port_name")
	request_body_string, _ = sjson.Delete(request_body_string, "ethernet_port.port_name")
	tflog.Debug(ctx, "http json override: set request_body_string::_schema")
	request_body_string, _ = sjson.Set(request_body_string, "_schema", 4)
	// copy pointer
	create_request.RequestBody = &request_body_string

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, create_request)
	if create_request.ResponseErr != nil {
		tflog.Info(ctx, "create request failed for prismasdwan_element_interface", map[string]any{
			"terraform_provider_function": "Create",
			"resource_name":               "prismasdwan_element_interface",
			"path":                        create_request.FinalPath,
		})
		tflog.Debug(ctx, "create request failed for prismasdwan_element_interface", map[string]any{
			"terraform_provider_function": "Create",
			"resource_name":               "prismasdwan_element_interface",
			"path":                        create_request.FinalPath,
			"request":                     create_request.ToString(),
		})
		resp.Diagnostics.AddError("error creating prismasdwan_element_interface", (*create_request.ResponseErr).Error())
		return false
	}

	// process http json path
	response_body_string := string(*create_request.ResponseBytes)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete response_body_string::_created_on_utc")
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	tflog.Debug(ctx, "http json override: set response_body_string::_schema")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// start copying attributes
	var ans sdwan_schema.InterfaceScreenV4N20
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to InterfaceScreenV4N20 in create", json_err.Error())
		return false
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return false
	}
	// ID Format: Id:Param1=Value1:Param2=Value2:...:ParamN=ValueN
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
		for p, v := range *create_request.PathParameters {
			idBuilder.WriteString(IdSeparator)
			idBuilder.WriteString(p)
			idBuilder.WriteString("=")
			idBuilder.WriteString(*v)
		}
	}
	// set the tf id for the resource created
	state.Tfid = types.StringValue(idBuilder.String())
	state.TfParameters = plan.TfParameters
	tflog.Info(ctx, "created prismasdwan_element_interface with ID", map[string]any{"tfid": state.Tfid.ValueString()})

	// Store the answer to state. schema=InterfaceScreenV4N20
	// copy_to_state: state=state prefix=rsModel ans=ans properties=50
	tflog.Debug(ctx, "copy_to_state state=state prefix=rsModel ans=ans")
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=admin_up, type=BOOLEAN macro=copy_to_state
	state.AdminUp = types.BoolPointerValue(ans.AdminUp)
	// property: name=attached_lan_networks, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.AttachedLanNetworks == nil {
		state.AttachedLanNetworks = nil
	} else if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = []rsModelLanNetworkVlanMapping{}
	} else {
		state.AttachedLanNetworks = make([]rsModelLanNetworkVlanMapping, 0, len(ans.AttachedLanNetworks))
		for varLoopAttachedLanNetworksIndex, varLoopAttachedLanNetworks := range ans.AttachedLanNetworks {
			// add a new item
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, rsModelLanNetworkVlanMapping{})
			// copy_to_state: state=state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel ans=varLoopAttachedLanNetworks properties=2
			tflog.Debug(ctx, "copy_to_state state=state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel ans=varLoopAttachedLanNetworks")
			// property: name=lan_network_id, type=STRING macro=copy_to_state
			state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].LanNetworkId = types.StringPointerValue(varLoopAttachedLanNetworks.LanNetworkId)
			// property: name=vlan_id, type=INTEGER macro=copy_to_state
			state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].VlanId = types.Int64PointerValue(varLoopAttachedLanNetworks.VlanId)
		}
	}
	// property: name=authentication_config, type=REFERENCE macro=copy_to_state
	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &rsModelAuthenticationInterfaceConfig{}
		// copy_to_state: state=state.AuthenticationConfig prefix=rsModel ans=ans.AuthenticationConfig properties=3
		tflog.Debug(ctx, "copy_to_state state=state.AuthenticationConfig prefix=rsModel ans=ans.AuthenticationConfig")
		// property: name=fallback_retry_count, type=INTEGER macro=copy_to_state
		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)
		// property: name=mode, type=STRING macro=copy_to_state
		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)
		// property: name=reauthentication_timeout, type=INTEGER macro=copy_to_state
		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}
	// property: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=copy_to_state
	varBoundInterfaces, errBoundInterfaces := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = varBoundInterfaces
	resp.Diagnostics.Append(errBoundInterfaces.Errors()...)
	// property: name=bypass_pair, type=REFERENCE macro=copy_to_state
	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &rsModelBypassPairV2{}
		// copy_to_state: state=state.BypassPair prefix=rsModel ans=ans.BypassPair properties=4
		tflog.Debug(ctx, "copy_to_state state=state.BypassPair prefix=rsModel ans=ans.BypassPair")
		// property: name=lan, type=STRING macro=copy_to_state
		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)
		// property: name=lan_state_propagation, type=BOOLEAN macro=copy_to_state
		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)
		// property: name=use_relay, type=BOOLEAN macro=copy_to_state
		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)
		// property: name=wan, type=STRING macro=copy_to_state
		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}
	// property: name=cellular_config, type=REFERENCE macro=copy_to_state
	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &rsModelCellularInterfaceConfig{}
		// copy_to_state: state=state.CellularConfig prefix=rsModel ans=ans.CellularConfig properties=5
		tflog.Debug(ctx, "copy_to_state state=state.CellularConfig prefix=rsModel ans=ans.CellularConfig")
		// property: name=apn_config, type=REFERENCE macro=copy_to_state
		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &rsModelAPNConfig{}
			// copy_to_state: state=state.CellularConfig.ApnConfig prefix=rsModel ans=ans.CellularConfig.ApnConfig properties=6
			tflog.Debug(ctx, "copy_to_state state=state.CellularConfig.ApnConfig prefix=rsModel ans=ans.CellularConfig.ApnConfig")
			// property: name=apn, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)
			// property: name=authentication, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Authentication = types.StringPointerValue(ans.CellularConfig.ApnConfig.Authentication)
			// property: name=clear_password, type=BOOLEAN macro=copy_to_state
			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)
			// property: name=password, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Password = types.StringPointerValue(plan.CellularConfig.ApnConfig.Password.ValueStringPointer())
			// this property is sensitive and will be stored in the state's internal key name
			state.CellularConfig.ApnConfig.PasswordInternalKeyName = types.StringValue(GenerateRandomString(16))
			// store value if needed
			if !state.CellularConfig.ApnConfig.Password.IsNull() {
				encryptedPassword, _ := Encrypt([]byte(state.CellularConfig.ApnConfig.Password.String()))
				resp.Private.SetKey(ctx, state.CellularConfig.ApnConfig.PasswordInternalKeyName.String(), []byte(encryptedPassword))
			}
			// property: name=password_encrypted, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(plan.CellularConfig.ApnConfig.PasswordEncrypted.ValueStringPointer())
			// this property is sensitive and will be stored in the state's internal key name
			state.CellularConfig.ApnConfig.PasswordEncryptedInternalKeyName = types.StringValue(GenerateRandomString(16))
			// store value if needed
			if !state.CellularConfig.ApnConfig.PasswordEncrypted.IsNull() {
				encryptedPasswordEncrypted, _ := Encrypt([]byte(state.CellularConfig.ApnConfig.PasswordEncrypted.String()))
				resp.Private.SetKey(ctx, state.CellularConfig.ApnConfig.PasswordEncryptedInternalKeyName.String(), []byte(encryptedPasswordEncrypted))
			}
			// property: name=user_name, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}
		// property: name=apnprofile_id, type=STRING macro=copy_to_state
		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)
		// property: name=auto_apn, type=BOOLEAN macro=copy_to_state
		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)
		// property: name=parent_module_id, type=STRING macro=copy_to_state
		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)
		// property: name=parent_sim_slot_number, type=INTEGER macro=copy_to_state
		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=devicemgmt_policysetstack_id, type=STRING macro=copy_to_state
	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)
	// property: name=dhcp_relay, type=REFERENCE macro=copy_to_state
	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &rsModelDHCPRelay{}
		// copy_to_state: state=state.DhcpRelay prefix=rsModel ans=ans.DhcpRelay properties=4
		tflog.Debug(ctx, "copy_to_state state=state.DhcpRelay prefix=rsModel ans=ans.DhcpRelay")
		// property: name=enabled, type=BOOLEAN macro=copy_to_state
		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)
		// property: name=option_82, type=REFERENCE macro=copy_to_state
		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &rsModelDHCPRelayOption82{}
			// copy_to_state: state=state.DhcpRelay.Option82 prefix=rsModel ans=ans.DhcpRelay.Option82 properties=4
			tflog.Debug(ctx, "copy_to_state state=state.DhcpRelay.Option82 prefix=rsModel ans=ans.DhcpRelay.Option82")
			// property: name=circuit_id, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)
			// property: name=enabled, type=BOOLEAN macro=copy_to_state
			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)
			// property: name=reforwarding_policy, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringPointerValue(ans.DhcpRelay.Option82.ReforwardingPolicy)
			// property: name=remote_id, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}
		// property: name=server_ips, type=ARRAY_PRIMITIVE macro=copy_to_state
		varServerIps, errServerIps := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = varServerIps
		resp.Diagnostics.Append(errServerIps.Errors()...)
		// property: name=source_interface, type=STRING macro=copy_to_state
		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}
	// property: name=directed_broadcast, type=BOOLEAN macro=copy_to_state
	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)
	// property: name=ethernet_port, type=REFERENCE macro=copy_to_state
	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &rsModelEthernetPort{}
		// copy_to_state: state=state.EthernetPort prefix=rsModel ans=ans.EthernetPort properties=4
		tflog.Debug(ctx, "copy_to_state state=state.EthernetPort prefix=rsModel ans=ans.EthernetPort")
		// property: name=full_duplex, type=BOOLEAN macro=copy_to_state
		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)
		// property: name=port_id, type=REFERENCE macro=copy_to_state
		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &rsModelEthernet{}
			// copy_to_state: state=state.EthernetPort.PortId prefix=rsModel ans=ans.EthernetPort.PortId properties=16
			tflog.Debug(ctx, "copy_to_state state=state.EthernetPort.PortId prefix=rsModel ans=ans.EthernetPort.PortId")
			// property: name=_etag, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.Etag = types.Int64PointerValue(ans.EthernetPort.PortId.Etag)
			// property: name=_schema, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.Schema = types.Int64PointerValue(ans.EthernetPort.PortId.Schema)
			// property: name=connector, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)
			// property: name=device, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)
			// property: name=disabled, type=BOOLEAN macro=copy_to_state
			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)
			// property: name=disabled_reason, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)
			// property: name=element_id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)
			// property: name=id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)
			// property: name=inactive, type=BOOLEAN macro=copy_to_state
			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)
			// property: name=inactive_reason, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)
			// property: name=max_mtu, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)
			// property: name=max_speed, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)
			// property: name=name, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)
			// property: name=original_mac_address, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)
			// property: name=region, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)
			// property: name=site_id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.SiteId = types.StringPointerValue(ans.EthernetPort.PortId.SiteId)
		}
		// property: name=port_name, type=STRING macro=copy_to_state
		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)
		// property: name=speed, type=INTEGER macro=copy_to_state
		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=interface_profile_id, type=STRING macro=copy_to_state
	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)
	// property: name=ipfixcollectorcontext_id, type=STRING macro=copy_to_state
	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)
	// property: name=ipfixfiltercontext_id, type=STRING macro=copy_to_state
	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)
	// property: name=ipv4_config, type=REFERENCE macro=copy_to_state
	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &rsModelIpv4Config{}
		// copy_to_state: state=state.Ipv4Config prefix=rsModel ans=ans.Ipv4Config properties=6
		tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config prefix=rsModel ans=ans.Ipv4Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &rsModelIpv4Dhcp{}
			// copy_to_state: state=state.Ipv4Config.DhcpConfig prefix=rsModel ans=ans.Ipv4Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.DhcpConfig prefix=rsModel ans=ans.Ipv4Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_to_state
			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_to_state
			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v4_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &rsModelDNS{}
			// copy_to_state: state=state.Ipv4Config.DnsV4Config prefix=rsModel ans=ans.Ipv4Config.DnsV4Config properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.DnsV4Config prefix=rsModel ans=ans.Ipv4Config.DnsV4Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
			varNameServers, errNameServers := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = varNameServers
			resp.Diagnostics.Append(errNameServers.Errors()...)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_to_state
			varSearch, errSearch := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = varSearch
			resp.Diagnostics.Append(errSearch.Errors()...)
		}
		// property: name=pppoe_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &rsModelIpv4Pppoe{}
			// copy_to_state: state=state.Ipv4Config.PppoeConfig prefix=rsModel ans=ans.Ipv4Config.PppoeConfig properties=3
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.PppoeConfig prefix=rsModel ans=ans.Ipv4Config.PppoeConfig")
			// property: name=chap_passwd, type=STRING macro=copy_to_state
			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)
			// property: name=chap_user, type=STRING macro=copy_to_state
			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)
			// property: name=set_route, type=BOOLEAN macro=copy_to_state
			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.Ipv4Config.Routes == nil {
			state.Ipv4Config.Routes = nil
		} else if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = []rsModelRoute{}
		} else {
			state.Ipv4Config.Routes = make([]rsModelRoute, 0, len(ans.Ipv4Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range ans.Ipv4Config.Routes {
				// add a new item
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, rsModelRoute{})
				// copy_to_state: state=state.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_to_state
				state.Ipv4Config.Routes[varLoopRoutesIndex].Destination = types.StringPointerValue(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_to_state
				state.Ipv4Config.Routes[varLoopRoutesIndex].Via = types.StringPointerValue(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &rsModelIpv4Static{}
			// copy_to_state: state=state.Ipv4Config.StaticConfig prefix=rsModel ans=ans.Ipv4Config.StaticConfig properties=1
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.StaticConfig prefix=rsModel ans=ans.Ipv4Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_to_state
			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}
		// property: name=type, type=STRING macro=copy_to_state
		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}
	// property: name=ipv6_config, type=REFERENCE macro=copy_to_state
	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &rsModelIpv6ConfigV1{}
		// copy_to_state: state=state.Ipv6Config prefix=rsModel ans=ans.Ipv6Config properties=5
		tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config prefix=rsModel ans=ans.Ipv6Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &rsModelIpv6Dhcp{}
			// copy_to_state: state=state.Ipv6Config.DhcpConfig prefix=rsModel ans=ans.Ipv6Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.DhcpConfig prefix=rsModel ans=ans.Ipv6Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_to_state
			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_to_state
			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v6_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &rsModelDNS{}
			// copy_to_state: state=state.Ipv6Config.DnsV6Config prefix=rsModel ans=ans.Ipv6Config.DnsV6Config properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.DnsV6Config prefix=rsModel ans=ans.Ipv6Config.DnsV6Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
			varNameServers, errNameServers := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = varNameServers
			resp.Diagnostics.Append(errNameServers.Errors()...)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_to_state
			varSearch, errSearch := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = varSearch
			resp.Diagnostics.Append(errSearch.Errors()...)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.Ipv6Config.Routes == nil {
			state.Ipv6Config.Routes = nil
		} else if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = []rsModelRoute{}
		} else {
			state.Ipv6Config.Routes = make([]rsModelRoute, 0, len(ans.Ipv6Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range ans.Ipv6Config.Routes {
				// add a new item
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, rsModelRoute{})
				// copy_to_state: state=state.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_to_state
				state.Ipv6Config.Routes[varLoopRoutesIndex].Destination = types.StringPointerValue(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_to_state
				state.Ipv6Config.Routes[varLoopRoutesIndex].Via = types.StringPointerValue(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &rsModelIpv6StaticV1{}
			// copy_to_state: state=state.Ipv6Config.StaticConfig prefix=rsModel ans=ans.Ipv6Config.StaticConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.StaticConfig prefix=rsModel ans=ans.Ipv6Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_to_state
			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)
			// property: name=enable_prefix_distribution, type=BOOLEAN macro=copy_to_state
			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}
		// property: name=type, type=STRING macro=copy_to_state
		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}
	// property: name=lldp_enabled, type=BOOLEAN macro=copy_to_state
	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)
	// property: name=mac_address, type=STRING macro=copy_to_state
	state.MacAddress = types.StringPointerValue(ans.MacAddress)
	// property: name=mtu, type=INTEGER macro=copy_to_state
	state.Mtu = types.Int64PointerValue(ans.Mtu)
	// property: name=multicast_config, type=REFERENCE macro=copy_to_state
	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &rsModelMulticastInterfaceConfig{}
		// copy_to_state: state=state.MulticastConfig prefix=rsModel ans=ans.MulticastConfig properties=4
		tflog.Debug(ctx, "copy_to_state state=state.MulticastConfig prefix=rsModel ans=ans.MulticastConfig")
		// property: name=dr_priority, type=INTEGER macro=copy_to_state
		state.MulticastConfig.DrPriority = types.Int64PointerValue(ans.MulticastConfig.DrPriority)
		// property: name=igmp_static_joins, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.MulticastConfig.IgmpStaticJoins == nil {
			state.MulticastConfig.IgmpStaticJoins = nil
		} else if len(ans.MulticastConfig.IgmpStaticJoins) == 0 {
			state.MulticastConfig.IgmpStaticJoins = []rsModelMulticastIgmpStaticJoin{}
		} else {
			state.MulticastConfig.IgmpStaticJoins = make([]rsModelMulticastIgmpStaticJoin, 0, len(ans.MulticastConfig.IgmpStaticJoins))
			for varLoopIgmpStaticJoinsIndex, varLoopIgmpStaticJoins := range ans.MulticastConfig.IgmpStaticJoins {
				// add a new item
				state.MulticastConfig.IgmpStaticJoins = append(state.MulticastConfig.IgmpStaticJoins, rsModelMulticastIgmpStaticJoin{})
				// copy_to_state: state=state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel ans=varLoopIgmpStaticJoins properties=2
				tflog.Debug(ctx, "copy_to_state state=state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel ans=varLoopIgmpStaticJoins")
				// property: name=igmp_static_grp_ipv4, type=STRING macro=copy_to_state
				state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticGrpIpv4 = types.StringPointerValue(varLoopIgmpStaticJoins.IgmpStaticGrpIpv4)
				// property: name=igmp_static_src_ipv4, type=STRING macro=copy_to_state
				state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticSrcIpv4 = types.StringPointerValue(varLoopIgmpStaticJoins.IgmpStaticSrcIpv4)
			}
		}
		// property: name=igmp_version, type=STRING macro=copy_to_state
		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)
		// property: name=multicast_enabled, type=BOOLEAN macro=copy_to_state
		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=nat_address, type=STRING macro=copy_to_state
	state.NatAddress = types.StringPointerValue(ans.NatAddress)
	// property: name=nat_address_v6, type=STRING macro=copy_to_state
	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)
	// property: name=nat_pools, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.NatPools == nil {
		state.NatPools = nil
	} else if len(ans.NatPools) == 0 {
		state.NatPools = []rsModelNatPool{}
	} else {
		state.NatPools = make([]rsModelNatPool, 0, len(ans.NatPools))
		for varLoopNatPoolsIndex, varLoopNatPools := range ans.NatPools {
			// add a new item
			state.NatPools = append(state.NatPools, rsModelNatPool{})
			// copy_to_state: state=state.NatPools[varLoopNatPoolsIndex] prefix=rsModel ans=varLoopNatPools properties=2
			tflog.Debug(ctx, "copy_to_state state=state.NatPools[varLoopNatPoolsIndex] prefix=rsModel ans=varLoopNatPools")
			// property: name=ipv4_ranges, type=ARRAY_REFERENCE macro=copy_to_state
			if varLoopNatPools.Ipv4Ranges == nil {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = nil
			} else if len(varLoopNatPools.Ipv4Ranges) == 0 {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = []rsModelIPv4Range{}
			} else {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = make([]rsModelIPv4Range, 0, len(varLoopNatPools.Ipv4Ranges))
				for varLoopIpv4RangesIndex, varLoopIpv4Ranges := range varLoopNatPools.Ipv4Ranges {
					// add a new item
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = append(state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges, rsModelIPv4Range{})
					// copy_to_state: state=state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel ans=varLoopIpv4Ranges properties=2
					tflog.Debug(ctx, "copy_to_state state=state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel ans=varLoopIpv4Ranges")
					// property: name=end, type=STRING macro=copy_to_state
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].End = types.StringPointerValue(varLoopIpv4Ranges.End)
					// property: name=start, type=STRING macro=copy_to_state
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].Start = types.StringPointerValue(varLoopIpv4Ranges.Start)
				}
			}
			// property: name=nat_pool_id, type=STRING macro=copy_to_state
			state.NatPools[varLoopNatPoolsIndex].NatPoolId = types.StringPointerValue(varLoopNatPools.NatPoolId)
		}
	}
	// property: name=nat_port, type=INTEGER macro=copy_to_state
	state.NatPort = types.Int64PointerValue(ans.NatPort)
	// property: name=nat_port_v6, type=INTEGER macro=copy_to_state
	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)
	// property: name=nat_zone_id, type=STRING macro=copy_to_state
	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)
	// property: name=network_context_id, type=STRING macro=copy_to_state
	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)
	// property: name=parent, type=STRING macro=copy_to_state
	state.Parent = types.StringPointerValue(ans.Parent)
	// property: name=peer_bypasspair_wan_port_type, type=STRING macro=copy_to_state
	state.PeerBypasspairWanPortType = types.StringPointerValue(ans.PeerBypasspairWanPortType)
	// property: name=poe_enabled, type=BOOLEAN macro=copy_to_state
	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)
	// property: name=port_channel_config, type=REFERENCE macro=copy_to_state
	if ans.PortChannelConfig == nil {
		state.PortChannelConfig = nil
	} else {
		state.PortChannelConfig = &rsModelPortChannelConfig{}
		// copy_to_state: state=state.PortChannelConfig prefix=rsModel ans=ans.PortChannelConfig properties=2
		tflog.Debug(ctx, "copy_to_state state=state.PortChannelConfig prefix=rsModel ans=ans.PortChannelConfig")
		// property: name=lacp_enabled, type=BOOLEAN macro=copy_to_state
		state.PortChannelConfig.LacpEnabled = types.BoolPointerValue(ans.PortChannelConfig.LacpEnabled)
		// property: name=transmission_mode, type=STRING macro=copy_to_state
		state.PortChannelConfig.TransmissionMode = types.StringPointerValue(ans.PortChannelConfig.TransmissionMode)
	}
	// property: name=power_usage_threshold, type=INTEGER macro=copy_to_state
	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)
	// property: name=pppoe_config, type=REFERENCE macro=copy_to_state
	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &rsModelPppoEInterfaceConfig{}
		// copy_to_state: state=state.PppoeConfig prefix=rsModel ans=ans.PppoeConfig properties=6
		tflog.Debug(ctx, "copy_to_state state=state.PppoeConfig prefix=rsModel ans=ans.PppoeConfig")
		// property: name=host_uniq, type=STRING macro=copy_to_state
		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)
		// property: name=ip_address_type, type=STRING macro=copy_to_state
		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)
		// property: name=password, type=STRING macro=copy_to_state
		state.PppoeConfig.Password = types.StringPointerValue(plan.PppoeConfig.Password.ValueStringPointer())
		// this property is sensitive and will be stored in the state's internal key name
		state.PppoeConfig.PasswordInternalKeyName = types.StringValue(GenerateRandomString(16))
		// store value if needed
		if !state.PppoeConfig.Password.IsNull() {
			encryptedPassword, _ := Encrypt([]byte(state.PppoeConfig.Password.String()))
			resp.Private.SetKey(ctx, state.PppoeConfig.PasswordInternalKeyName.String(), []byte(encryptedPassword))
		}
		// property: name=reconnection_delay, type=INTEGER macro=copy_to_state
		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)
		// property: name=service_name, type=STRING macro=copy_to_state
		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)
		// property: name=username, type=STRING macro=copy_to_state
		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}
	// property: name=scope, type=STRING macro=copy_to_state
	state.Scope = types.StringPointerValue(ans.Scope)
	// property: name=secondary_ip_configs, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.SecondaryIpConfigs == nil {
		state.SecondaryIpConfigs = nil
	} else if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = []rsModelSecondaryIPConfig{}
	} else {
		state.SecondaryIpConfigs = make([]rsModelSecondaryIPConfig, 0, len(ans.SecondaryIpConfigs))
		for varLoopSecondaryIpConfigsIndex, varLoopSecondaryIpConfigs := range ans.SecondaryIpConfigs {
			// add a new item
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, rsModelSecondaryIPConfig{})
			// copy_to_state: state=state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel ans=varLoopSecondaryIpConfigs properties=2
			tflog.Debug(ctx, "copy_to_state state=state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel ans=varLoopSecondaryIpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Ipv4Address = types.StringPointerValue(varLoopSecondaryIpConfigs.Ipv4Address)
			// property: name=scope, type=STRING macro=copy_to_state
			state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Scope = types.StringPointerValue(varLoopSecondaryIpConfigs.Scope)
		}
	}
	// property: name=service_link_config, type=REFERENCE macro=copy_to_state
	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &rsModelServiceLinkV4{}
		// copy_to_state: state=state.ServiceLinkConfig prefix=rsModel ans=ans.ServiceLinkConfig properties=8
		tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig prefix=rsModel ans=ans.ServiceLinkConfig")
		// property: name=gre_config, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &rsModelGREConfig{}
			// copy_to_state: state=state.ServiceLinkConfig.GreConfig prefix=rsModel ans=ans.ServiceLinkConfig.GreConfig properties=4
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.GreConfig prefix=rsModel ans=ans.ServiceLinkConfig.GreConfig")
			// property: name=csum, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)
			// property: name=keepalive_enable, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)
			// property: name=keepalive_fail_count, type=INTEGER macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)
			// property: name=keepalive_interval, type=INTEGER macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}
		// property: name=ipsec_config, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &rsModelIPSECConfigV1{}
			// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig")
			// property: name=authentication, type=REFERENCE macro=copy_to_state
			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &rsModelIPSECAuthenticationV1{}
				// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication properties=22
				tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication")
				// property: name=certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)
				// property: name=certificate_profile_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)
				// property: name=comment, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)
				// property: name=ikev1_params, type=REFERENCE macro=copy_to_state
				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &rsModelIKEV1Params{}
					// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params properties=5
					tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params")
					// property: name=xauth_id, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)
					// property: name=xauth_secret, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret.ValueStringPointer())
					// this property is sensitive and will be stored in the state's internal key name
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretInternalKeyName = types.StringValue(GenerateRandomString(16))
					// store value if needed
					if !state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret.IsNull() {
						encryptedXauthSecret, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret.String()))
						resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretInternalKeyName.String(), []byte(encryptedXauthSecret))
					}
					// property: name=xauth_secret_encrypted, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted.ValueStringPointer())
					// this property is sensitive and will be stored in the state's internal key name
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncryptedInternalKeyName = types.StringValue(GenerateRandomString(16))
					// store value if needed
					if !state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted.IsNull() {
						encryptedXauthSecretEncrypted, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted.String()))
						resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncryptedInternalKeyName.String(), []byte(encryptedXauthSecretEncrypted))
					}
					// property: name=xauth_secret_hash, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash.ValueStringPointer())
					// this property is sensitive and will be stored in the state's internal key name
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHashInternalKeyName = types.StringValue(GenerateRandomString(16))
					// store value if needed
					if !state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash.IsNull() {
						encryptedXauthSecretHash, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash.String()))
						resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHashInternalKeyName.String(), []byte(encryptedXauthSecretHash))
					}
					// property: name=xauth_type, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}
				// property: name=local_ca_certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)
				// property: name=local_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)
				// property: name=local_id_custom, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)
				// property: name=local_pa_certificate_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)
				// property: name=pa_master_key_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)
				// property: name=passphrase, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)
				// property: name=passphrase_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)
				// property: name=peer_id_check, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)
				// property: name=permit_peer_id_mismatch, type=BOOLEAN macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)
				// property: name=private_key, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)
				// property: name=private_key_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)
				// property: name=remote_ca_certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)
				// property: name=remote_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)
				// property: name=secret, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Secret.ValueStringPointer())
				// this property is sensitive and will be stored in the state's internal key name
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretInternalKeyName = types.StringValue(GenerateRandomString(16))
				// store value if needed
				if !state.ServiceLinkConfig.IpsecConfig.Authentication.Secret.IsNull() {
					encryptedSecret, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Secret.String()))
					resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretInternalKeyName.String(), []byte(encryptedSecret))
				}
				// property: name=secret_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted.ValueStringPointer())
				// this property is sensitive and will be stored in the state's internal key name
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncryptedInternalKeyName = types.StringValue(GenerateRandomString(16))
				// store value if needed
				if !state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted.IsNull() {
					encryptedSecretEncrypted, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted.String()))
					resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncryptedInternalKeyName.String(), []byte(encryptedSecretEncrypted))
				}
				// property: name=secret_hash, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash.ValueStringPointer())
				// this property is sensitive and will be stored in the state's internal key name
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHashInternalKeyName = types.StringValue(GenerateRandomString(16))
				// store value if needed
				if !state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash.IsNull() {
					encryptedSecretHash, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash.String()))
					resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHashInternalKeyName.String(), []byte(encryptedSecretHash))
				}
				// property: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)
				// property: name=type, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)
			}
			// property: name=ipsec_profile_id, type=STRING macro=copy_to_state
			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}
		// property: name=last_parent, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)
		// property: name=parent, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)
		// property: name=passive_mode, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &rsModelPassiveMode{}
			// copy_to_state: state=state.ServiceLinkConfig.PassiveMode prefix=rsModel ans=ans.ServiceLinkConfig.PassiveMode properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.PassiveMode prefix=rsModel ans=ans.ServiceLinkConfig.PassiveMode")
			// property: name=enable, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)
			// property: name=peer_ip_dynamic, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}
		// property: name=peer, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &rsModelPeerInfo{}
			// copy_to_state: state=state.ServiceLinkConfig.Peer prefix=rsModel ans=ans.ServiceLinkConfig.Peer properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.Peer prefix=rsModel ans=ans.ServiceLinkConfig.Peer")
			// property: name=hostname, type=STRING macro=copy_to_state
			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)
			// property: name=ip_addresses, type=ARRAY_PRIMITIVE macro=copy_to_state
			varIpAddresses, errIpAddresses := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = varIpAddresses
			resp.Diagnostics.Append(errIpAddresses.Errors()...)
		}
		// property: name=service_endpoint_id, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)
		// property: name=type, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.Type = types.StringPointerValue(ans.ServiceLinkConfig.Type)
	}
	// property: name=sgi_apply_static_tag, type=BOOLEAN macro=copy_to_state
	state.SgiApplyStaticTag = types.BoolPointerValue(ans.SgiApplyStaticTag)
	// property: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=copy_to_state
	varSiteWanInterfaceIds, errSiteWanInterfaceIds := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = varSiteWanInterfaceIds
	resp.Diagnostics.Append(errSiteWanInterfaceIds.Errors()...)
	// property: name=static_arp_configs, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.StaticArpConfigs == nil {
		state.StaticArpConfigs = nil
	} else if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = []rsModelStaticARPConfig{}
	} else {
		state.StaticArpConfigs = make([]rsModelStaticARPConfig, 0, len(ans.StaticArpConfigs))
		for varLoopStaticArpConfigsIndex, varLoopStaticArpConfigs := range ans.StaticArpConfigs {
			// add a new item
			state.StaticArpConfigs = append(state.StaticArpConfigs, rsModelStaticARPConfig{})
			// copy_to_state: state=state.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel ans=varLoopStaticArpConfigs properties=2
			tflog.Debug(ctx, "copy_to_state state=state.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel ans=varLoopStaticArpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.StaticArpConfigs[varLoopStaticArpConfigsIndex].Ipv4Address = types.StringPointerValue(varLoopStaticArpConfigs.Ipv4Address)
			// property: name=mac_address, type=STRING macro=copy_to_state
			state.StaticArpConfigs[varLoopStaticArpConfigsIndex].MacAddress = types.StringPointerValue(varLoopStaticArpConfigs.MacAddress)
		}
	}
	// property: name=sub_interface, type=REFERENCE macro=copy_to_state
	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &rsModelSubInterface{}
		// copy_to_state: state=state.SubInterface prefix=rsModel ans=ans.SubInterface properties=1
		tflog.Debug(ctx, "copy_to_state state=state.SubInterface prefix=rsModel ans=ans.SubInterface")
		// property: name=vlan_id, type=INTEGER macro=copy_to_state
		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}
	// property: name=switch_port_config, type=REFERENCE macro=copy_to_state
	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &rsModelSwitchPortConfig{}
		// copy_to_state: state=state.SwitchPortConfig prefix=rsModel ans=ans.SwitchPortConfig properties=12
		tflog.Debug(ctx, "copy_to_state state=state.SwitchPortConfig prefix=rsModel ans=ans.SwitchPortConfig")
		// property: name=access_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)
		// property: name=bpdu_guard_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)
		// property: name=forward_fast_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)
		// property: name=native_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)
		// property: name=root_guard_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)
		// property: name=storm_control_config, type=REFERENCE macro=copy_to_state
		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &rsModelStormControlConfig{}
			// copy_to_state: state=state.SwitchPortConfig.StormControlConfig prefix=rsModel ans=ans.SwitchPortConfig.StormControlConfig properties=3
			tflog.Debug(ctx, "copy_to_state state=state.SwitchPortConfig.StormControlConfig prefix=rsModel ans=ans.SwitchPortConfig.StormControlConfig")
			// property: name=broadcast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)
			// property: name=multicast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)
			// property: name=unicast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}
		// property: name=stp_port_cost, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)
		// property: name=stp_port_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)
		// property: name=stp_port_priority, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)
		// property: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=copy_to_state
		varTrunkVlans, errTrunkVlans := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = varTrunkVlans
		resp.Diagnostics.Append(errTrunkVlans.Errors()...)
		// property: name=vlan_mode, type=STRING macro=copy_to_state
		state.SwitchPortConfig.VlanMode = types.StringPointerValue(ans.SwitchPortConfig.VlanMode)
		// property: name=voice_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	// property: name=type, type=STRING macro=copy_to_state
	state.Type = types.StringPointerValue(ans.Type)
	// property: name=used_for, type=STRING macro=copy_to_state
	state.UsedFor = types.StringPointerValue(ans.UsedFor)
	// property: name=vlan_config, type=REFERENCE macro=copy_to_state
	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &rsModelVlanConfig{}
		// copy_to_state: state=state.VlanConfig prefix=rsModel ans=ans.VlanConfig properties=3
		tflog.Debug(ctx, "copy_to_state state=state.VlanConfig prefix=rsModel ans=ans.VlanConfig")
		// property: name=mstp_instance, type=INTEGER macro=copy_to_state
		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)
		// property: name=vlan_id, type=INTEGER macro=copy_to_state
		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)
		// property: name=voice_enabled, type=BOOLEAN macro=copy_to_state
		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}
	// property: name=vrf_context_id, type=STRING macro=copy_to_state
	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)
	return true
}

func (r *elementInterfaceResource) doGet(ctx context.Context, state *rsModelInterfaceScreenV4N20, savestate *rsModelInterfaceScreenV4N20, State *tfsdk.State, resp *resource.ReadResponse) bool {
	// Basic logging.
	tfid := savestate.Tfid.ValueString()
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "prismasdwan_element_interface",
		"tfid":                        tfid,
	})

	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) < 3 {
		resp.Diagnostics.AddError("error in prismasdwan_element_interface ID format", "Expected 3 tokens")
		return false
	}

	// Prepare to read the config.
	svc := sdwan_client.NewClient(r.client)

	// Prepare input for the API endpoint.
	read_request := &sdwan_client.SdwanClientRequestResponse{}
	read_request.ResourceType = "prismasdwan_element_interface"
	read_request.Method = "GET"
	read_request.Path = "/sdwan/v4.20/api/sites/{site_id}/elements/{element_id}/interfaces/{interface_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, savestate.TfParameters)
	read_request.PathParameters = &params
	// add last parameter as ObjectID
	(*read_request.PathParameters)["interface_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*read_request.PathParameters)[param[0]] = &param[1]
	}

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, read_request)
	if read_request.ResponseErr != nil {
		if IsObjectNotFound(*read_request.ResponseErr) {
			State.RemoveResource(ctx)
		} else if r.GetHttpStatusCode(read_request) == 404 {
			State.RemoveResource(ctx)
		} else {
			tflog.Info(ctx, "read request failed for prismasdwan_element_interface", map[string]any{
				"terraform_provider_function": "Read",
				"resource_name":               "prismasdwan_element_interface",
				"path":                        read_request.FinalPath,
				"request":                     read_request.ToString(),
			})
			resp.Diagnostics.AddError("error reading prismasdwan_element_interface from sdwan servers", (*read_request.ResponseErr).Error())
		}
		return false
	}

	// process http json path
	response_body_string := string(*read_request.ResponseBytes)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete response_body_string::_created_on_utc")
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	tflog.Debug(ctx, "http json override: set response_body_string::_schema")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// Store the answer to state. schema=InterfaceScreenV4N20
	state.Tfid = savestate.Tfid
	// copy parameters from savestate as they are
	if savestate.TfParameters.IsNull() {
		state.TfParameters = types.MapNull(types.StringType)
	} else {
		state.TfParameters = savestate.TfParameters
	}
	// start copying attributes
	var ans sdwan_schema.InterfaceScreenV4N20
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to InterfaceScreenV4N20 in read", json_err.Error())
		return false
	}
	// lets copy all items into state
	// copy_to_state: state=state prefix=rsModel ans=ans properties=50
	tflog.Debug(ctx, "copy_to_state state=state prefix=rsModel ans=ans")
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=admin_up, type=BOOLEAN macro=copy_to_state
	state.AdminUp = types.BoolPointerValue(ans.AdminUp)
	// property: name=attached_lan_networks, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.AttachedLanNetworks == nil {
		state.AttachedLanNetworks = nil
	} else if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = []rsModelLanNetworkVlanMapping{}
	} else {
		state.AttachedLanNetworks = make([]rsModelLanNetworkVlanMapping, 0, len(ans.AttachedLanNetworks))
		for varLoopAttachedLanNetworksIndex, varLoopAttachedLanNetworks := range ans.AttachedLanNetworks {
			// add a new item
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, rsModelLanNetworkVlanMapping{})
			// copy_to_state: state=state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel ans=varLoopAttachedLanNetworks properties=2
			tflog.Debug(ctx, "copy_to_state state=state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel ans=varLoopAttachedLanNetworks")
			// property: name=lan_network_id, type=STRING macro=copy_to_state
			state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].LanNetworkId = types.StringPointerValue(varLoopAttachedLanNetworks.LanNetworkId)
			// property: name=vlan_id, type=INTEGER macro=copy_to_state
			state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].VlanId = types.Int64PointerValue(varLoopAttachedLanNetworks.VlanId)
		}
	}
	// property: name=authentication_config, type=REFERENCE macro=copy_to_state
	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &rsModelAuthenticationInterfaceConfig{}
		// copy_to_state: state=state.AuthenticationConfig prefix=rsModel ans=ans.AuthenticationConfig properties=3
		tflog.Debug(ctx, "copy_to_state state=state.AuthenticationConfig prefix=rsModel ans=ans.AuthenticationConfig")
		// property: name=fallback_retry_count, type=INTEGER macro=copy_to_state
		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)
		// property: name=mode, type=STRING macro=copy_to_state
		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)
		// property: name=reauthentication_timeout, type=INTEGER macro=copy_to_state
		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}
	// property: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=copy_to_state
	varBoundInterfaces, errBoundInterfaces := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = varBoundInterfaces
	resp.Diagnostics.Append(errBoundInterfaces.Errors()...)
	// property: name=bypass_pair, type=REFERENCE macro=copy_to_state
	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &rsModelBypassPairV2{}
		// copy_to_state: state=state.BypassPair prefix=rsModel ans=ans.BypassPair properties=4
		tflog.Debug(ctx, "copy_to_state state=state.BypassPair prefix=rsModel ans=ans.BypassPair")
		// property: name=lan, type=STRING macro=copy_to_state
		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)
		// property: name=lan_state_propagation, type=BOOLEAN macro=copy_to_state
		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)
		// property: name=use_relay, type=BOOLEAN macro=copy_to_state
		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)
		// property: name=wan, type=STRING macro=copy_to_state
		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}
	// property: name=cellular_config, type=REFERENCE macro=copy_to_state
	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &rsModelCellularInterfaceConfig{}
		// copy_to_state: state=state.CellularConfig prefix=rsModel ans=ans.CellularConfig properties=5
		tflog.Debug(ctx, "copy_to_state state=state.CellularConfig prefix=rsModel ans=ans.CellularConfig")
		// property: name=apn_config, type=REFERENCE macro=copy_to_state
		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &rsModelAPNConfig{}
			// copy_to_state: state=state.CellularConfig.ApnConfig prefix=rsModel ans=ans.CellularConfig.ApnConfig properties=6
			tflog.Debug(ctx, "copy_to_state state=state.CellularConfig.ApnConfig prefix=rsModel ans=ans.CellularConfig.ApnConfig")
			// property: name=apn, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)
			// property: name=authentication, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Authentication = types.StringPointerValue(ans.CellularConfig.ApnConfig.Authentication)
			// property: name=clear_password, type=BOOLEAN macro=copy_to_state
			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)
			// property: name=password, type=STRING macro=copy_to_state
			encryptedPasswordKeyName := state.CellularConfig.ApnConfig.PasswordInternalKeyName.String()
			encryptedPasswordValueBytes, _ := resp.Private.GetKey(ctx, encryptedPasswordKeyName)
			if encryptedPasswordValueBytes != nil {
				decryptedPassword, _ := Decrypt(string(encryptedPasswordValueBytes))
				state.CellularConfig.ApnConfig.Password = types.StringValue(decryptedPassword)
			}
			// property: name=password_encrypted, type=STRING macro=copy_to_state
			encryptedPasswordEncryptedKeyName := state.CellularConfig.ApnConfig.PasswordEncryptedInternalKeyName.String()
			encryptedPasswordEncryptedValueBytes, _ := resp.Private.GetKey(ctx, encryptedPasswordEncryptedKeyName)
			if encryptedPasswordEncryptedValueBytes != nil {
				decryptedPasswordEncrypted, _ := Decrypt(string(encryptedPasswordEncryptedValueBytes))
				state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringValue(decryptedPasswordEncrypted)
			}
			// property: name=user_name, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}
		// property: name=apnprofile_id, type=STRING macro=copy_to_state
		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)
		// property: name=auto_apn, type=BOOLEAN macro=copy_to_state
		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)
		// property: name=parent_module_id, type=STRING macro=copy_to_state
		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)
		// property: name=parent_sim_slot_number, type=INTEGER macro=copy_to_state
		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=devicemgmt_policysetstack_id, type=STRING macro=copy_to_state
	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)
	// property: name=dhcp_relay, type=REFERENCE macro=copy_to_state
	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &rsModelDHCPRelay{}
		// copy_to_state: state=state.DhcpRelay prefix=rsModel ans=ans.DhcpRelay properties=4
		tflog.Debug(ctx, "copy_to_state state=state.DhcpRelay prefix=rsModel ans=ans.DhcpRelay")
		// property: name=enabled, type=BOOLEAN macro=copy_to_state
		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)
		// property: name=option_82, type=REFERENCE macro=copy_to_state
		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &rsModelDHCPRelayOption82{}
			// copy_to_state: state=state.DhcpRelay.Option82 prefix=rsModel ans=ans.DhcpRelay.Option82 properties=4
			tflog.Debug(ctx, "copy_to_state state=state.DhcpRelay.Option82 prefix=rsModel ans=ans.DhcpRelay.Option82")
			// property: name=circuit_id, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)
			// property: name=enabled, type=BOOLEAN macro=copy_to_state
			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)
			// property: name=reforwarding_policy, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringPointerValue(ans.DhcpRelay.Option82.ReforwardingPolicy)
			// property: name=remote_id, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}
		// property: name=server_ips, type=ARRAY_PRIMITIVE macro=copy_to_state
		varServerIps, errServerIps := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = varServerIps
		resp.Diagnostics.Append(errServerIps.Errors()...)
		// property: name=source_interface, type=STRING macro=copy_to_state
		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}
	// property: name=directed_broadcast, type=BOOLEAN macro=copy_to_state
	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)
	// property: name=ethernet_port, type=REFERENCE macro=copy_to_state
	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &rsModelEthernetPort{}
		// copy_to_state: state=state.EthernetPort prefix=rsModel ans=ans.EthernetPort properties=4
		tflog.Debug(ctx, "copy_to_state state=state.EthernetPort prefix=rsModel ans=ans.EthernetPort")
		// property: name=full_duplex, type=BOOLEAN macro=copy_to_state
		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)
		// property: name=port_id, type=REFERENCE macro=copy_to_state
		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &rsModelEthernet{}
			// copy_to_state: state=state.EthernetPort.PortId prefix=rsModel ans=ans.EthernetPort.PortId properties=16
			tflog.Debug(ctx, "copy_to_state state=state.EthernetPort.PortId prefix=rsModel ans=ans.EthernetPort.PortId")
			// property: name=_etag, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.Etag = types.Int64PointerValue(ans.EthernetPort.PortId.Etag)
			// property: name=_schema, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.Schema = types.Int64PointerValue(ans.EthernetPort.PortId.Schema)
			// property: name=connector, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)
			// property: name=device, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)
			// property: name=disabled, type=BOOLEAN macro=copy_to_state
			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)
			// property: name=disabled_reason, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)
			// property: name=element_id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)
			// property: name=id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)
			// property: name=inactive, type=BOOLEAN macro=copy_to_state
			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)
			// property: name=inactive_reason, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)
			// property: name=max_mtu, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)
			// property: name=max_speed, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)
			// property: name=name, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)
			// property: name=original_mac_address, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)
			// property: name=region, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)
			// property: name=site_id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.SiteId = types.StringPointerValue(ans.EthernetPort.PortId.SiteId)
		}
		// property: name=port_name, type=STRING macro=copy_to_state
		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)
		// property: name=speed, type=INTEGER macro=copy_to_state
		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=interface_profile_id, type=STRING macro=copy_to_state
	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)
	// property: name=ipfixcollectorcontext_id, type=STRING macro=copy_to_state
	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)
	// property: name=ipfixfiltercontext_id, type=STRING macro=copy_to_state
	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)
	// property: name=ipv4_config, type=REFERENCE macro=copy_to_state
	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &rsModelIpv4Config{}
		// copy_to_state: state=state.Ipv4Config prefix=rsModel ans=ans.Ipv4Config properties=6
		tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config prefix=rsModel ans=ans.Ipv4Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &rsModelIpv4Dhcp{}
			// copy_to_state: state=state.Ipv4Config.DhcpConfig prefix=rsModel ans=ans.Ipv4Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.DhcpConfig prefix=rsModel ans=ans.Ipv4Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_to_state
			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_to_state
			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v4_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &rsModelDNS{}
			// copy_to_state: state=state.Ipv4Config.DnsV4Config prefix=rsModel ans=ans.Ipv4Config.DnsV4Config properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.DnsV4Config prefix=rsModel ans=ans.Ipv4Config.DnsV4Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
			varNameServers, errNameServers := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = varNameServers
			resp.Diagnostics.Append(errNameServers.Errors()...)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_to_state
			varSearch, errSearch := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = varSearch
			resp.Diagnostics.Append(errSearch.Errors()...)
		}
		// property: name=pppoe_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &rsModelIpv4Pppoe{}
			// copy_to_state: state=state.Ipv4Config.PppoeConfig prefix=rsModel ans=ans.Ipv4Config.PppoeConfig properties=3
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.PppoeConfig prefix=rsModel ans=ans.Ipv4Config.PppoeConfig")
			// property: name=chap_passwd, type=STRING macro=copy_to_state
			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)
			// property: name=chap_user, type=STRING macro=copy_to_state
			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)
			// property: name=set_route, type=BOOLEAN macro=copy_to_state
			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.Ipv4Config.Routes == nil {
			state.Ipv4Config.Routes = nil
		} else if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = []rsModelRoute{}
		} else {
			state.Ipv4Config.Routes = make([]rsModelRoute, 0, len(ans.Ipv4Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range ans.Ipv4Config.Routes {
				// add a new item
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, rsModelRoute{})
				// copy_to_state: state=state.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_to_state
				state.Ipv4Config.Routes[varLoopRoutesIndex].Destination = types.StringPointerValue(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_to_state
				state.Ipv4Config.Routes[varLoopRoutesIndex].Via = types.StringPointerValue(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &rsModelIpv4Static{}
			// copy_to_state: state=state.Ipv4Config.StaticConfig prefix=rsModel ans=ans.Ipv4Config.StaticConfig properties=1
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.StaticConfig prefix=rsModel ans=ans.Ipv4Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_to_state
			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}
		// property: name=type, type=STRING macro=copy_to_state
		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}
	// property: name=ipv6_config, type=REFERENCE macro=copy_to_state
	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &rsModelIpv6ConfigV1{}
		// copy_to_state: state=state.Ipv6Config prefix=rsModel ans=ans.Ipv6Config properties=5
		tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config prefix=rsModel ans=ans.Ipv6Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &rsModelIpv6Dhcp{}
			// copy_to_state: state=state.Ipv6Config.DhcpConfig prefix=rsModel ans=ans.Ipv6Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.DhcpConfig prefix=rsModel ans=ans.Ipv6Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_to_state
			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_to_state
			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v6_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &rsModelDNS{}
			// copy_to_state: state=state.Ipv6Config.DnsV6Config prefix=rsModel ans=ans.Ipv6Config.DnsV6Config properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.DnsV6Config prefix=rsModel ans=ans.Ipv6Config.DnsV6Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
			varNameServers, errNameServers := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = varNameServers
			resp.Diagnostics.Append(errNameServers.Errors()...)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_to_state
			varSearch, errSearch := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = varSearch
			resp.Diagnostics.Append(errSearch.Errors()...)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.Ipv6Config.Routes == nil {
			state.Ipv6Config.Routes = nil
		} else if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = []rsModelRoute{}
		} else {
			state.Ipv6Config.Routes = make([]rsModelRoute, 0, len(ans.Ipv6Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range ans.Ipv6Config.Routes {
				// add a new item
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, rsModelRoute{})
				// copy_to_state: state=state.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_to_state
				state.Ipv6Config.Routes[varLoopRoutesIndex].Destination = types.StringPointerValue(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_to_state
				state.Ipv6Config.Routes[varLoopRoutesIndex].Via = types.StringPointerValue(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &rsModelIpv6StaticV1{}
			// copy_to_state: state=state.Ipv6Config.StaticConfig prefix=rsModel ans=ans.Ipv6Config.StaticConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.StaticConfig prefix=rsModel ans=ans.Ipv6Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_to_state
			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)
			// property: name=enable_prefix_distribution, type=BOOLEAN macro=copy_to_state
			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}
		// property: name=type, type=STRING macro=copy_to_state
		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}
	// property: name=lldp_enabled, type=BOOLEAN macro=copy_to_state
	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)
	// property: name=mac_address, type=STRING macro=copy_to_state
	state.MacAddress = types.StringPointerValue(ans.MacAddress)
	// property: name=mtu, type=INTEGER macro=copy_to_state
	state.Mtu = types.Int64PointerValue(ans.Mtu)
	// property: name=multicast_config, type=REFERENCE macro=copy_to_state
	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &rsModelMulticastInterfaceConfig{}
		// copy_to_state: state=state.MulticastConfig prefix=rsModel ans=ans.MulticastConfig properties=4
		tflog.Debug(ctx, "copy_to_state state=state.MulticastConfig prefix=rsModel ans=ans.MulticastConfig")
		// property: name=dr_priority, type=INTEGER macro=copy_to_state
		state.MulticastConfig.DrPriority = types.Int64PointerValue(ans.MulticastConfig.DrPriority)
		// property: name=igmp_static_joins, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.MulticastConfig.IgmpStaticJoins == nil {
			state.MulticastConfig.IgmpStaticJoins = nil
		} else if len(ans.MulticastConfig.IgmpStaticJoins) == 0 {
			state.MulticastConfig.IgmpStaticJoins = []rsModelMulticastIgmpStaticJoin{}
		} else {
			state.MulticastConfig.IgmpStaticJoins = make([]rsModelMulticastIgmpStaticJoin, 0, len(ans.MulticastConfig.IgmpStaticJoins))
			for varLoopIgmpStaticJoinsIndex, varLoopIgmpStaticJoins := range ans.MulticastConfig.IgmpStaticJoins {
				// add a new item
				state.MulticastConfig.IgmpStaticJoins = append(state.MulticastConfig.IgmpStaticJoins, rsModelMulticastIgmpStaticJoin{})
				// copy_to_state: state=state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel ans=varLoopIgmpStaticJoins properties=2
				tflog.Debug(ctx, "copy_to_state state=state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel ans=varLoopIgmpStaticJoins")
				// property: name=igmp_static_grp_ipv4, type=STRING macro=copy_to_state
				state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticGrpIpv4 = types.StringPointerValue(varLoopIgmpStaticJoins.IgmpStaticGrpIpv4)
				// property: name=igmp_static_src_ipv4, type=STRING macro=copy_to_state
				state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticSrcIpv4 = types.StringPointerValue(varLoopIgmpStaticJoins.IgmpStaticSrcIpv4)
			}
		}
		// property: name=igmp_version, type=STRING macro=copy_to_state
		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)
		// property: name=multicast_enabled, type=BOOLEAN macro=copy_to_state
		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=nat_address, type=STRING macro=copy_to_state
	state.NatAddress = types.StringPointerValue(ans.NatAddress)
	// property: name=nat_address_v6, type=STRING macro=copy_to_state
	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)
	// property: name=nat_pools, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.NatPools == nil {
		state.NatPools = nil
	} else if len(ans.NatPools) == 0 {
		state.NatPools = []rsModelNatPool{}
	} else {
		state.NatPools = make([]rsModelNatPool, 0, len(ans.NatPools))
		for varLoopNatPoolsIndex, varLoopNatPools := range ans.NatPools {
			// add a new item
			state.NatPools = append(state.NatPools, rsModelNatPool{})
			// copy_to_state: state=state.NatPools[varLoopNatPoolsIndex] prefix=rsModel ans=varLoopNatPools properties=2
			tflog.Debug(ctx, "copy_to_state state=state.NatPools[varLoopNatPoolsIndex] prefix=rsModel ans=varLoopNatPools")
			// property: name=ipv4_ranges, type=ARRAY_REFERENCE macro=copy_to_state
			if varLoopNatPools.Ipv4Ranges == nil {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = nil
			} else if len(varLoopNatPools.Ipv4Ranges) == 0 {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = []rsModelIPv4Range{}
			} else {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = make([]rsModelIPv4Range, 0, len(varLoopNatPools.Ipv4Ranges))
				for varLoopIpv4RangesIndex, varLoopIpv4Ranges := range varLoopNatPools.Ipv4Ranges {
					// add a new item
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = append(state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges, rsModelIPv4Range{})
					// copy_to_state: state=state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel ans=varLoopIpv4Ranges properties=2
					tflog.Debug(ctx, "copy_to_state state=state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel ans=varLoopIpv4Ranges")
					// property: name=end, type=STRING macro=copy_to_state
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].End = types.StringPointerValue(varLoopIpv4Ranges.End)
					// property: name=start, type=STRING macro=copy_to_state
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].Start = types.StringPointerValue(varLoopIpv4Ranges.Start)
				}
			}
			// property: name=nat_pool_id, type=STRING macro=copy_to_state
			state.NatPools[varLoopNatPoolsIndex].NatPoolId = types.StringPointerValue(varLoopNatPools.NatPoolId)
		}
	}
	// property: name=nat_port, type=INTEGER macro=copy_to_state
	state.NatPort = types.Int64PointerValue(ans.NatPort)
	// property: name=nat_port_v6, type=INTEGER macro=copy_to_state
	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)
	// property: name=nat_zone_id, type=STRING macro=copy_to_state
	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)
	// property: name=network_context_id, type=STRING macro=copy_to_state
	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)
	// property: name=parent, type=STRING macro=copy_to_state
	state.Parent = types.StringPointerValue(ans.Parent)
	// property: name=peer_bypasspair_wan_port_type, type=STRING macro=copy_to_state
	state.PeerBypasspairWanPortType = types.StringPointerValue(ans.PeerBypasspairWanPortType)
	// property: name=poe_enabled, type=BOOLEAN macro=copy_to_state
	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)
	// property: name=port_channel_config, type=REFERENCE macro=copy_to_state
	if ans.PortChannelConfig == nil {
		state.PortChannelConfig = nil
	} else {
		state.PortChannelConfig = &rsModelPortChannelConfig{}
		// copy_to_state: state=state.PortChannelConfig prefix=rsModel ans=ans.PortChannelConfig properties=2
		tflog.Debug(ctx, "copy_to_state state=state.PortChannelConfig prefix=rsModel ans=ans.PortChannelConfig")
		// property: name=lacp_enabled, type=BOOLEAN macro=copy_to_state
		state.PortChannelConfig.LacpEnabled = types.BoolPointerValue(ans.PortChannelConfig.LacpEnabled)
		// property: name=transmission_mode, type=STRING macro=copy_to_state
		state.PortChannelConfig.TransmissionMode = types.StringPointerValue(ans.PortChannelConfig.TransmissionMode)
	}
	// property: name=power_usage_threshold, type=INTEGER macro=copy_to_state
	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)
	// property: name=pppoe_config, type=REFERENCE macro=copy_to_state
	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &rsModelPppoEInterfaceConfig{}
		// copy_to_state: state=state.PppoeConfig prefix=rsModel ans=ans.PppoeConfig properties=6
		tflog.Debug(ctx, "copy_to_state state=state.PppoeConfig prefix=rsModel ans=ans.PppoeConfig")
		// property: name=host_uniq, type=STRING macro=copy_to_state
		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)
		// property: name=ip_address_type, type=STRING macro=copy_to_state
		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)
		// property: name=password, type=STRING macro=copy_to_state
		encryptedPasswordKeyName := state.PppoeConfig.PasswordInternalKeyName.String()
		encryptedPasswordValueBytes, _ := resp.Private.GetKey(ctx, encryptedPasswordKeyName)
		if encryptedPasswordValueBytes != nil {
			decryptedPassword, _ := Decrypt(string(encryptedPasswordValueBytes))
			state.PppoeConfig.Password = types.StringValue(decryptedPassword)
		}
		// property: name=reconnection_delay, type=INTEGER macro=copy_to_state
		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)
		// property: name=service_name, type=STRING macro=copy_to_state
		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)
		// property: name=username, type=STRING macro=copy_to_state
		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}
	// property: name=scope, type=STRING macro=copy_to_state
	state.Scope = types.StringPointerValue(ans.Scope)
	// property: name=secondary_ip_configs, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.SecondaryIpConfigs == nil {
		state.SecondaryIpConfigs = nil
	} else if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = []rsModelSecondaryIPConfig{}
	} else {
		state.SecondaryIpConfigs = make([]rsModelSecondaryIPConfig, 0, len(ans.SecondaryIpConfigs))
		for varLoopSecondaryIpConfigsIndex, varLoopSecondaryIpConfigs := range ans.SecondaryIpConfigs {
			// add a new item
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, rsModelSecondaryIPConfig{})
			// copy_to_state: state=state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel ans=varLoopSecondaryIpConfigs properties=2
			tflog.Debug(ctx, "copy_to_state state=state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel ans=varLoopSecondaryIpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Ipv4Address = types.StringPointerValue(varLoopSecondaryIpConfigs.Ipv4Address)
			// property: name=scope, type=STRING macro=copy_to_state
			state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Scope = types.StringPointerValue(varLoopSecondaryIpConfigs.Scope)
		}
	}
	// property: name=service_link_config, type=REFERENCE macro=copy_to_state
	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &rsModelServiceLinkV4{}
		// copy_to_state: state=state.ServiceLinkConfig prefix=rsModel ans=ans.ServiceLinkConfig properties=8
		tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig prefix=rsModel ans=ans.ServiceLinkConfig")
		// property: name=gre_config, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &rsModelGREConfig{}
			// copy_to_state: state=state.ServiceLinkConfig.GreConfig prefix=rsModel ans=ans.ServiceLinkConfig.GreConfig properties=4
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.GreConfig prefix=rsModel ans=ans.ServiceLinkConfig.GreConfig")
			// property: name=csum, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)
			// property: name=keepalive_enable, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)
			// property: name=keepalive_fail_count, type=INTEGER macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)
			// property: name=keepalive_interval, type=INTEGER macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}
		// property: name=ipsec_config, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &rsModelIPSECConfigV1{}
			// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig")
			// property: name=authentication, type=REFERENCE macro=copy_to_state
			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &rsModelIPSECAuthenticationV1{}
				// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication properties=22
				tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication")
				// property: name=certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)
				// property: name=certificate_profile_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)
				// property: name=comment, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)
				// property: name=ikev1_params, type=REFERENCE macro=copy_to_state
				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &rsModelIKEV1Params{}
					// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params properties=5
					tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params")
					// property: name=xauth_id, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)
					// property: name=xauth_secret, type=STRING macro=copy_to_state
					encryptedXauthSecretKeyName := state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretInternalKeyName.String()
					encryptedXauthSecretValueBytes, _ := resp.Private.GetKey(ctx, encryptedXauthSecretKeyName)
					if encryptedXauthSecretValueBytes != nil {
						decryptedXauthSecret, _ := Decrypt(string(encryptedXauthSecretValueBytes))
						state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringValue(decryptedXauthSecret)
					}
					// property: name=xauth_secret_encrypted, type=STRING macro=copy_to_state
					encryptedXauthSecretEncryptedKeyName := state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncryptedInternalKeyName.String()
					encryptedXauthSecretEncryptedValueBytes, _ := resp.Private.GetKey(ctx, encryptedXauthSecretEncryptedKeyName)
					if encryptedXauthSecretEncryptedValueBytes != nil {
						decryptedXauthSecretEncrypted, _ := Decrypt(string(encryptedXauthSecretEncryptedValueBytes))
						state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringValue(decryptedXauthSecretEncrypted)
					}
					// property: name=xauth_secret_hash, type=STRING macro=copy_to_state
					encryptedXauthSecretHashKeyName := state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHashInternalKeyName.String()
					encryptedXauthSecretHashValueBytes, _ := resp.Private.GetKey(ctx, encryptedXauthSecretHashKeyName)
					if encryptedXauthSecretHashValueBytes != nil {
						decryptedXauthSecretHash, _ := Decrypt(string(encryptedXauthSecretHashValueBytes))
						state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringValue(decryptedXauthSecretHash)
					}
					// property: name=xauth_type, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}
				// property: name=local_ca_certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)
				// property: name=local_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)
				// property: name=local_id_custom, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)
				// property: name=local_pa_certificate_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)
				// property: name=pa_master_key_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)
				// property: name=passphrase, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)
				// property: name=passphrase_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)
				// property: name=peer_id_check, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)
				// property: name=permit_peer_id_mismatch, type=BOOLEAN macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)
				// property: name=private_key, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)
				// property: name=private_key_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)
				// property: name=remote_ca_certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)
				// property: name=remote_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)
				// property: name=secret, type=STRING macro=copy_to_state
				encryptedSecretKeyName := state.ServiceLinkConfig.IpsecConfig.Authentication.SecretInternalKeyName.String()
				encryptedSecretValueBytes, _ := resp.Private.GetKey(ctx, encryptedSecretKeyName)
				if encryptedSecretValueBytes != nil {
					decryptedSecret, _ := Decrypt(string(encryptedSecretValueBytes))
					state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringValue(decryptedSecret)
				}
				// property: name=secret_encrypted, type=STRING macro=copy_to_state
				encryptedSecretEncryptedKeyName := state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncryptedInternalKeyName.String()
				encryptedSecretEncryptedValueBytes, _ := resp.Private.GetKey(ctx, encryptedSecretEncryptedKeyName)
				if encryptedSecretEncryptedValueBytes != nil {
					decryptedSecretEncrypted, _ := Decrypt(string(encryptedSecretEncryptedValueBytes))
					state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringValue(decryptedSecretEncrypted)
				}
				// property: name=secret_hash, type=STRING macro=copy_to_state
				encryptedSecretHashKeyName := state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHashInternalKeyName.String()
				encryptedSecretHashValueBytes, _ := resp.Private.GetKey(ctx, encryptedSecretHashKeyName)
				if encryptedSecretHashValueBytes != nil {
					decryptedSecretHash, _ := Decrypt(string(encryptedSecretHashValueBytes))
					state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringValue(decryptedSecretHash)
				}
				// property: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)
				// property: name=type, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)
			}
			// property: name=ipsec_profile_id, type=STRING macro=copy_to_state
			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}
		// property: name=last_parent, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)
		// property: name=parent, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)
		// property: name=passive_mode, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &rsModelPassiveMode{}
			// copy_to_state: state=state.ServiceLinkConfig.PassiveMode prefix=rsModel ans=ans.ServiceLinkConfig.PassiveMode properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.PassiveMode prefix=rsModel ans=ans.ServiceLinkConfig.PassiveMode")
			// property: name=enable, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)
			// property: name=peer_ip_dynamic, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}
		// property: name=peer, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &rsModelPeerInfo{}
			// copy_to_state: state=state.ServiceLinkConfig.Peer prefix=rsModel ans=ans.ServiceLinkConfig.Peer properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.Peer prefix=rsModel ans=ans.ServiceLinkConfig.Peer")
			// property: name=hostname, type=STRING macro=copy_to_state
			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)
			// property: name=ip_addresses, type=ARRAY_PRIMITIVE macro=copy_to_state
			varIpAddresses, errIpAddresses := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = varIpAddresses
			resp.Diagnostics.Append(errIpAddresses.Errors()...)
		}
		// property: name=service_endpoint_id, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)
		// property: name=type, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.Type = types.StringPointerValue(ans.ServiceLinkConfig.Type)
	}
	// property: name=sgi_apply_static_tag, type=BOOLEAN macro=copy_to_state
	state.SgiApplyStaticTag = types.BoolPointerValue(ans.SgiApplyStaticTag)
	// property: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=copy_to_state
	varSiteWanInterfaceIds, errSiteWanInterfaceIds := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = varSiteWanInterfaceIds
	resp.Diagnostics.Append(errSiteWanInterfaceIds.Errors()...)
	// property: name=static_arp_configs, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.StaticArpConfigs == nil {
		state.StaticArpConfigs = nil
	} else if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = []rsModelStaticARPConfig{}
	} else {
		state.StaticArpConfigs = make([]rsModelStaticARPConfig, 0, len(ans.StaticArpConfigs))
		for varLoopStaticArpConfigsIndex, varLoopStaticArpConfigs := range ans.StaticArpConfigs {
			// add a new item
			state.StaticArpConfigs = append(state.StaticArpConfigs, rsModelStaticARPConfig{})
			// copy_to_state: state=state.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel ans=varLoopStaticArpConfigs properties=2
			tflog.Debug(ctx, "copy_to_state state=state.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel ans=varLoopStaticArpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.StaticArpConfigs[varLoopStaticArpConfigsIndex].Ipv4Address = types.StringPointerValue(varLoopStaticArpConfigs.Ipv4Address)
			// property: name=mac_address, type=STRING macro=copy_to_state
			state.StaticArpConfigs[varLoopStaticArpConfigsIndex].MacAddress = types.StringPointerValue(varLoopStaticArpConfigs.MacAddress)
		}
	}
	// property: name=sub_interface, type=REFERENCE macro=copy_to_state
	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &rsModelSubInterface{}
		// copy_to_state: state=state.SubInterface prefix=rsModel ans=ans.SubInterface properties=1
		tflog.Debug(ctx, "copy_to_state state=state.SubInterface prefix=rsModel ans=ans.SubInterface")
		// property: name=vlan_id, type=INTEGER macro=copy_to_state
		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}
	// property: name=switch_port_config, type=REFERENCE macro=copy_to_state
	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &rsModelSwitchPortConfig{}
		// copy_to_state: state=state.SwitchPortConfig prefix=rsModel ans=ans.SwitchPortConfig properties=12
		tflog.Debug(ctx, "copy_to_state state=state.SwitchPortConfig prefix=rsModel ans=ans.SwitchPortConfig")
		// property: name=access_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)
		// property: name=bpdu_guard_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)
		// property: name=forward_fast_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)
		// property: name=native_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)
		// property: name=root_guard_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)
		// property: name=storm_control_config, type=REFERENCE macro=copy_to_state
		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &rsModelStormControlConfig{}
			// copy_to_state: state=state.SwitchPortConfig.StormControlConfig prefix=rsModel ans=ans.SwitchPortConfig.StormControlConfig properties=3
			tflog.Debug(ctx, "copy_to_state state=state.SwitchPortConfig.StormControlConfig prefix=rsModel ans=ans.SwitchPortConfig.StormControlConfig")
			// property: name=broadcast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)
			// property: name=multicast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)
			// property: name=unicast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}
		// property: name=stp_port_cost, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)
		// property: name=stp_port_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)
		// property: name=stp_port_priority, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)
		// property: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=copy_to_state
		varTrunkVlans, errTrunkVlans := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = varTrunkVlans
		resp.Diagnostics.Append(errTrunkVlans.Errors()...)
		// property: name=vlan_mode, type=STRING macro=copy_to_state
		state.SwitchPortConfig.VlanMode = types.StringPointerValue(ans.SwitchPortConfig.VlanMode)
		// property: name=voice_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	// property: name=type, type=STRING macro=copy_to_state
	state.Type = types.StringPointerValue(ans.Type)
	// property: name=used_for, type=STRING macro=copy_to_state
	state.UsedFor = types.StringPointerValue(ans.UsedFor)
	// property: name=vlan_config, type=REFERENCE macro=copy_to_state
	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &rsModelVlanConfig{}
		// copy_to_state: state=state.VlanConfig prefix=rsModel ans=ans.VlanConfig properties=3
		tflog.Debug(ctx, "copy_to_state state=state.VlanConfig prefix=rsModel ans=ans.VlanConfig")
		// property: name=mstp_instance, type=INTEGER macro=copy_to_state
		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)
		// property: name=vlan_id, type=INTEGER macro=copy_to_state
		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)
		// property: name=voice_enabled, type=BOOLEAN macro=copy_to_state
		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}
	// property: name=vrf_context_id, type=STRING macro=copy_to_state
	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)
	return true
}

func (r *elementInterfaceResource) doPut(ctx context.Context, plan *rsModelInterfaceScreenV4N20, state *rsModelInterfaceScreenV4N20, State *tfsdk.State, resp *resource.UpdateResponse) bool {
	state_tfid := state.Tfid.ValueString()
	plan_tfid := plan.Tfid.ValueString()
	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "prismasdwan_element_interface",
		"state_tfid":                  state_tfid,
		"plan_tfid":                   plan_tfid,
	})

	// both TFID must be SAME!!!
	if state_tfid != plan_tfid {
		resp.Diagnostics.AddError("error updating prismasdwan_element_interface", "state and plan TFID do not match")
		return false
	}

	// split tokens
	tokens := strings.Split(state_tfid, IdSeparator)
	if len(tokens) < 3 {
		resp.Diagnostics.AddError("error in prismasdwan_element_interface ID format", "Expected 3 tokens")
		return false
	}

	// Prepare input for the API endpoint.
	put_request := &sdwan_client.SdwanClientRequestResponse{}
	put_request.ResourceType = "prismasdwan_element_interface"
	put_request.Method = "PUT"
	put_request.Path = "/sdwan/v4.20/api/sites/{site_id}/elements/{element_id}/interfaces/{interface_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, state.TfParameters)
	put_request.PathParameters = &params
	// add last parameter as ObjectID
	(*put_request.PathParameters)["interface_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*put_request.PathParameters)[param[0]] = &param[1]
	}

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// prepare request from state
	var body = &sdwan_schema.InterfaceScreenV4N20{}

	// now we create the JSON request from the state/plan created by TF
	// below copy code generated from macro copy_from_plan_or_state
	// copy_from_plan_or_state: body=body prefix=rsModel state=state plan=plan properties=50
	tflog.Debug(ctx, "copy_from_plan_or_state body=body prefix=rsModel state=state plan=plan")
	// property: name=_etag, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Etag = ValueInt64PointerFromPlanOrState(plan.Etag, state.Etag)
	} else {
		body.Etag = Int64ValueOrNil(plan.Etag)
	}
	// property: name=_schema, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Schema = ValueInt64PointerFromPlanOrState(plan.Schema, state.Schema)
	} else {
		body.Schema = Int64ValueOrNil(plan.Schema)
	}
	// property: name=admin_up, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.AdminUp = ValueBoolPointerFromPlanOrState(plan.AdminUp, state.AdminUp)
	} else {
		body.AdminUp = BoolValueOrNil(plan.AdminUp)
	}
	// property: name=attached_lan_networks, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
	if plan.AttachedLanNetworks == nil && (state == nil || state.AttachedLanNetworks == nil) {
		body.AttachedLanNetworks = nil
	} else if len(plan.AttachedLanNetworks) == 0 && (state == nil || len(state.AttachedLanNetworks) == 0) {
		body.AttachedLanNetworks = []sdwan_schema.LanNetworkVlanMapping{}
	} else if len(plan.AttachedLanNetworks) != 0 || (state != nil && len(state.AttachedLanNetworks) != 0) {
		AttachedLanNetworksToUse := plan.AttachedLanNetworks
		if len(plan.AttachedLanNetworks) == 0 {
			AttachedLanNetworksToUse = state.AttachedLanNetworks
		}
		body.AttachedLanNetworks = make([]sdwan_schema.LanNetworkVlanMapping, 0, len(AttachedLanNetworksToUse))
		for varLoopAttachedLanNetworksIndex, varLoopAttachedLanNetworks := range AttachedLanNetworksToUse {
			// add a new item
			body.AttachedLanNetworks = append(body.AttachedLanNetworks, sdwan_schema.LanNetworkVlanMapping{})
			// since we have chosen to stick with either the plan or state, we need to simply copy child properties
			// copy_from_plan: body=body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel plan=varLoopAttachedLanNetworks properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel plan=varLoopAttachedLanNetworks")
			// property: name=lan_network_id, type=STRING macro=copy_from_plan
			body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].LanNetworkId = StringValueOrNil(varLoopAttachedLanNetworks.LanNetworkId)
			// property: name=vlan_id, type=INTEGER macro=copy_from_plan
			body.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].VlanId = Int64ValueOrNil(varLoopAttachedLanNetworks.VlanId)
		}
	}
	// property: name=authentication_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.AuthenticationConfig == nil {
		body.AuthenticationConfig = nil
	} else {
		body.AuthenticationConfig = &sdwan_schema.AuthenticationInterfaceConfig{}
		// copy_from_plan_or_state: body=body.AuthenticationConfig prefix=rsModel state=state.AuthenticationConfig plan=plan.AuthenticationConfig properties=3
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.AuthenticationConfig prefix=rsModel state=state.AuthenticationConfig plan=plan.AuthenticationConfig")
		// property: name=fallback_retry_count, type=INTEGER macro=copy_from_plan_or_state
		if state.AuthenticationConfig != nil {
			body.AuthenticationConfig.FallbackRetryCount = ValueInt64PointerFromPlanOrState(plan.AuthenticationConfig.FallbackRetryCount, state.AuthenticationConfig.FallbackRetryCount)
		} else {
			body.AuthenticationConfig.FallbackRetryCount = Int64ValueOrNil(plan.AuthenticationConfig.FallbackRetryCount)
		}
		// property: name=mode, type=STRING macro=copy_from_plan_or_state
		if state.AuthenticationConfig != nil {
			body.AuthenticationConfig.Mode = ValueStringPointerFromPlanOrState(plan.AuthenticationConfig.Mode, state.AuthenticationConfig.Mode)
		} else {
			body.AuthenticationConfig.Mode = StringValueOrNil(plan.AuthenticationConfig.Mode)
		}
		// property: name=reauthentication_timeout, type=INTEGER macro=copy_from_plan_or_state
		if state.AuthenticationConfig != nil {
			body.AuthenticationConfig.ReauthenticationTimeout = ValueInt64PointerFromPlanOrState(plan.AuthenticationConfig.ReauthenticationTimeout, state.AuthenticationConfig.ReauthenticationTimeout)
		} else {
			body.AuthenticationConfig.ReauthenticationTimeout = Int64ValueOrNil(plan.AuthenticationConfig.ReauthenticationTimeout)
		}
	}
	// property: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
	body.BoundInterfaces = ListStringValueOrNil(ctx, plan.BoundInterfaces)
	// property: name=bypass_pair, type=REFERENCE macro=copy_from_plan_or_state
	if plan.BypassPair == nil {
		body.BypassPair = nil
	} else {
		body.BypassPair = &sdwan_schema.BypassPairV2{}
		// copy_from_plan_or_state: body=body.BypassPair prefix=rsModel state=state.BypassPair plan=plan.BypassPair properties=4
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.BypassPair prefix=rsModel state=state.BypassPair plan=plan.BypassPair")
		// property: name=lan, type=STRING macro=copy_from_plan_or_state
		if state.BypassPair != nil {
			body.BypassPair.Lan = ValueStringPointerFromPlanOrState(plan.BypassPair.Lan, state.BypassPair.Lan)
		} else {
			body.BypassPair.Lan = StringValueOrNil(plan.BypassPair.Lan)
		}
		// property: name=lan_state_propagation, type=BOOLEAN macro=copy_from_plan_or_state
		if state.BypassPair != nil {
			body.BypassPair.LanStatePropagation = ValueBoolPointerFromPlanOrState(plan.BypassPair.LanStatePropagation, state.BypassPair.LanStatePropagation)
		} else {
			body.BypassPair.LanStatePropagation = BoolValueOrNil(plan.BypassPair.LanStatePropagation)
		}
		// property: name=use_relay, type=BOOLEAN macro=copy_from_plan_or_state
		if state.BypassPair != nil {
			body.BypassPair.UseRelay = ValueBoolPointerFromPlanOrState(plan.BypassPair.UseRelay, state.BypassPair.UseRelay)
		} else {
			body.BypassPair.UseRelay = BoolValueOrNil(plan.BypassPair.UseRelay)
		}
		// property: name=wan, type=STRING macro=copy_from_plan_or_state
		if state.BypassPair != nil {
			body.BypassPair.Wan = ValueStringPointerFromPlanOrState(plan.BypassPair.Wan, state.BypassPair.Wan)
		} else {
			body.BypassPair.Wan = StringValueOrNil(plan.BypassPair.Wan)
		}
	}
	// property: name=cellular_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.CellularConfig == nil {
		body.CellularConfig = nil
	} else {
		body.CellularConfig = &sdwan_schema.CellularInterfaceConfig{}
		// copy_from_plan_or_state: body=body.CellularConfig prefix=rsModel state=state.CellularConfig plan=plan.CellularConfig properties=5
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.CellularConfig prefix=rsModel state=state.CellularConfig plan=plan.CellularConfig")
		// property: name=apn_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.CellularConfig.ApnConfig == nil {
			body.CellularConfig.ApnConfig = nil
		} else {
			body.CellularConfig.ApnConfig = &sdwan_schema.APNConfig{}
			// copy_from_plan_or_state: body=body.CellularConfig.ApnConfig prefix=rsModel state=state.CellularConfig.ApnConfig plan=plan.CellularConfig.ApnConfig properties=6
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.CellularConfig.ApnConfig prefix=rsModel state=state.CellularConfig.ApnConfig plan=plan.CellularConfig.ApnConfig")
			// property: name=apn, type=STRING macro=copy_from_plan_or_state
			if state.CellularConfig.ApnConfig != nil {
				body.CellularConfig.ApnConfig.Apn = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.Apn, state.CellularConfig.ApnConfig.Apn)
			} else {
				body.CellularConfig.ApnConfig.Apn = StringValueOrNil(plan.CellularConfig.ApnConfig.Apn)
			}
			// property: name=authentication, type=STRING macro=copy_from_plan_or_state
			if state.CellularConfig.ApnConfig != nil {
				body.CellularConfig.ApnConfig.Authentication = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.Authentication, state.CellularConfig.ApnConfig.Authentication)
			} else {
				body.CellularConfig.ApnConfig.Authentication = StringValueOrNil(plan.CellularConfig.ApnConfig.Authentication)
			}
			// property: name=clear_password, type=BOOLEAN macro=copy_from_plan_or_state
			if state.CellularConfig.ApnConfig != nil {
				body.CellularConfig.ApnConfig.ClearPassword = ValueBoolPointerFromPlanOrState(plan.CellularConfig.ApnConfig.ClearPassword, state.CellularConfig.ApnConfig.ClearPassword)
			} else {
				body.CellularConfig.ApnConfig.ClearPassword = BoolValueOrNil(plan.CellularConfig.ApnConfig.ClearPassword)
			}
			// property: name=password, type=STRING macro=copy_from_plan_or_state
			if state.CellularConfig.ApnConfig != nil {
				body.CellularConfig.ApnConfig.Password = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.Password, state.CellularConfig.ApnConfig.Password)
			} else {
				body.CellularConfig.ApnConfig.Password = StringValueOrNil(plan.CellularConfig.ApnConfig.Password)
			}
			// property: name=password_encrypted, type=STRING macro=copy_from_plan_or_state
			if state.CellularConfig.ApnConfig != nil {
				body.CellularConfig.ApnConfig.PasswordEncrypted = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.PasswordEncrypted, state.CellularConfig.ApnConfig.PasswordEncrypted)
			} else {
				body.CellularConfig.ApnConfig.PasswordEncrypted = StringValueOrNil(plan.CellularConfig.ApnConfig.PasswordEncrypted)
			}
			// property: name=user_name, type=STRING macro=copy_from_plan_or_state
			if state.CellularConfig.ApnConfig != nil {
				body.CellularConfig.ApnConfig.UserName = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.UserName, state.CellularConfig.ApnConfig.UserName)
			} else {
				body.CellularConfig.ApnConfig.UserName = StringValueOrNil(plan.CellularConfig.ApnConfig.UserName)
			}
		}
		// property: name=apnprofile_id, type=STRING macro=copy_from_plan_or_state
		if state.CellularConfig != nil {
			body.CellularConfig.ApnprofileId = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnprofileId, state.CellularConfig.ApnprofileId)
		} else {
			body.CellularConfig.ApnprofileId = StringValueOrNil(plan.CellularConfig.ApnprofileId)
		}
		// property: name=auto_apn, type=BOOLEAN macro=copy_from_plan_or_state
		if state.CellularConfig != nil {
			body.CellularConfig.AutoApn = ValueBoolPointerFromPlanOrState(plan.CellularConfig.AutoApn, state.CellularConfig.AutoApn)
		} else {
			body.CellularConfig.AutoApn = BoolValueOrNil(plan.CellularConfig.AutoApn)
		}
		// property: name=parent_module_id, type=STRING macro=copy_from_plan_or_state
		if state.CellularConfig != nil {
			body.CellularConfig.ParentModuleId = ValueStringPointerFromPlanOrState(plan.CellularConfig.ParentModuleId, state.CellularConfig.ParentModuleId)
		} else {
			body.CellularConfig.ParentModuleId = StringValueOrNil(plan.CellularConfig.ParentModuleId)
		}
		// property: name=parent_sim_slot_number, type=INTEGER macro=copy_from_plan_or_state
		if state.CellularConfig != nil {
			body.CellularConfig.ParentSimSlotNumber = ValueInt64PointerFromPlanOrState(plan.CellularConfig.ParentSimSlotNumber, state.CellularConfig.ParentSimSlotNumber)
		} else {
			body.CellularConfig.ParentSimSlotNumber = Int64ValueOrNil(plan.CellularConfig.ParentSimSlotNumber)
		}
	}
	// property: name=description, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Description = ValueStringPointerFromPlanOrState(plan.Description, state.Description)
	} else {
		body.Description = StringValueOrNil(plan.Description)
	}
	// property: name=devicemgmt_policysetstack_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.DevicemgmtPolicysetstackId = ValueStringPointerFromPlanOrState(plan.DevicemgmtPolicysetstackId, state.DevicemgmtPolicysetstackId)
	} else {
		body.DevicemgmtPolicysetstackId = StringValueOrNil(plan.DevicemgmtPolicysetstackId)
	}
	// property: name=dhcp_relay, type=REFERENCE macro=copy_from_plan_or_state
	if plan.DhcpRelay == nil {
		body.DhcpRelay = nil
	} else {
		body.DhcpRelay = &sdwan_schema.DHCPRelay{}
		// copy_from_plan_or_state: body=body.DhcpRelay prefix=rsModel state=state.DhcpRelay plan=plan.DhcpRelay properties=4
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.DhcpRelay prefix=rsModel state=state.DhcpRelay plan=plan.DhcpRelay")
		// property: name=enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DhcpRelay != nil {
			body.DhcpRelay.Enabled = ValueBoolPointerFromPlanOrState(plan.DhcpRelay.Enabled, state.DhcpRelay.Enabled)
		} else {
			body.DhcpRelay.Enabled = BoolValueOrNil(plan.DhcpRelay.Enabled)
		}
		// property: name=option_82, type=REFERENCE macro=copy_from_plan_or_state
		if plan.DhcpRelay.Option82 == nil {
			body.DhcpRelay.Option82 = nil
		} else {
			body.DhcpRelay.Option82 = &sdwan_schema.DHCPRelayOption82{}
			// copy_from_plan_or_state: body=body.DhcpRelay.Option82 prefix=rsModel state=state.DhcpRelay.Option82 plan=plan.DhcpRelay.Option82 properties=4
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.DhcpRelay.Option82 prefix=rsModel state=state.DhcpRelay.Option82 plan=plan.DhcpRelay.Option82")
			// property: name=circuit_id, type=STRING macro=copy_from_plan_or_state
			if state.DhcpRelay.Option82 != nil {
				body.DhcpRelay.Option82.CircuitId = ValueStringPointerFromPlanOrState(plan.DhcpRelay.Option82.CircuitId, state.DhcpRelay.Option82.CircuitId)
			} else {
				body.DhcpRelay.Option82.CircuitId = StringValueOrNil(plan.DhcpRelay.Option82.CircuitId)
			}
			// property: name=enabled, type=BOOLEAN macro=copy_from_plan_or_state
			if state.DhcpRelay.Option82 != nil {
				body.DhcpRelay.Option82.Enabled = ValueBoolPointerFromPlanOrState(plan.DhcpRelay.Option82.Enabled, state.DhcpRelay.Option82.Enabled)
			} else {
				body.DhcpRelay.Option82.Enabled = BoolValueOrNil(plan.DhcpRelay.Option82.Enabled)
			}
			// property: name=reforwarding_policy, type=STRING macro=copy_from_plan_or_state
			if state.DhcpRelay.Option82 != nil {
				body.DhcpRelay.Option82.ReforwardingPolicy = ValueStringPointerFromPlanOrState(plan.DhcpRelay.Option82.ReforwardingPolicy, state.DhcpRelay.Option82.ReforwardingPolicy)
			} else {
				body.DhcpRelay.Option82.ReforwardingPolicy = StringValueOrNil(plan.DhcpRelay.Option82.ReforwardingPolicy)
			}
			// property: name=remote_id, type=STRING macro=copy_from_plan_or_state
			if state.DhcpRelay.Option82 != nil {
				body.DhcpRelay.Option82.RemoteId = ValueStringPointerFromPlanOrState(plan.DhcpRelay.Option82.RemoteId, state.DhcpRelay.Option82.RemoteId)
			} else {
				body.DhcpRelay.Option82.RemoteId = StringValueOrNil(plan.DhcpRelay.Option82.RemoteId)
			}
		}
		// property: name=server_ips, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.DhcpRelay.ServerIps = ListStringValueOrNil(ctx, plan.DhcpRelay.ServerIps)
		// property: name=source_interface, type=STRING macro=copy_from_plan_or_state
		if state.DhcpRelay != nil {
			body.DhcpRelay.SourceInterface = ValueStringPointerFromPlanOrState(plan.DhcpRelay.SourceInterface, state.DhcpRelay.SourceInterface)
		} else {
			body.DhcpRelay.SourceInterface = StringValueOrNil(plan.DhcpRelay.SourceInterface)
		}
	}
	// property: name=directed_broadcast, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.DirectedBroadcast = ValueBoolPointerFromPlanOrState(plan.DirectedBroadcast, state.DirectedBroadcast)
	} else {
		body.DirectedBroadcast = BoolValueOrNil(plan.DirectedBroadcast)
	}
	// property: name=ethernet_port, type=REFERENCE macro=copy_from_plan_or_state
	if plan.EthernetPort == nil {
		body.EthernetPort = nil
	} else {
		body.EthernetPort = &sdwan_schema.EthernetPort{}
		// copy_from_plan_or_state: body=body.EthernetPort prefix=rsModel state=state.EthernetPort plan=plan.EthernetPort properties=4
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.EthernetPort prefix=rsModel state=state.EthernetPort plan=plan.EthernetPort")
		// property: name=full_duplex, type=BOOLEAN macro=copy_from_plan_or_state
		if state.EthernetPort != nil {
			body.EthernetPort.FullDuplex = ValueBoolPointerFromPlanOrState(plan.EthernetPort.FullDuplex, state.EthernetPort.FullDuplex)
		} else {
			body.EthernetPort.FullDuplex = BoolValueOrNil(plan.EthernetPort.FullDuplex)
		}
		// property: name=port_id, type=REFERENCE macro=copy_from_plan_or_state
		if plan.EthernetPort.PortId == nil {
			body.EthernetPort.PortId = nil
		} else {
			body.EthernetPort.PortId = &sdwan_schema.Ethernet{}
			// copy_from_plan_or_state: body=body.EthernetPort.PortId prefix=rsModel state=state.EthernetPort.PortId plan=plan.EthernetPort.PortId properties=16
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.EthernetPort.PortId prefix=rsModel state=state.EthernetPort.PortId plan=plan.EthernetPort.PortId")
			// property: name=_etag, type=INTEGER macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Etag = ValueInt64PointerFromPlanOrState(plan.EthernetPort.PortId.Etag, state.EthernetPort.PortId.Etag)
			} else {
				body.EthernetPort.PortId.Etag = Int64ValueOrNil(plan.EthernetPort.PortId.Etag)
			}
			// property: name=_schema, type=INTEGER macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Schema = ValueInt64PointerFromPlanOrState(plan.EthernetPort.PortId.Schema, state.EthernetPort.PortId.Schema)
			} else {
				body.EthernetPort.PortId.Schema = Int64ValueOrNil(plan.EthernetPort.PortId.Schema)
			}
			// property: name=connector, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Connector = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Connector, state.EthernetPort.PortId.Connector)
			} else {
				body.EthernetPort.PortId.Connector = StringValueOrNil(plan.EthernetPort.PortId.Connector)
			}
			// property: name=device, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Device = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Device, state.EthernetPort.PortId.Device)
			} else {
				body.EthernetPort.PortId.Device = StringValueOrNil(plan.EthernetPort.PortId.Device)
			}
			// property: name=disabled, type=BOOLEAN macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Disabled = ValueBoolPointerFromPlanOrState(plan.EthernetPort.PortId.Disabled, state.EthernetPort.PortId.Disabled)
			} else {
				body.EthernetPort.PortId.Disabled = BoolValueOrNil(plan.EthernetPort.PortId.Disabled)
			}
			// property: name=disabled_reason, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.DisabledReason = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.DisabledReason, state.EthernetPort.PortId.DisabledReason)
			} else {
				body.EthernetPort.PortId.DisabledReason = StringValueOrNil(plan.EthernetPort.PortId.DisabledReason)
			}
			// property: name=element_id, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.ElementId = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.ElementId, state.EthernetPort.PortId.ElementId)
			} else {
				body.EthernetPort.PortId.ElementId = StringValueOrNil(plan.EthernetPort.PortId.ElementId)
			}
			// property: name=id, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Id = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Id, state.EthernetPort.PortId.Id)
			} else {
				body.EthernetPort.PortId.Id = StringValueOrNil(plan.EthernetPort.PortId.Id)
			}
			// property: name=inactive, type=BOOLEAN macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Inactive = ValueBoolPointerFromPlanOrState(plan.EthernetPort.PortId.Inactive, state.EthernetPort.PortId.Inactive)
			} else {
				body.EthernetPort.PortId.Inactive = BoolValueOrNil(plan.EthernetPort.PortId.Inactive)
			}
			// property: name=inactive_reason, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.InactiveReason = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.InactiveReason, state.EthernetPort.PortId.InactiveReason)
			} else {
				body.EthernetPort.PortId.InactiveReason = StringValueOrNil(plan.EthernetPort.PortId.InactiveReason)
			}
			// property: name=max_mtu, type=INTEGER macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.MaxMtu = ValueInt64PointerFromPlanOrState(plan.EthernetPort.PortId.MaxMtu, state.EthernetPort.PortId.MaxMtu)
			} else {
				body.EthernetPort.PortId.MaxMtu = Int64ValueOrNil(plan.EthernetPort.PortId.MaxMtu)
			}
			// property: name=max_speed, type=INTEGER macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.MaxSpeed = ValueInt64PointerFromPlanOrState(plan.EthernetPort.PortId.MaxSpeed, state.EthernetPort.PortId.MaxSpeed)
			} else {
				body.EthernetPort.PortId.MaxSpeed = Int64ValueOrNil(plan.EthernetPort.PortId.MaxSpeed)
			}
			// property: name=name, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Name = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Name, state.EthernetPort.PortId.Name)
			} else {
				body.EthernetPort.PortId.Name = StringValueOrNil(plan.EthernetPort.PortId.Name)
			}
			// property: name=original_mac_address, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.OriginalMacAddress = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.OriginalMacAddress, state.EthernetPort.PortId.OriginalMacAddress)
			} else {
				body.EthernetPort.PortId.OriginalMacAddress = StringValueOrNil(plan.EthernetPort.PortId.OriginalMacAddress)
			}
			// property: name=region, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.Region = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Region, state.EthernetPort.PortId.Region)
			} else {
				body.EthernetPort.PortId.Region = StringValueOrNil(plan.EthernetPort.PortId.Region)
			}
			// property: name=site_id, type=STRING macro=copy_from_plan_or_state
			if state.EthernetPort.PortId != nil {
				body.EthernetPort.PortId.SiteId = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.SiteId, state.EthernetPort.PortId.SiteId)
			} else {
				body.EthernetPort.PortId.SiteId = StringValueOrNil(plan.EthernetPort.PortId.SiteId)
			}
		}
		// property: name=port_name, type=STRING macro=copy_from_plan_or_state
		if state.EthernetPort != nil {
			body.EthernetPort.PortName = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortName, state.EthernetPort.PortName)
		} else {
			body.EthernetPort.PortName = StringValueOrNil(plan.EthernetPort.PortName)
		}
		// property: name=speed, type=INTEGER macro=copy_from_plan_or_state
		if state.EthernetPort != nil {
			body.EthernetPort.Speed = ValueInt64PointerFromPlanOrState(plan.EthernetPort.Speed, state.EthernetPort.Speed)
		} else {
			body.EthernetPort.Speed = Int64ValueOrNil(plan.EthernetPort.Speed)
		}
	}
	// property: name=id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Id = ValueStringPointerFromPlanOrState(plan.Id, state.Id)
	} else {
		body.Id = StringValueOrNil(plan.Id)
	}
	// property: name=interface_profile_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.InterfaceProfileId = ValueStringPointerFromPlanOrState(plan.InterfaceProfileId, state.InterfaceProfileId)
	} else {
		body.InterfaceProfileId = StringValueOrNil(plan.InterfaceProfileId)
	}
	// property: name=ipfixcollectorcontext_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.IpfixcollectorcontextId = ValueStringPointerFromPlanOrState(plan.IpfixcollectorcontextId, state.IpfixcollectorcontextId)
	} else {
		body.IpfixcollectorcontextId = StringValueOrNil(plan.IpfixcollectorcontextId)
	}
	// property: name=ipfixfiltercontext_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.IpfixfiltercontextId = ValueStringPointerFromPlanOrState(plan.IpfixfiltercontextId, state.IpfixfiltercontextId)
	} else {
		body.IpfixfiltercontextId = StringValueOrNil(plan.IpfixfiltercontextId)
	}
	// property: name=ipv4_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.Ipv4Config == nil {
		body.Ipv4Config = nil
	} else {
		body.Ipv4Config = &sdwan_schema.Ipv4Config{}
		// copy_from_plan_or_state: body=body.Ipv4Config prefix=rsModel state=state.Ipv4Config plan=plan.Ipv4Config properties=6
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv4Config prefix=rsModel state=state.Ipv4Config plan=plan.Ipv4Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv4Config.DhcpConfig == nil {
			body.Ipv4Config.DhcpConfig = nil
		} else {
			body.Ipv4Config.DhcpConfig = &sdwan_schema.Ipv4Dhcp{}
			// copy_from_plan_or_state: body=body.Ipv4Config.DhcpConfig prefix=rsModel state=state.Ipv4Config.DhcpConfig plan=plan.Ipv4Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv4Config.DhcpConfig prefix=rsModel state=state.Ipv4Config.DhcpConfig plan=plan.Ipv4Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_from_plan_or_state
			if state.Ipv4Config.DhcpConfig != nil {
				body.Ipv4Config.DhcpConfig.ClientId = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpConfig.ClientId, state.Ipv4Config.DhcpConfig.ClientId)
			} else {
				body.Ipv4Config.DhcpConfig.ClientId = StringValueOrNil(plan.Ipv4Config.DhcpConfig.ClientId)
			}
			// property: name=hostname, type=STRING macro=copy_from_plan_or_state
			if state.Ipv4Config.DhcpConfig != nil {
				body.Ipv4Config.DhcpConfig.Hostname = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpConfig.Hostname, state.Ipv4Config.DhcpConfig.Hostname)
			} else {
				body.Ipv4Config.DhcpConfig.Hostname = StringValueOrNil(plan.Ipv4Config.DhcpConfig.Hostname)
			}
		}
		// property: name=dns_v4_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv4Config.DnsV4Config == nil {
			body.Ipv4Config.DnsV4Config = nil
		} else {
			body.Ipv4Config.DnsV4Config = &sdwan_schema.DNS{}
			// copy_from_plan_or_state: body=body.Ipv4Config.DnsV4Config prefix=rsModel state=state.Ipv4Config.DnsV4Config plan=plan.Ipv4Config.DnsV4Config properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv4Config.DnsV4Config prefix=rsModel state=state.Ipv4Config.DnsV4Config plan=plan.Ipv4Config.DnsV4Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
			body.Ipv4Config.DnsV4Config.NameServers = ListStringValueOrNil(ctx, plan.Ipv4Config.DnsV4Config.NameServers)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
			body.Ipv4Config.DnsV4Config.Search = ListStringValueOrNil(ctx, plan.Ipv4Config.DnsV4Config.Search)
		}
		// property: name=pppoe_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv4Config.PppoeConfig == nil {
			body.Ipv4Config.PppoeConfig = nil
		} else {
			body.Ipv4Config.PppoeConfig = &sdwan_schema.Ipv4Pppoe{}
			// copy_from_plan_or_state: body=body.Ipv4Config.PppoeConfig prefix=rsModel state=state.Ipv4Config.PppoeConfig plan=plan.Ipv4Config.PppoeConfig properties=3
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv4Config.PppoeConfig prefix=rsModel state=state.Ipv4Config.PppoeConfig plan=plan.Ipv4Config.PppoeConfig")
			// property: name=chap_passwd, type=STRING macro=copy_from_plan_or_state
			if state.Ipv4Config.PppoeConfig != nil {
				body.Ipv4Config.PppoeConfig.ChapPasswd = ValueStringPointerFromPlanOrState(plan.Ipv4Config.PppoeConfig.ChapPasswd, state.Ipv4Config.PppoeConfig.ChapPasswd)
			} else {
				body.Ipv4Config.PppoeConfig.ChapPasswd = StringValueOrNil(plan.Ipv4Config.PppoeConfig.ChapPasswd)
			}
			// property: name=chap_user, type=STRING macro=copy_from_plan_or_state
			if state.Ipv4Config.PppoeConfig != nil {
				body.Ipv4Config.PppoeConfig.ChapUser = ValueStringPointerFromPlanOrState(plan.Ipv4Config.PppoeConfig.ChapUser, state.Ipv4Config.PppoeConfig.ChapUser)
			} else {
				body.Ipv4Config.PppoeConfig.ChapUser = StringValueOrNil(plan.Ipv4Config.PppoeConfig.ChapUser)
			}
			// property: name=set_route, type=BOOLEAN macro=copy_from_plan_or_state
			if state.Ipv4Config.PppoeConfig != nil {
				body.Ipv4Config.PppoeConfig.SetRoute = ValueBoolPointerFromPlanOrState(plan.Ipv4Config.PppoeConfig.SetRoute, state.Ipv4Config.PppoeConfig.SetRoute)
			} else {
				body.Ipv4Config.PppoeConfig.SetRoute = BoolValueOrNil(plan.Ipv4Config.PppoeConfig.SetRoute)
			}
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv4Config.Routes == nil && (state.Ipv4Config == nil || state.Ipv4Config.Routes == nil) {
			body.Ipv4Config.Routes = nil
		} else if len(plan.Ipv4Config.Routes) == 0 && (state.Ipv4Config == nil || len(state.Ipv4Config.Routes) == 0) {
			body.Ipv4Config.Routes = []sdwan_schema.Route{}
		} else if len(plan.Ipv4Config.Routes) != 0 || (state.Ipv4Config != nil && len(state.Ipv4Config.Routes) != 0) {
			RoutesToUse := plan.Ipv4Config.Routes
			if len(plan.Ipv4Config.Routes) == 0 {
				RoutesToUse = state.Ipv4Config.Routes
			}
			body.Ipv4Config.Routes = make([]sdwan_schema.Route, 0, len(RoutesToUse))
			for varLoopRoutesIndex, varLoopRoutes := range RoutesToUse {
				// add a new item
				body.Ipv4Config.Routes = append(body.Ipv4Config.Routes, sdwan_schema.Route{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_from_plan body=body.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_from_plan
				body.Ipv4Config.Routes[varLoopRoutesIndex].Destination = StringValueOrNil(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_from_plan
				body.Ipv4Config.Routes[varLoopRoutesIndex].Via = StringValueOrNil(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv4Config.StaticConfig == nil {
			body.Ipv4Config.StaticConfig = nil
		} else {
			body.Ipv4Config.StaticConfig = &sdwan_schema.Ipv4Static{}
			// copy_from_plan_or_state: body=body.Ipv4Config.StaticConfig prefix=rsModel state=state.Ipv4Config.StaticConfig plan=plan.Ipv4Config.StaticConfig properties=1
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv4Config.StaticConfig prefix=rsModel state=state.Ipv4Config.StaticConfig plan=plan.Ipv4Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_from_plan_or_state
			if state.Ipv4Config.StaticConfig != nil {
				body.Ipv4Config.StaticConfig.Address = ValueStringPointerFromPlanOrState(plan.Ipv4Config.StaticConfig.Address, state.Ipv4Config.StaticConfig.Address)
			} else {
				body.Ipv4Config.StaticConfig.Address = StringValueOrNil(plan.Ipv4Config.StaticConfig.Address)
			}
		}
		// property: name=type, type=STRING macro=copy_from_plan_or_state
		if state.Ipv4Config != nil {
			body.Ipv4Config.Type = ValueStringPointerFromPlanOrState(plan.Ipv4Config.Type, state.Ipv4Config.Type)
		} else {
			body.Ipv4Config.Type = StringValueOrNil(plan.Ipv4Config.Type)
		}
	}
	// property: name=ipv6_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.Ipv6Config == nil {
		body.Ipv6Config = nil
	} else {
		body.Ipv6Config = &sdwan_schema.Ipv6ConfigV1{}
		// copy_from_plan_or_state: body=body.Ipv6Config prefix=rsModel state=state.Ipv6Config plan=plan.Ipv6Config properties=5
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv6Config prefix=rsModel state=state.Ipv6Config plan=plan.Ipv6Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv6Config.DhcpConfig == nil {
			body.Ipv6Config.DhcpConfig = nil
		} else {
			body.Ipv6Config.DhcpConfig = &sdwan_schema.Ipv6Dhcp{}
			// copy_from_plan_or_state: body=body.Ipv6Config.DhcpConfig prefix=rsModel state=state.Ipv6Config.DhcpConfig plan=plan.Ipv6Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv6Config.DhcpConfig prefix=rsModel state=state.Ipv6Config.DhcpConfig plan=plan.Ipv6Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_from_plan_or_state
			if state.Ipv6Config.DhcpConfig != nil {
				body.Ipv6Config.DhcpConfig.ClientId = ValueStringPointerFromPlanOrState(plan.Ipv6Config.DhcpConfig.ClientId, state.Ipv6Config.DhcpConfig.ClientId)
			} else {
				body.Ipv6Config.DhcpConfig.ClientId = StringValueOrNil(plan.Ipv6Config.DhcpConfig.ClientId)
			}
			// property: name=hostname, type=STRING macro=copy_from_plan_or_state
			if state.Ipv6Config.DhcpConfig != nil {
				body.Ipv6Config.DhcpConfig.Hostname = ValueStringPointerFromPlanOrState(plan.Ipv6Config.DhcpConfig.Hostname, state.Ipv6Config.DhcpConfig.Hostname)
			} else {
				body.Ipv6Config.DhcpConfig.Hostname = StringValueOrNil(plan.Ipv6Config.DhcpConfig.Hostname)
			}
		}
		// property: name=dns_v6_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv6Config.DnsV6Config == nil {
			body.Ipv6Config.DnsV6Config = nil
		} else {
			body.Ipv6Config.DnsV6Config = &sdwan_schema.DNS{}
			// copy_from_plan_or_state: body=body.Ipv6Config.DnsV6Config prefix=rsModel state=state.Ipv6Config.DnsV6Config plan=plan.Ipv6Config.DnsV6Config properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv6Config.DnsV6Config prefix=rsModel state=state.Ipv6Config.DnsV6Config plan=plan.Ipv6Config.DnsV6Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
			body.Ipv6Config.DnsV6Config.NameServers = ListStringValueOrNil(ctx, plan.Ipv6Config.DnsV6Config.NameServers)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
			body.Ipv6Config.DnsV6Config.Search = ListStringValueOrNil(ctx, plan.Ipv6Config.DnsV6Config.Search)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv6Config.Routes == nil && (state.Ipv6Config == nil || state.Ipv6Config.Routes == nil) {
			body.Ipv6Config.Routes = nil
		} else if len(plan.Ipv6Config.Routes) == 0 && (state.Ipv6Config == nil || len(state.Ipv6Config.Routes) == 0) {
			body.Ipv6Config.Routes = []sdwan_schema.Route{}
		} else if len(plan.Ipv6Config.Routes) != 0 || (state.Ipv6Config != nil && len(state.Ipv6Config.Routes) != 0) {
			RoutesToUse := plan.Ipv6Config.Routes
			if len(plan.Ipv6Config.Routes) == 0 {
				RoutesToUse = state.Ipv6Config.Routes
			}
			body.Ipv6Config.Routes = make([]sdwan_schema.Route, 0, len(RoutesToUse))
			for varLoopRoutesIndex, varLoopRoutes := range RoutesToUse {
				// add a new item
				body.Ipv6Config.Routes = append(body.Ipv6Config.Routes, sdwan_schema.Route{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_from_plan body=body.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel plan=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_from_plan
				body.Ipv6Config.Routes[varLoopRoutesIndex].Destination = StringValueOrNil(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_from_plan
				body.Ipv6Config.Routes[varLoopRoutesIndex].Via = StringValueOrNil(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.Ipv6Config.StaticConfig == nil {
			body.Ipv6Config.StaticConfig = nil
		} else {
			body.Ipv6Config.StaticConfig = &sdwan_schema.Ipv6StaticV1{}
			// copy_from_plan_or_state: body=body.Ipv6Config.StaticConfig prefix=rsModel state=state.Ipv6Config.StaticConfig plan=plan.Ipv6Config.StaticConfig properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.Ipv6Config.StaticConfig prefix=rsModel state=state.Ipv6Config.StaticConfig plan=plan.Ipv6Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_from_plan_or_state
			if state.Ipv6Config.StaticConfig != nil {
				body.Ipv6Config.StaticConfig.Address = ValueStringPointerFromPlanOrState(plan.Ipv6Config.StaticConfig.Address, state.Ipv6Config.StaticConfig.Address)
			} else {
				body.Ipv6Config.StaticConfig.Address = StringValueOrNil(plan.Ipv6Config.StaticConfig.Address)
			}
			// property: name=enable_prefix_distribution, type=BOOLEAN macro=copy_from_plan_or_state
			if state.Ipv6Config.StaticConfig != nil {
				body.Ipv6Config.StaticConfig.EnablePrefixDistribution = ValueBoolPointerFromPlanOrState(plan.Ipv6Config.StaticConfig.EnablePrefixDistribution, state.Ipv6Config.StaticConfig.EnablePrefixDistribution)
			} else {
				body.Ipv6Config.StaticConfig.EnablePrefixDistribution = BoolValueOrNil(plan.Ipv6Config.StaticConfig.EnablePrefixDistribution)
			}
		}
		// property: name=type, type=STRING macro=copy_from_plan_or_state
		if state.Ipv6Config != nil {
			body.Ipv6Config.Type = ValueStringPointerFromPlanOrState(plan.Ipv6Config.Type, state.Ipv6Config.Type)
		} else {
			body.Ipv6Config.Type = StringValueOrNil(plan.Ipv6Config.Type)
		}
	}
	// property: name=lldp_enabled, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.LldpEnabled = ValueBoolPointerFromPlanOrState(plan.LldpEnabled, state.LldpEnabled)
	} else {
		body.LldpEnabled = BoolValueOrNil(plan.LldpEnabled)
	}
	// property: name=mac_address, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.MacAddress = ValueStringPointerFromPlanOrState(plan.MacAddress, state.MacAddress)
	} else {
		body.MacAddress = StringValueOrNil(plan.MacAddress)
	}
	// property: name=mtu, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Mtu = ValueInt64PointerFromPlanOrState(plan.Mtu, state.Mtu)
	} else {
		body.Mtu = Int64ValueOrNil(plan.Mtu)
	}
	// property: name=multicast_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.MulticastConfig == nil {
		body.MulticastConfig = nil
	} else {
		body.MulticastConfig = &sdwan_schema.MulticastInterfaceConfig{}
		// copy_from_plan_or_state: body=body.MulticastConfig prefix=rsModel state=state.MulticastConfig plan=plan.MulticastConfig properties=4
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.MulticastConfig prefix=rsModel state=state.MulticastConfig plan=plan.MulticastConfig")
		// property: name=dr_priority, type=INTEGER macro=copy_from_plan_or_state
		if state.MulticastConfig != nil {
			body.MulticastConfig.DrPriority = ValueInt64PointerFromPlanOrState(plan.MulticastConfig.DrPriority, state.MulticastConfig.DrPriority)
		} else {
			body.MulticastConfig.DrPriority = Int64ValueOrNil(plan.MulticastConfig.DrPriority)
		}
		// property: name=igmp_static_joins, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.MulticastConfig.IgmpStaticJoins == nil && (state.MulticastConfig == nil || state.MulticastConfig.IgmpStaticJoins == nil) {
			body.MulticastConfig.IgmpStaticJoins = nil
		} else if len(plan.MulticastConfig.IgmpStaticJoins) == 0 && (state.MulticastConfig == nil || len(state.MulticastConfig.IgmpStaticJoins) == 0) {
			body.MulticastConfig.IgmpStaticJoins = []sdwan_schema.MulticastIgmpStaticJoin{}
		} else if len(plan.MulticastConfig.IgmpStaticJoins) != 0 || (state.MulticastConfig != nil && len(state.MulticastConfig.IgmpStaticJoins) != 0) {
			IgmpStaticJoinsToUse := plan.MulticastConfig.IgmpStaticJoins
			if len(plan.MulticastConfig.IgmpStaticJoins) == 0 {
				IgmpStaticJoinsToUse = state.MulticastConfig.IgmpStaticJoins
			}
			body.MulticastConfig.IgmpStaticJoins = make([]sdwan_schema.MulticastIgmpStaticJoin, 0, len(IgmpStaticJoinsToUse))
			for varLoopIgmpStaticJoinsIndex, varLoopIgmpStaticJoins := range IgmpStaticJoinsToUse {
				// add a new item
				body.MulticastConfig.IgmpStaticJoins = append(body.MulticastConfig.IgmpStaticJoins, sdwan_schema.MulticastIgmpStaticJoin{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel plan=varLoopIgmpStaticJoins properties=2
				tflog.Debug(ctx, "copy_from_plan body=body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel plan=varLoopIgmpStaticJoins")
				// property: name=igmp_static_grp_ipv4, type=STRING macro=copy_from_plan
				body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticGrpIpv4 = StringValueOrNil(varLoopIgmpStaticJoins.IgmpStaticGrpIpv4)
				// property: name=igmp_static_src_ipv4, type=STRING macro=copy_from_plan
				body.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticSrcIpv4 = StringValueOrNil(varLoopIgmpStaticJoins.IgmpStaticSrcIpv4)
			}
		}
		// property: name=igmp_version, type=STRING macro=copy_from_plan_or_state
		if state.MulticastConfig != nil {
			body.MulticastConfig.IgmpVersion = ValueStringPointerFromPlanOrState(plan.MulticastConfig.IgmpVersion, state.MulticastConfig.IgmpVersion)
		} else {
			body.MulticastConfig.IgmpVersion = StringValueOrNil(plan.MulticastConfig.IgmpVersion)
		}
		// property: name=multicast_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.MulticastConfig != nil {
			body.MulticastConfig.MulticastEnabled = ValueBoolPointerFromPlanOrState(plan.MulticastConfig.MulticastEnabled, state.MulticastConfig.MulticastEnabled)
		} else {
			body.MulticastConfig.MulticastEnabled = BoolValueOrNil(plan.MulticastConfig.MulticastEnabled)
		}
	}
	// property: name=name, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Name = ValueStringPointerFromPlanOrState(plan.Name, state.Name)
	} else {
		body.Name = StringValueOrNil(plan.Name)
	}
	// property: name=nat_address, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.NatAddress = ValueStringPointerFromPlanOrState(plan.NatAddress, state.NatAddress)
	} else {
		body.NatAddress = StringValueOrNil(plan.NatAddress)
	}
	// property: name=nat_address_v6, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.NatAddressV6 = ValueStringPointerFromPlanOrState(plan.NatAddressV6, state.NatAddressV6)
	} else {
		body.NatAddressV6 = StringValueOrNil(plan.NatAddressV6)
	}
	// property: name=nat_pools, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
	if plan.NatPools == nil && (state == nil || state.NatPools == nil) {
		body.NatPools = nil
	} else if len(plan.NatPools) == 0 && (state == nil || len(state.NatPools) == 0) {
		body.NatPools = []sdwan_schema.NatPool{}
	} else if len(plan.NatPools) != 0 || (state != nil && len(state.NatPools) != 0) {
		NatPoolsToUse := plan.NatPools
		if len(plan.NatPools) == 0 {
			NatPoolsToUse = state.NatPools
		}
		body.NatPools = make([]sdwan_schema.NatPool, 0, len(NatPoolsToUse))
		for varLoopNatPoolsIndex, varLoopNatPools := range NatPoolsToUse {
			// add a new item
			body.NatPools = append(body.NatPools, sdwan_schema.NatPool{})
			// since we have chosen to stick with either the plan or state, we need to simply copy child properties
			// copy_from_plan: body=body.NatPools[varLoopNatPoolsIndex] prefix=rsModel plan=varLoopNatPools properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.NatPools[varLoopNatPoolsIndex] prefix=rsModel plan=varLoopNatPools")
			// property: name=ipv4_ranges, type=ARRAY_REFERENCE macro=copy_from_plan
			if varLoopNatPools.Ipv4Ranges == nil {
				body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = nil
			} else if len(varLoopNatPools.Ipv4Ranges) == 0 {
				body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = []sdwan_schema.IPv4Range{}
			} else {
				body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = make([]sdwan_schema.IPv4Range, 0, len(varLoopNatPools.Ipv4Ranges))
				for varLoopIpv4RangesIndex, varLoopIpv4Ranges := range varLoopNatPools.Ipv4Ranges {
					// add a new item
					body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = append(body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges, sdwan_schema.IPv4Range{})
					// copy_from_plan: body=body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel plan=varLoopIpv4Ranges properties=2
					tflog.Debug(ctx, "copy_from_plan body=body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel plan=varLoopIpv4Ranges")
					// property: name=end, type=STRING macro=copy_from_plan
					body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].End = StringValueOrNil(varLoopIpv4Ranges.End)
					// property: name=start, type=STRING macro=copy_from_plan
					body.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].Start = StringValueOrNil(varLoopIpv4Ranges.Start)
				}
			}
			// property: name=nat_pool_id, type=STRING macro=copy_from_plan
			body.NatPools[varLoopNatPoolsIndex].NatPoolId = StringValueOrNil(varLoopNatPools.NatPoolId)
		}
	}
	// property: name=nat_port, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.NatPort = ValueInt64PointerFromPlanOrState(plan.NatPort, state.NatPort)
	} else {
		body.NatPort = Int64ValueOrNil(plan.NatPort)
	}
	// property: name=nat_port_v6, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.NatPortV6 = ValueInt64PointerFromPlanOrState(plan.NatPortV6, state.NatPortV6)
	} else {
		body.NatPortV6 = Int64ValueOrNil(plan.NatPortV6)
	}
	// property: name=nat_zone_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.NatZoneId = ValueStringPointerFromPlanOrState(plan.NatZoneId, state.NatZoneId)
	} else {
		body.NatZoneId = StringValueOrNil(plan.NatZoneId)
	}
	// property: name=network_context_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.NetworkContextId = ValueStringPointerFromPlanOrState(plan.NetworkContextId, state.NetworkContextId)
	} else {
		body.NetworkContextId = StringValueOrNil(plan.NetworkContextId)
	}
	// property: name=parent, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Parent = ValueStringPointerFromPlanOrState(plan.Parent, state.Parent)
	} else {
		body.Parent = StringValueOrNil(plan.Parent)
	}
	// property: name=peer_bypasspair_wan_port_type, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.PeerBypasspairWanPortType = ValueStringPointerFromPlanOrState(plan.PeerBypasspairWanPortType, state.PeerBypasspairWanPortType)
	} else {
		body.PeerBypasspairWanPortType = StringValueOrNil(plan.PeerBypasspairWanPortType)
	}
	// property: name=poe_enabled, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.PoeEnabled = ValueBoolPointerFromPlanOrState(plan.PoeEnabled, state.PoeEnabled)
	} else {
		body.PoeEnabled = BoolValueOrNil(plan.PoeEnabled)
	}
	// property: name=port_channel_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.PortChannelConfig == nil {
		body.PortChannelConfig = nil
	} else {
		body.PortChannelConfig = &sdwan_schema.PortChannelConfig{}
		// copy_from_plan_or_state: body=body.PortChannelConfig prefix=rsModel state=state.PortChannelConfig plan=plan.PortChannelConfig properties=2
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.PortChannelConfig prefix=rsModel state=state.PortChannelConfig plan=plan.PortChannelConfig")
		// property: name=lacp_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.PortChannelConfig != nil {
			body.PortChannelConfig.LacpEnabled = ValueBoolPointerFromPlanOrState(plan.PortChannelConfig.LacpEnabled, state.PortChannelConfig.LacpEnabled)
		} else {
			body.PortChannelConfig.LacpEnabled = BoolValueOrNil(plan.PortChannelConfig.LacpEnabled)
		}
		// property: name=transmission_mode, type=STRING macro=copy_from_plan_or_state
		if state.PortChannelConfig != nil {
			body.PortChannelConfig.TransmissionMode = ValueStringPointerFromPlanOrState(plan.PortChannelConfig.TransmissionMode, state.PortChannelConfig.TransmissionMode)
		} else {
			body.PortChannelConfig.TransmissionMode = StringValueOrNil(plan.PortChannelConfig.TransmissionMode)
		}
	}
	// property: name=power_usage_threshold, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.PowerUsageThreshold = ValueInt64PointerFromPlanOrState(plan.PowerUsageThreshold, state.PowerUsageThreshold)
	} else {
		body.PowerUsageThreshold = Int64ValueOrNil(plan.PowerUsageThreshold)
	}
	// property: name=pppoe_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.PppoeConfig == nil {
		body.PppoeConfig = nil
	} else {
		body.PppoeConfig = &sdwan_schema.PppoEInterfaceConfig{}
		// copy_from_plan_or_state: body=body.PppoeConfig prefix=rsModel state=state.PppoeConfig plan=plan.PppoeConfig properties=6
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.PppoeConfig prefix=rsModel state=state.PppoeConfig plan=plan.PppoeConfig")
		// property: name=host_uniq, type=STRING macro=copy_from_plan_or_state
		if state.PppoeConfig != nil {
			body.PppoeConfig.HostUniq = ValueStringPointerFromPlanOrState(plan.PppoeConfig.HostUniq, state.PppoeConfig.HostUniq)
		} else {
			body.PppoeConfig.HostUniq = StringValueOrNil(plan.PppoeConfig.HostUniq)
		}
		// property: name=ip_address_type, type=STRING macro=copy_from_plan_or_state
		if state.PppoeConfig != nil {
			body.PppoeConfig.IpAddressType = ValueStringPointerFromPlanOrState(plan.PppoeConfig.IpAddressType, state.PppoeConfig.IpAddressType)
		} else {
			body.PppoeConfig.IpAddressType = StringValueOrNil(plan.PppoeConfig.IpAddressType)
		}
		// property: name=password, type=STRING macro=copy_from_plan_or_state
		if state.PppoeConfig != nil {
			body.PppoeConfig.Password = ValueStringPointerFromPlanOrState(plan.PppoeConfig.Password, state.PppoeConfig.Password)
		} else {
			body.PppoeConfig.Password = StringValueOrNil(plan.PppoeConfig.Password)
		}
		// property: name=reconnection_delay, type=INTEGER macro=copy_from_plan_or_state
		if state.PppoeConfig != nil {
			body.PppoeConfig.ReconnectionDelay = ValueInt64PointerFromPlanOrState(plan.PppoeConfig.ReconnectionDelay, state.PppoeConfig.ReconnectionDelay)
		} else {
			body.PppoeConfig.ReconnectionDelay = Int64ValueOrNil(plan.PppoeConfig.ReconnectionDelay)
		}
		// property: name=service_name, type=STRING macro=copy_from_plan_or_state
		if state.PppoeConfig != nil {
			body.PppoeConfig.ServiceName = ValueStringPointerFromPlanOrState(plan.PppoeConfig.ServiceName, state.PppoeConfig.ServiceName)
		} else {
			body.PppoeConfig.ServiceName = StringValueOrNil(plan.PppoeConfig.ServiceName)
		}
		// property: name=username, type=STRING macro=copy_from_plan_or_state
		if state.PppoeConfig != nil {
			body.PppoeConfig.Username = ValueStringPointerFromPlanOrState(plan.PppoeConfig.Username, state.PppoeConfig.Username)
		} else {
			body.PppoeConfig.Username = StringValueOrNil(plan.PppoeConfig.Username)
		}
	}
	// property: name=scope, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Scope = ValueStringPointerFromPlanOrState(plan.Scope, state.Scope)
	} else {
		body.Scope = StringValueOrNil(plan.Scope)
	}
	// property: name=secondary_ip_configs, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
	if plan.SecondaryIpConfigs == nil && (state == nil || state.SecondaryIpConfigs == nil) {
		body.SecondaryIpConfigs = nil
	} else if len(plan.SecondaryIpConfigs) == 0 && (state == nil || len(state.SecondaryIpConfigs) == 0) {
		body.SecondaryIpConfigs = []sdwan_schema.SecondaryIPConfig{}
	} else if len(plan.SecondaryIpConfigs) != 0 || (state != nil && len(state.SecondaryIpConfigs) != 0) {
		SecondaryIpConfigsToUse := plan.SecondaryIpConfigs
		if len(plan.SecondaryIpConfigs) == 0 {
			SecondaryIpConfigsToUse = state.SecondaryIpConfigs
		}
		body.SecondaryIpConfigs = make([]sdwan_schema.SecondaryIPConfig, 0, len(SecondaryIpConfigsToUse))
		for varLoopSecondaryIpConfigsIndex, varLoopSecondaryIpConfigs := range SecondaryIpConfigsToUse {
			// add a new item
			body.SecondaryIpConfigs = append(body.SecondaryIpConfigs, sdwan_schema.SecondaryIPConfig{})
			// since we have chosen to stick with either the plan or state, we need to simply copy child properties
			// copy_from_plan: body=body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel plan=varLoopSecondaryIpConfigs properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel plan=varLoopSecondaryIpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_from_plan
			body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Ipv4Address = StringValueOrNil(varLoopSecondaryIpConfigs.Ipv4Address)
			// property: name=scope, type=STRING macro=copy_from_plan
			body.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Scope = StringValueOrNil(varLoopSecondaryIpConfigs.Scope)
		}
	}
	// property: name=service_link_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.ServiceLinkConfig == nil {
		body.ServiceLinkConfig = nil
	} else {
		body.ServiceLinkConfig = &sdwan_schema.ServiceLinkV4{}
		// copy_from_plan_or_state: body=body.ServiceLinkConfig prefix=rsModel state=state.ServiceLinkConfig plan=plan.ServiceLinkConfig properties=8
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig prefix=rsModel state=state.ServiceLinkConfig plan=plan.ServiceLinkConfig")
		// property: name=gre_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.ServiceLinkConfig.GreConfig == nil {
			body.ServiceLinkConfig.GreConfig = nil
		} else {
			body.ServiceLinkConfig.GreConfig = &sdwan_schema.GREConfig{}
			// copy_from_plan_or_state: body=body.ServiceLinkConfig.GreConfig prefix=rsModel state=state.ServiceLinkConfig.GreConfig plan=plan.ServiceLinkConfig.GreConfig properties=4
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig.GreConfig prefix=rsModel state=state.ServiceLinkConfig.GreConfig plan=plan.ServiceLinkConfig.GreConfig")
			// property: name=csum, type=BOOLEAN macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.GreConfig != nil {
				body.ServiceLinkConfig.GreConfig.Csum = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.Csum, state.ServiceLinkConfig.GreConfig.Csum)
			} else {
				body.ServiceLinkConfig.GreConfig.Csum = BoolValueOrNil(plan.ServiceLinkConfig.GreConfig.Csum)
			}
			// property: name=keepalive_enable, type=BOOLEAN macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.GreConfig != nil {
				body.ServiceLinkConfig.GreConfig.KeepaliveEnable = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.KeepaliveEnable, state.ServiceLinkConfig.GreConfig.KeepaliveEnable)
			} else {
				body.ServiceLinkConfig.GreConfig.KeepaliveEnable = BoolValueOrNil(plan.ServiceLinkConfig.GreConfig.KeepaliveEnable)
			}
			// property: name=keepalive_fail_count, type=INTEGER macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.GreConfig != nil {
				body.ServiceLinkConfig.GreConfig.KeepaliveFailCount = ValueInt64PointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.KeepaliveFailCount, state.ServiceLinkConfig.GreConfig.KeepaliveFailCount)
			} else {
				body.ServiceLinkConfig.GreConfig.KeepaliveFailCount = Int64ValueOrNil(plan.ServiceLinkConfig.GreConfig.KeepaliveFailCount)
			}
			// property: name=keepalive_interval, type=INTEGER macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.GreConfig != nil {
				body.ServiceLinkConfig.GreConfig.KeepaliveInterval = ValueInt64PointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.KeepaliveInterval, state.ServiceLinkConfig.GreConfig.KeepaliveInterval)
			} else {
				body.ServiceLinkConfig.GreConfig.KeepaliveInterval = Int64ValueOrNil(plan.ServiceLinkConfig.GreConfig.KeepaliveInterval)
			}
		}
		// property: name=ipsec_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.ServiceLinkConfig.IpsecConfig == nil {
			body.ServiceLinkConfig.IpsecConfig = nil
		} else {
			body.ServiceLinkConfig.IpsecConfig = &sdwan_schema.IPSECConfigV1{}
			// copy_from_plan_or_state: body=body.ServiceLinkConfig.IpsecConfig prefix=rsModel state=state.ServiceLinkConfig.IpsecConfig plan=plan.ServiceLinkConfig.IpsecConfig properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig.IpsecConfig prefix=rsModel state=state.ServiceLinkConfig.IpsecConfig plan=plan.ServiceLinkConfig.IpsecConfig")
			// property: name=authentication, type=REFERENCE macro=copy_from_plan_or_state
			if plan.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				body.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				body.ServiceLinkConfig.IpsecConfig.Authentication = &sdwan_schema.IPSECAuthenticationV1{}
				// copy_from_plan_or_state: body=body.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel state=state.ServiceLinkConfig.IpsecConfig.Authentication plan=plan.ServiceLinkConfig.IpsecConfig.Authentication properties=22
				tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel state=state.ServiceLinkConfig.IpsecConfig.Authentication plan=plan.ServiceLinkConfig.IpsecConfig.Authentication")
				// property: name=certificate, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Certificate, state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)
				}
				// property: name=certificate_profile_id, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId, state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)
				}
				// property: name=comment, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Comment = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Comment, state.ServiceLinkConfig.IpsecConfig.Authentication.Comment)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Comment = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Comment)
				}
				// property: name=ikev1_params, type=REFERENCE macro=copy_from_plan_or_state
				if plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &sdwan_schema.IKEV1Params{}
					// copy_from_plan_or_state: body=body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params plan=plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params properties=5
					tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params plan=plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params")
					// property: name=xauth_id, type=STRING macro=copy_from_plan_or_state
					if state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)
					} else {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)
					}
					// property: name=xauth_secret, type=STRING macro=copy_from_plan_or_state
					if state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)
					} else {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)
					}
					// property: name=xauth_secret_encrypted, type=STRING macro=copy_from_plan_or_state
					if state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)
					} else {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)
					}
					// property: name=xauth_secret_hash, type=STRING macro=copy_from_plan_or_state
					if state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)
					} else {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)
					}
					// property: name=xauth_type, type=STRING macro=copy_from_plan_or_state
					if state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
					} else {
						body.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
					}
				}
				// property: name=local_ca_certificate, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)
				}
				// property: name=local_id, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalId, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)
				}
				// property: name=local_id_custom, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)
				}
				// property: name=local_pa_certificate_id, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)
				}
				// property: name=pa_master_key_id, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId, state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)
				}
				// property: name=passphrase, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase, state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)
				}
				// property: name=passphrase_encrypted, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)
				}
				// property: name=peer_id_check, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck, state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)
				}
				// property: name=permit_peer_id_mismatch, type=BOOLEAN macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch, state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = BoolValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)
				}
				// property: name=private_key, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey, state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)
				}
				// property: name=private_key_encrypted, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)
				}
				// property: name=remote_ca_certificate, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate, state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)
				}
				// property: name=remote_id, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId, state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)
				}
				// property: name=secret, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Secret = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Secret, state.ServiceLinkConfig.IpsecConfig.Authentication.Secret)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Secret = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Secret)
				}
				// property: name=secret_encrypted, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)
				}
				// property: name=secret_hash, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)
				}
				// property: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse, state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = BoolValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)
				}
				// property: name=type, type=STRING macro=copy_from_plan_or_state
				if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Type = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Type, state.ServiceLinkConfig.IpsecConfig.Authentication.Type)
				} else {
					body.ServiceLinkConfig.IpsecConfig.Authentication.Type = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.Authentication.Type)
				}
			}
			// property: name=ipsec_profile_id, type=STRING macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.IpsecConfig != nil {
				body.ServiceLinkConfig.IpsecConfig.IpsecProfileId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.IpsecProfileId, state.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
			} else {
				body.ServiceLinkConfig.IpsecConfig.IpsecProfileId = StringValueOrNil(plan.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
			}
		}
		// property: name=last_parent, type=STRING macro=copy_from_plan_or_state
		if state.ServiceLinkConfig != nil {
			body.ServiceLinkConfig.LastParent = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.LastParent, state.ServiceLinkConfig.LastParent)
		} else {
			body.ServiceLinkConfig.LastParent = StringValueOrNil(plan.ServiceLinkConfig.LastParent)
		}
		// property: name=parent, type=STRING macro=copy_from_plan_or_state
		if state.ServiceLinkConfig != nil {
			body.ServiceLinkConfig.Parent = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.Parent, state.ServiceLinkConfig.Parent)
		} else {
			body.ServiceLinkConfig.Parent = StringValueOrNil(plan.ServiceLinkConfig.Parent)
		}
		// property: name=passive_mode, type=REFERENCE macro=copy_from_plan_or_state
		if plan.ServiceLinkConfig.PassiveMode == nil {
			body.ServiceLinkConfig.PassiveMode = nil
		} else {
			body.ServiceLinkConfig.PassiveMode = &sdwan_schema.PassiveMode{}
			// copy_from_plan_or_state: body=body.ServiceLinkConfig.PassiveMode prefix=rsModel state=state.ServiceLinkConfig.PassiveMode plan=plan.ServiceLinkConfig.PassiveMode properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig.PassiveMode prefix=rsModel state=state.ServiceLinkConfig.PassiveMode plan=plan.ServiceLinkConfig.PassiveMode")
			// property: name=enable, type=BOOLEAN macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.PassiveMode != nil {
				body.ServiceLinkConfig.PassiveMode.Enable = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.PassiveMode.Enable, state.ServiceLinkConfig.PassiveMode.Enable)
			} else {
				body.ServiceLinkConfig.PassiveMode.Enable = BoolValueOrNil(plan.ServiceLinkConfig.PassiveMode.Enable)
			}
			// property: name=peer_ip_dynamic, type=BOOLEAN macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.PassiveMode != nil {
				body.ServiceLinkConfig.PassiveMode.PeerIpDynamic = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.PassiveMode.PeerIpDynamic, state.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
			} else {
				body.ServiceLinkConfig.PassiveMode.PeerIpDynamic = BoolValueOrNil(plan.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
			}
		}
		// property: name=peer, type=REFERENCE macro=copy_from_plan_or_state
		if plan.ServiceLinkConfig.Peer == nil {
			body.ServiceLinkConfig.Peer = nil
		} else {
			body.ServiceLinkConfig.Peer = &sdwan_schema.PeerInfo{}
			// copy_from_plan_or_state: body=body.ServiceLinkConfig.Peer prefix=rsModel state=state.ServiceLinkConfig.Peer plan=plan.ServiceLinkConfig.Peer properties=2
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.ServiceLinkConfig.Peer prefix=rsModel state=state.ServiceLinkConfig.Peer plan=plan.ServiceLinkConfig.Peer")
			// property: name=hostname, type=STRING macro=copy_from_plan_or_state
			if state.ServiceLinkConfig.Peer != nil {
				body.ServiceLinkConfig.Peer.Hostname = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.Peer.Hostname, state.ServiceLinkConfig.Peer.Hostname)
			} else {
				body.ServiceLinkConfig.Peer.Hostname = StringValueOrNil(plan.ServiceLinkConfig.Peer.Hostname)
			}
			// property: name=ip_addresses, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
			body.ServiceLinkConfig.Peer.IpAddresses = ListStringValueOrNil(ctx, plan.ServiceLinkConfig.Peer.IpAddresses)
		}
		// property: name=service_endpoint_id, type=STRING macro=copy_from_plan_or_state
		if state.ServiceLinkConfig != nil {
			body.ServiceLinkConfig.ServiceEndpointId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.ServiceEndpointId, state.ServiceLinkConfig.ServiceEndpointId)
		} else {
			body.ServiceLinkConfig.ServiceEndpointId = StringValueOrNil(plan.ServiceLinkConfig.ServiceEndpointId)
		}
		// property: name=type, type=STRING macro=copy_from_plan_or_state
		if state.ServiceLinkConfig != nil {
			body.ServiceLinkConfig.Type = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.Type, state.ServiceLinkConfig.Type)
		} else {
			body.ServiceLinkConfig.Type = StringValueOrNil(plan.ServiceLinkConfig.Type)
		}
	}
	// property: name=sgi_apply_static_tag, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.SgiApplyStaticTag = ValueBoolPointerFromPlanOrState(plan.SgiApplyStaticTag, state.SgiApplyStaticTag)
	} else {
		body.SgiApplyStaticTag = BoolValueOrNil(plan.SgiApplyStaticTag)
	}
	// property: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
	body.SiteWanInterfaceIds = ListStringValueOrNil(ctx, plan.SiteWanInterfaceIds)
	// property: name=static_arp_configs, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
	if plan.StaticArpConfigs == nil && (state == nil || state.StaticArpConfigs == nil) {
		body.StaticArpConfigs = nil
	} else if len(plan.StaticArpConfigs) == 0 && (state == nil || len(state.StaticArpConfigs) == 0) {
		body.StaticArpConfigs = []sdwan_schema.StaticARPConfig{}
	} else if len(plan.StaticArpConfigs) != 0 || (state != nil && len(state.StaticArpConfigs) != 0) {
		StaticArpConfigsToUse := plan.StaticArpConfigs
		if len(plan.StaticArpConfigs) == 0 {
			StaticArpConfigsToUse = state.StaticArpConfigs
		}
		body.StaticArpConfigs = make([]sdwan_schema.StaticARPConfig, 0, len(StaticArpConfigsToUse))
		for varLoopStaticArpConfigsIndex, varLoopStaticArpConfigs := range StaticArpConfigsToUse {
			// add a new item
			body.StaticArpConfigs = append(body.StaticArpConfigs, sdwan_schema.StaticARPConfig{})
			// since we have chosen to stick with either the plan or state, we need to simply copy child properties
			// copy_from_plan: body=body.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel plan=varLoopStaticArpConfigs properties=2
			tflog.Debug(ctx, "copy_from_plan body=body.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel plan=varLoopStaticArpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_from_plan
			body.StaticArpConfigs[varLoopStaticArpConfigsIndex].Ipv4Address = StringValueOrNil(varLoopStaticArpConfigs.Ipv4Address)
			// property: name=mac_address, type=STRING macro=copy_from_plan
			body.StaticArpConfigs[varLoopStaticArpConfigsIndex].MacAddress = StringValueOrNil(varLoopStaticArpConfigs.MacAddress)
		}
	}
	// property: name=sub_interface, type=REFERENCE macro=copy_from_plan_or_state
	if plan.SubInterface == nil {
		body.SubInterface = nil
	} else {
		body.SubInterface = &sdwan_schema.SubInterface{}
		// copy_from_plan_or_state: body=body.SubInterface prefix=rsModel state=state.SubInterface plan=plan.SubInterface properties=1
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.SubInterface prefix=rsModel state=state.SubInterface plan=plan.SubInterface")
		// property: name=vlan_id, type=INTEGER macro=copy_from_plan_or_state
		if state.SubInterface != nil {
			body.SubInterface.VlanId = ValueInt64PointerFromPlanOrState(plan.SubInterface.VlanId, state.SubInterface.VlanId)
		} else {
			body.SubInterface.VlanId = Int64ValueOrNil(plan.SubInterface.VlanId)
		}
	}
	// property: name=switch_port_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.SwitchPortConfig == nil {
		body.SwitchPortConfig = nil
	} else {
		body.SwitchPortConfig = &sdwan_schema.SwitchPortConfig{}
		// copy_from_plan_or_state: body=body.SwitchPortConfig prefix=rsModel state=state.SwitchPortConfig plan=plan.SwitchPortConfig properties=12
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.SwitchPortConfig prefix=rsModel state=state.SwitchPortConfig plan=plan.SwitchPortConfig")
		// property: name=access_vlan_id, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.AccessVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.AccessVlanId, state.SwitchPortConfig.AccessVlanId)
		} else {
			body.SwitchPortConfig.AccessVlanId = Int64ValueOrNil(plan.SwitchPortConfig.AccessVlanId)
		}
		// property: name=bpdu_guard_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.BpduGuardEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.BpduGuardEnabled, state.SwitchPortConfig.BpduGuardEnabled)
		} else {
			body.SwitchPortConfig.BpduGuardEnabled = BoolValueOrNil(plan.SwitchPortConfig.BpduGuardEnabled)
		}
		// property: name=forward_fast_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.ForwardFastEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.ForwardFastEnabled, state.SwitchPortConfig.ForwardFastEnabled)
		} else {
			body.SwitchPortConfig.ForwardFastEnabled = BoolValueOrNil(plan.SwitchPortConfig.ForwardFastEnabled)
		}
		// property: name=native_vlan_id, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.NativeVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.NativeVlanId, state.SwitchPortConfig.NativeVlanId)
		} else {
			body.SwitchPortConfig.NativeVlanId = Int64ValueOrNil(plan.SwitchPortConfig.NativeVlanId)
		}
		// property: name=root_guard_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.RootGuardEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.RootGuardEnabled, state.SwitchPortConfig.RootGuardEnabled)
		} else {
			body.SwitchPortConfig.RootGuardEnabled = BoolValueOrNil(plan.SwitchPortConfig.RootGuardEnabled)
		}
		// property: name=storm_control_config, type=REFERENCE macro=copy_from_plan_or_state
		if plan.SwitchPortConfig.StormControlConfig == nil {
			body.SwitchPortConfig.StormControlConfig = nil
		} else {
			body.SwitchPortConfig.StormControlConfig = &sdwan_schema.StormControlConfig{}
			// copy_from_plan_or_state: body=body.SwitchPortConfig.StormControlConfig prefix=rsModel state=state.SwitchPortConfig.StormControlConfig plan=plan.SwitchPortConfig.StormControlConfig properties=3
			tflog.Debug(ctx, "copy_from_plan_or_state body=body.SwitchPortConfig.StormControlConfig prefix=rsModel state=state.SwitchPortConfig.StormControlConfig plan=plan.SwitchPortConfig.StormControlConfig")
			// property: name=broadcast_threshold, type=INTEGER macro=copy_from_plan_or_state
			if state.SwitchPortConfig.StormControlConfig != nil {
				body.SwitchPortConfig.StormControlConfig.BroadcastThreshold = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StormControlConfig.BroadcastThreshold, state.SwitchPortConfig.StormControlConfig.BroadcastThreshold)
			} else {
				body.SwitchPortConfig.StormControlConfig.BroadcastThreshold = Int64ValueOrNil(plan.SwitchPortConfig.StormControlConfig.BroadcastThreshold)
			}
			// property: name=multicast_threshold, type=INTEGER macro=copy_from_plan_or_state
			if state.SwitchPortConfig.StormControlConfig != nil {
				body.SwitchPortConfig.StormControlConfig.MulticastThreshold = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StormControlConfig.MulticastThreshold, state.SwitchPortConfig.StormControlConfig.MulticastThreshold)
			} else {
				body.SwitchPortConfig.StormControlConfig.MulticastThreshold = Int64ValueOrNil(plan.SwitchPortConfig.StormControlConfig.MulticastThreshold)
			}
			// property: name=unicast_threshold, type=INTEGER macro=copy_from_plan_or_state
			if state.SwitchPortConfig.StormControlConfig != nil {
				body.SwitchPortConfig.StormControlConfig.UnicastThreshold = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StormControlConfig.UnicastThreshold, state.SwitchPortConfig.StormControlConfig.UnicastThreshold)
			} else {
				body.SwitchPortConfig.StormControlConfig.UnicastThreshold = Int64ValueOrNil(plan.SwitchPortConfig.StormControlConfig.UnicastThreshold)
			}
		}
		// property: name=stp_port_cost, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.StpPortCost = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StpPortCost, state.SwitchPortConfig.StpPortCost)
		} else {
			body.SwitchPortConfig.StpPortCost = Int64ValueOrNil(plan.SwitchPortConfig.StpPortCost)
		}
		// property: name=stp_port_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.StpPortEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.StpPortEnabled, state.SwitchPortConfig.StpPortEnabled)
		} else {
			body.SwitchPortConfig.StpPortEnabled = BoolValueOrNil(plan.SwitchPortConfig.StpPortEnabled)
		}
		// property: name=stp_port_priority, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.StpPortPriority = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StpPortPriority, state.SwitchPortConfig.StpPortPriority)
		} else {
			body.SwitchPortConfig.StpPortPriority = Int64ValueOrNil(plan.SwitchPortConfig.StpPortPriority)
		}
		// property: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.SwitchPortConfig.TrunkVlans = ListStringValueOrNil(ctx, plan.SwitchPortConfig.TrunkVlans)
		// property: name=vlan_mode, type=STRING macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.VlanMode = ValueStringPointerFromPlanOrState(plan.SwitchPortConfig.VlanMode, state.SwitchPortConfig.VlanMode)
		} else {
			body.SwitchPortConfig.VlanMode = StringValueOrNil(plan.SwitchPortConfig.VlanMode)
		}
		// property: name=voice_vlan_id, type=INTEGER macro=copy_from_plan_or_state
		if state.SwitchPortConfig != nil {
			body.SwitchPortConfig.VoiceVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.VoiceVlanId, state.SwitchPortConfig.VoiceVlanId)
		} else {
			body.SwitchPortConfig.VoiceVlanId = Int64ValueOrNil(plan.SwitchPortConfig.VoiceVlanId)
		}
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_from_plan_or_state
	body.Tags = SetStringValueOrNil(ctx, plan.Tags)
	// property: name=type, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Type = ValueStringPointerFromPlanOrState(plan.Type, state.Type)
	} else {
		body.Type = StringValueOrNil(plan.Type)
	}
	// property: name=used_for, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.UsedFor = ValueStringPointerFromPlanOrState(plan.UsedFor, state.UsedFor)
	} else {
		body.UsedFor = StringValueOrNil(plan.UsedFor)
	}
	// property: name=vlan_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.VlanConfig == nil {
		body.VlanConfig = nil
	} else {
		body.VlanConfig = &sdwan_schema.VlanConfig{}
		// copy_from_plan_or_state: body=body.VlanConfig prefix=rsModel state=state.VlanConfig plan=plan.VlanConfig properties=3
		tflog.Debug(ctx, "copy_from_plan_or_state body=body.VlanConfig prefix=rsModel state=state.VlanConfig plan=plan.VlanConfig")
		// property: name=mstp_instance, type=INTEGER macro=copy_from_plan_or_state
		if state.VlanConfig != nil {
			body.VlanConfig.MstpInstance = ValueInt64PointerFromPlanOrState(plan.VlanConfig.MstpInstance, state.VlanConfig.MstpInstance)
		} else {
			body.VlanConfig.MstpInstance = Int64ValueOrNil(plan.VlanConfig.MstpInstance)
		}
		// property: name=vlan_id, type=INTEGER macro=copy_from_plan_or_state
		if state.VlanConfig != nil {
			body.VlanConfig.VlanId = ValueInt64PointerFromPlanOrState(plan.VlanConfig.VlanId, state.VlanConfig.VlanId)
		} else {
			body.VlanConfig.VlanId = Int64ValueOrNil(plan.VlanConfig.VlanId)
		}
		// property: name=voice_enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.VlanConfig != nil {
			body.VlanConfig.VoiceEnabled = ValueBoolPointerFromPlanOrState(plan.VlanConfig.VoiceEnabled, state.VlanConfig.VoiceEnabled)
		} else {
			body.VlanConfig.VoiceEnabled = BoolValueOrNil(plan.VlanConfig.VoiceEnabled)
		}
	}
	// property: name=vrf_context_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.VrfContextId = ValueStringPointerFromPlanOrState(plan.VrfContextId, state.VrfContextId)
	} else {
		body.VrfContextId = StringValueOrNil(plan.VrfContextId)
	}

	// convert body to map
	json_body, err := json.Marshal(body)
	if err != nil {
		resp.Diagnostics.AddError("error marshaling struct InterfaceScreenV4N20 to JSON:", err.Error())
		return false
	}

	// process http json path
	request_body_string := string(json_body)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete request_body_string::ethernet_port.port_id")
	request_body_string, _ = sjson.Delete(request_body_string, "ethernet_port.port_id")
	tflog.Debug(ctx, "http json override: delete request_body_string::ethernet_port.port_name")
	request_body_string, _ = sjson.Delete(request_body_string, "ethernet_port.port_name")
	tflog.Debug(ctx, "http json override: set request_body_string::_schema")
	request_body_string, _ = sjson.Set(request_body_string, "_schema", 4)
	// copy pointer
	put_request.RequestBody = &request_body_string

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, put_request)
	if put_request.ResponseErr != nil {
		if IsObjectNotFound(*put_request.ResponseErr) {
			State.RemoveResource(ctx)
		} else if r.GetHttpStatusCode(put_request) == 404 {
			State.RemoveResource(ctx)
		} else {
			tflog.Info(ctx, "update request failed for prismasdwan_element_interface", map[string]any{
				"terraform_provider_function": "Update",
				"resource_name":               "prismasdwan_element_interface",
				"path":                        put_request.FinalPath,
			})
			tflog.Debug(ctx, "update request failed for prismasdwan_element_interface", map[string]any{
				"terraform_provider_function": "Update",
				"resource_name":               "prismasdwan_element_interface",
				"path":                        put_request.FinalPath,
				"request":                     put_request.ToString(),
			})
			resp.Diagnostics.AddError("error updating prismasdwan_element_interface", (*put_request.ResponseErr).Error())
		}
		return false
	}

	// process http json path
	response_body_string := string(*put_request.ResponseBytes)
	// inject overrides
	tflog.Debug(ctx, "http json override: delete response_body_string::_created_on_utc")
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	tflog.Debug(ctx, "http json override: set response_body_string::_schema")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// start copying attributes
	var ans sdwan_schema.InterfaceScreenV4N20
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to InterfaceScreenV4N20 in update", json_err.Error())
		return false
	}

	// Store the answer to state. schema=InterfaceScreenV4N20
	// copy_to_state: state=state prefix=rsModel ans=ans properties=50
	tflog.Debug(ctx, "copy_to_state state=state prefix=rsModel ans=ans")
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=admin_up, type=BOOLEAN macro=copy_to_state
	state.AdminUp = types.BoolPointerValue(ans.AdminUp)
	// property: name=attached_lan_networks, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.AttachedLanNetworks == nil {
		state.AttachedLanNetworks = nil
	} else if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = []rsModelLanNetworkVlanMapping{}
	} else {
		state.AttachedLanNetworks = make([]rsModelLanNetworkVlanMapping, 0, len(ans.AttachedLanNetworks))
		for varLoopAttachedLanNetworksIndex, varLoopAttachedLanNetworks := range ans.AttachedLanNetworks {
			// add a new item
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, rsModelLanNetworkVlanMapping{})
			// copy_to_state: state=state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel ans=varLoopAttachedLanNetworks properties=2
			tflog.Debug(ctx, "copy_to_state state=state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex] prefix=rsModel ans=varLoopAttachedLanNetworks")
			// property: name=lan_network_id, type=STRING macro=copy_to_state
			state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].LanNetworkId = types.StringPointerValue(varLoopAttachedLanNetworks.LanNetworkId)
			// property: name=vlan_id, type=INTEGER macro=copy_to_state
			state.AttachedLanNetworks[varLoopAttachedLanNetworksIndex].VlanId = types.Int64PointerValue(varLoopAttachedLanNetworks.VlanId)
		}
	}
	// property: name=authentication_config, type=REFERENCE macro=copy_to_state
	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &rsModelAuthenticationInterfaceConfig{}
		// copy_to_state: state=state.AuthenticationConfig prefix=rsModel ans=ans.AuthenticationConfig properties=3
		tflog.Debug(ctx, "copy_to_state state=state.AuthenticationConfig prefix=rsModel ans=ans.AuthenticationConfig")
		// property: name=fallback_retry_count, type=INTEGER macro=copy_to_state
		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)
		// property: name=mode, type=STRING macro=copy_to_state
		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)
		// property: name=reauthentication_timeout, type=INTEGER macro=copy_to_state
		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}
	// property: name=bound_interfaces, type=ARRAY_PRIMITIVE macro=copy_to_state
	varBoundInterfaces, errBoundInterfaces := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = varBoundInterfaces
	resp.Diagnostics.Append(errBoundInterfaces.Errors()...)
	// property: name=bypass_pair, type=REFERENCE macro=copy_to_state
	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &rsModelBypassPairV2{}
		// copy_to_state: state=state.BypassPair prefix=rsModel ans=ans.BypassPair properties=4
		tflog.Debug(ctx, "copy_to_state state=state.BypassPair prefix=rsModel ans=ans.BypassPair")
		// property: name=lan, type=STRING macro=copy_to_state
		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)
		// property: name=lan_state_propagation, type=BOOLEAN macro=copy_to_state
		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)
		// property: name=use_relay, type=BOOLEAN macro=copy_to_state
		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)
		// property: name=wan, type=STRING macro=copy_to_state
		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}
	// property: name=cellular_config, type=REFERENCE macro=copy_to_state
	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &rsModelCellularInterfaceConfig{}
		// copy_to_state: state=state.CellularConfig prefix=rsModel ans=ans.CellularConfig properties=5
		tflog.Debug(ctx, "copy_to_state state=state.CellularConfig prefix=rsModel ans=ans.CellularConfig")
		// property: name=apn_config, type=REFERENCE macro=copy_to_state
		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &rsModelAPNConfig{}
			// copy_to_state: state=state.CellularConfig.ApnConfig prefix=rsModel ans=ans.CellularConfig.ApnConfig properties=6
			tflog.Debug(ctx, "copy_to_state state=state.CellularConfig.ApnConfig prefix=rsModel ans=ans.CellularConfig.ApnConfig")
			// property: name=apn, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)
			// property: name=authentication, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Authentication = types.StringPointerValue(ans.CellularConfig.ApnConfig.Authentication)
			// property: name=clear_password, type=BOOLEAN macro=copy_to_state
			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)
			// property: name=password, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.Password = types.StringPointerValue(plan.CellularConfig.ApnConfig.Password.ValueStringPointer())
			// this property is sensitive and will be stored in the state's internal key name
			state.CellularConfig.ApnConfig.PasswordInternalKeyName = types.StringValue(GenerateRandomString(16))
			// store value if needed
			if !state.CellularConfig.ApnConfig.Password.IsNull() {
				encryptedPassword, _ := Encrypt([]byte(state.CellularConfig.ApnConfig.Password.String()))
				resp.Private.SetKey(ctx, state.CellularConfig.ApnConfig.PasswordInternalKeyName.String(), []byte(encryptedPassword))
			}
			// property: name=password_encrypted, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(plan.CellularConfig.ApnConfig.PasswordEncrypted.ValueStringPointer())
			// this property is sensitive and will be stored in the state's internal key name
			state.CellularConfig.ApnConfig.PasswordEncryptedInternalKeyName = types.StringValue(GenerateRandomString(16))
			// store value if needed
			if !state.CellularConfig.ApnConfig.PasswordEncrypted.IsNull() {
				encryptedPasswordEncrypted, _ := Encrypt([]byte(state.CellularConfig.ApnConfig.PasswordEncrypted.String()))
				resp.Private.SetKey(ctx, state.CellularConfig.ApnConfig.PasswordEncryptedInternalKeyName.String(), []byte(encryptedPasswordEncrypted))
			}
			// property: name=user_name, type=STRING macro=copy_to_state
			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}
		// property: name=apnprofile_id, type=STRING macro=copy_to_state
		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)
		// property: name=auto_apn, type=BOOLEAN macro=copy_to_state
		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)
		// property: name=parent_module_id, type=STRING macro=copy_to_state
		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)
		// property: name=parent_sim_slot_number, type=INTEGER macro=copy_to_state
		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=devicemgmt_policysetstack_id, type=STRING macro=copy_to_state
	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)
	// property: name=dhcp_relay, type=REFERENCE macro=copy_to_state
	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &rsModelDHCPRelay{}
		// copy_to_state: state=state.DhcpRelay prefix=rsModel ans=ans.DhcpRelay properties=4
		tflog.Debug(ctx, "copy_to_state state=state.DhcpRelay prefix=rsModel ans=ans.DhcpRelay")
		// property: name=enabled, type=BOOLEAN macro=copy_to_state
		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)
		// property: name=option_82, type=REFERENCE macro=copy_to_state
		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &rsModelDHCPRelayOption82{}
			// copy_to_state: state=state.DhcpRelay.Option82 prefix=rsModel ans=ans.DhcpRelay.Option82 properties=4
			tflog.Debug(ctx, "copy_to_state state=state.DhcpRelay.Option82 prefix=rsModel ans=ans.DhcpRelay.Option82")
			// property: name=circuit_id, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)
			// property: name=enabled, type=BOOLEAN macro=copy_to_state
			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)
			// property: name=reforwarding_policy, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringPointerValue(ans.DhcpRelay.Option82.ReforwardingPolicy)
			// property: name=remote_id, type=STRING macro=copy_to_state
			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}
		// property: name=server_ips, type=ARRAY_PRIMITIVE macro=copy_to_state
		varServerIps, errServerIps := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = varServerIps
		resp.Diagnostics.Append(errServerIps.Errors()...)
		// property: name=source_interface, type=STRING macro=copy_to_state
		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}
	// property: name=directed_broadcast, type=BOOLEAN macro=copy_to_state
	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)
	// property: name=ethernet_port, type=REFERENCE macro=copy_to_state
	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &rsModelEthernetPort{}
		// copy_to_state: state=state.EthernetPort prefix=rsModel ans=ans.EthernetPort properties=4
		tflog.Debug(ctx, "copy_to_state state=state.EthernetPort prefix=rsModel ans=ans.EthernetPort")
		// property: name=full_duplex, type=BOOLEAN macro=copy_to_state
		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)
		// property: name=port_id, type=REFERENCE macro=copy_to_state
		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &rsModelEthernet{}
			// copy_to_state: state=state.EthernetPort.PortId prefix=rsModel ans=ans.EthernetPort.PortId properties=16
			tflog.Debug(ctx, "copy_to_state state=state.EthernetPort.PortId prefix=rsModel ans=ans.EthernetPort.PortId")
			// property: name=_etag, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.Etag = types.Int64PointerValue(ans.EthernetPort.PortId.Etag)
			// property: name=_schema, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.Schema = types.Int64PointerValue(ans.EthernetPort.PortId.Schema)
			// property: name=connector, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)
			// property: name=device, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)
			// property: name=disabled, type=BOOLEAN macro=copy_to_state
			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)
			// property: name=disabled_reason, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)
			// property: name=element_id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)
			// property: name=id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)
			// property: name=inactive, type=BOOLEAN macro=copy_to_state
			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)
			// property: name=inactive_reason, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)
			// property: name=max_mtu, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)
			// property: name=max_speed, type=INTEGER macro=copy_to_state
			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)
			// property: name=name, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)
			// property: name=original_mac_address, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)
			// property: name=region, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)
			// property: name=site_id, type=STRING macro=copy_to_state
			state.EthernetPort.PortId.SiteId = types.StringPointerValue(ans.EthernetPort.PortId.SiteId)
		}
		// property: name=port_name, type=STRING macro=copy_to_state
		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)
		// property: name=speed, type=INTEGER macro=copy_to_state
		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=interface_profile_id, type=STRING macro=copy_to_state
	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)
	// property: name=ipfixcollectorcontext_id, type=STRING macro=copy_to_state
	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)
	// property: name=ipfixfiltercontext_id, type=STRING macro=copy_to_state
	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)
	// property: name=ipv4_config, type=REFERENCE macro=copy_to_state
	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &rsModelIpv4Config{}
		// copy_to_state: state=state.Ipv4Config prefix=rsModel ans=ans.Ipv4Config properties=6
		tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config prefix=rsModel ans=ans.Ipv4Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &rsModelIpv4Dhcp{}
			// copy_to_state: state=state.Ipv4Config.DhcpConfig prefix=rsModel ans=ans.Ipv4Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.DhcpConfig prefix=rsModel ans=ans.Ipv4Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_to_state
			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_to_state
			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v4_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &rsModelDNS{}
			// copy_to_state: state=state.Ipv4Config.DnsV4Config prefix=rsModel ans=ans.Ipv4Config.DnsV4Config properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.DnsV4Config prefix=rsModel ans=ans.Ipv4Config.DnsV4Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
			varNameServers, errNameServers := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = varNameServers
			resp.Diagnostics.Append(errNameServers.Errors()...)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_to_state
			varSearch, errSearch := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = varSearch
			resp.Diagnostics.Append(errSearch.Errors()...)
		}
		// property: name=pppoe_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &rsModelIpv4Pppoe{}
			// copy_to_state: state=state.Ipv4Config.PppoeConfig prefix=rsModel ans=ans.Ipv4Config.PppoeConfig properties=3
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.PppoeConfig prefix=rsModel ans=ans.Ipv4Config.PppoeConfig")
			// property: name=chap_passwd, type=STRING macro=copy_to_state
			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)
			// property: name=chap_user, type=STRING macro=copy_to_state
			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)
			// property: name=set_route, type=BOOLEAN macro=copy_to_state
			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.Ipv4Config.Routes == nil {
			state.Ipv4Config.Routes = nil
		} else if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = []rsModelRoute{}
		} else {
			state.Ipv4Config.Routes = make([]rsModelRoute, 0, len(ans.Ipv4Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range ans.Ipv4Config.Routes {
				// add a new item
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, rsModelRoute{})
				// copy_to_state: state=state.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_to_state
				state.Ipv4Config.Routes[varLoopRoutesIndex].Destination = types.StringPointerValue(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_to_state
				state.Ipv4Config.Routes[varLoopRoutesIndex].Via = types.StringPointerValue(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &rsModelIpv4Static{}
			// copy_to_state: state=state.Ipv4Config.StaticConfig prefix=rsModel ans=ans.Ipv4Config.StaticConfig properties=1
			tflog.Debug(ctx, "copy_to_state state=state.Ipv4Config.StaticConfig prefix=rsModel ans=ans.Ipv4Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_to_state
			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}
		// property: name=type, type=STRING macro=copy_to_state
		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}
	// property: name=ipv6_config, type=REFERENCE macro=copy_to_state
	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &rsModelIpv6ConfigV1{}
		// copy_to_state: state=state.Ipv6Config prefix=rsModel ans=ans.Ipv6Config properties=5
		tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config prefix=rsModel ans=ans.Ipv6Config")
		// property: name=dhcp_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &rsModelIpv6Dhcp{}
			// copy_to_state: state=state.Ipv6Config.DhcpConfig prefix=rsModel ans=ans.Ipv6Config.DhcpConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.DhcpConfig prefix=rsModel ans=ans.Ipv6Config.DhcpConfig")
			// property: name=client_id, type=STRING macro=copy_to_state
			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)
			// property: name=hostname, type=STRING macro=copy_to_state
			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}
		// property: name=dns_v6_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &rsModelDNS{}
			// copy_to_state: state=state.Ipv6Config.DnsV6Config prefix=rsModel ans=ans.Ipv6Config.DnsV6Config properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.DnsV6Config prefix=rsModel ans=ans.Ipv6Config.DnsV6Config")
			// property: name=name_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
			varNameServers, errNameServers := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = varNameServers
			resp.Diagnostics.Append(errNameServers.Errors()...)
			// property: name=search, type=ARRAY_PRIMITIVE macro=copy_to_state
			varSearch, errSearch := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = varSearch
			resp.Diagnostics.Append(errSearch.Errors()...)
		}
		// property: name=routes, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.Ipv6Config.Routes == nil {
			state.Ipv6Config.Routes = nil
		} else if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = []rsModelRoute{}
		} else {
			state.Ipv6Config.Routes = make([]rsModelRoute, 0, len(ans.Ipv6Config.Routes))
			for varLoopRoutesIndex, varLoopRoutes := range ans.Ipv6Config.Routes {
				// add a new item
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, rsModelRoute{})
				// copy_to_state: state=state.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes properties=2
				tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.Routes[varLoopRoutesIndex] prefix=rsModel ans=varLoopRoutes")
				// property: name=destination, type=STRING macro=copy_to_state
				state.Ipv6Config.Routes[varLoopRoutesIndex].Destination = types.StringPointerValue(varLoopRoutes.Destination)
				// property: name=via, type=STRING macro=copy_to_state
				state.Ipv6Config.Routes[varLoopRoutesIndex].Via = types.StringPointerValue(varLoopRoutes.Via)
			}
		}
		// property: name=static_config, type=REFERENCE macro=copy_to_state
		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &rsModelIpv6StaticV1{}
			// copy_to_state: state=state.Ipv6Config.StaticConfig prefix=rsModel ans=ans.Ipv6Config.StaticConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.Ipv6Config.StaticConfig prefix=rsModel ans=ans.Ipv6Config.StaticConfig")
			// property: name=address, type=STRING macro=copy_to_state
			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)
			// property: name=enable_prefix_distribution, type=BOOLEAN macro=copy_to_state
			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}
		// property: name=type, type=STRING macro=copy_to_state
		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}
	// property: name=lldp_enabled, type=BOOLEAN macro=copy_to_state
	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)
	// property: name=mac_address, type=STRING macro=copy_to_state
	state.MacAddress = types.StringPointerValue(ans.MacAddress)
	// property: name=mtu, type=INTEGER macro=copy_to_state
	state.Mtu = types.Int64PointerValue(ans.Mtu)
	// property: name=multicast_config, type=REFERENCE macro=copy_to_state
	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &rsModelMulticastInterfaceConfig{}
		// copy_to_state: state=state.MulticastConfig prefix=rsModel ans=ans.MulticastConfig properties=4
		tflog.Debug(ctx, "copy_to_state state=state.MulticastConfig prefix=rsModel ans=ans.MulticastConfig")
		// property: name=dr_priority, type=INTEGER macro=copy_to_state
		state.MulticastConfig.DrPriority = types.Int64PointerValue(ans.MulticastConfig.DrPriority)
		// property: name=igmp_static_joins, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.MulticastConfig.IgmpStaticJoins == nil {
			state.MulticastConfig.IgmpStaticJoins = nil
		} else if len(ans.MulticastConfig.IgmpStaticJoins) == 0 {
			state.MulticastConfig.IgmpStaticJoins = []rsModelMulticastIgmpStaticJoin{}
		} else {
			state.MulticastConfig.IgmpStaticJoins = make([]rsModelMulticastIgmpStaticJoin, 0, len(ans.MulticastConfig.IgmpStaticJoins))
			for varLoopIgmpStaticJoinsIndex, varLoopIgmpStaticJoins := range ans.MulticastConfig.IgmpStaticJoins {
				// add a new item
				state.MulticastConfig.IgmpStaticJoins = append(state.MulticastConfig.IgmpStaticJoins, rsModelMulticastIgmpStaticJoin{})
				// copy_to_state: state=state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel ans=varLoopIgmpStaticJoins properties=2
				tflog.Debug(ctx, "copy_to_state state=state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex] prefix=rsModel ans=varLoopIgmpStaticJoins")
				// property: name=igmp_static_grp_ipv4, type=STRING macro=copy_to_state
				state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticGrpIpv4 = types.StringPointerValue(varLoopIgmpStaticJoins.IgmpStaticGrpIpv4)
				// property: name=igmp_static_src_ipv4, type=STRING macro=copy_to_state
				state.MulticastConfig.IgmpStaticJoins[varLoopIgmpStaticJoinsIndex].IgmpStaticSrcIpv4 = types.StringPointerValue(varLoopIgmpStaticJoins.IgmpStaticSrcIpv4)
			}
		}
		// property: name=igmp_version, type=STRING macro=copy_to_state
		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)
		// property: name=multicast_enabled, type=BOOLEAN macro=copy_to_state
		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=nat_address, type=STRING macro=copy_to_state
	state.NatAddress = types.StringPointerValue(ans.NatAddress)
	// property: name=nat_address_v6, type=STRING macro=copy_to_state
	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)
	// property: name=nat_pools, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.NatPools == nil {
		state.NatPools = nil
	} else if len(ans.NatPools) == 0 {
		state.NatPools = []rsModelNatPool{}
	} else {
		state.NatPools = make([]rsModelNatPool, 0, len(ans.NatPools))
		for varLoopNatPoolsIndex, varLoopNatPools := range ans.NatPools {
			// add a new item
			state.NatPools = append(state.NatPools, rsModelNatPool{})
			// copy_to_state: state=state.NatPools[varLoopNatPoolsIndex] prefix=rsModel ans=varLoopNatPools properties=2
			tflog.Debug(ctx, "copy_to_state state=state.NatPools[varLoopNatPoolsIndex] prefix=rsModel ans=varLoopNatPools")
			// property: name=ipv4_ranges, type=ARRAY_REFERENCE macro=copy_to_state
			if varLoopNatPools.Ipv4Ranges == nil {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = nil
			} else if len(varLoopNatPools.Ipv4Ranges) == 0 {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = []rsModelIPv4Range{}
			} else {
				state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = make([]rsModelIPv4Range, 0, len(varLoopNatPools.Ipv4Ranges))
				for varLoopIpv4RangesIndex, varLoopIpv4Ranges := range varLoopNatPools.Ipv4Ranges {
					// add a new item
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges = append(state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges, rsModelIPv4Range{})
					// copy_to_state: state=state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel ans=varLoopIpv4Ranges properties=2
					tflog.Debug(ctx, "copy_to_state state=state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex] prefix=rsModel ans=varLoopIpv4Ranges")
					// property: name=end, type=STRING macro=copy_to_state
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].End = types.StringPointerValue(varLoopIpv4Ranges.End)
					// property: name=start, type=STRING macro=copy_to_state
					state.NatPools[varLoopNatPoolsIndex].Ipv4Ranges[varLoopIpv4RangesIndex].Start = types.StringPointerValue(varLoopIpv4Ranges.Start)
				}
			}
			// property: name=nat_pool_id, type=STRING macro=copy_to_state
			state.NatPools[varLoopNatPoolsIndex].NatPoolId = types.StringPointerValue(varLoopNatPools.NatPoolId)
		}
	}
	// property: name=nat_port, type=INTEGER macro=copy_to_state
	state.NatPort = types.Int64PointerValue(ans.NatPort)
	// property: name=nat_port_v6, type=INTEGER macro=copy_to_state
	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)
	// property: name=nat_zone_id, type=STRING macro=copy_to_state
	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)
	// property: name=network_context_id, type=STRING macro=copy_to_state
	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)
	// property: name=parent, type=STRING macro=copy_to_state
	state.Parent = types.StringPointerValue(ans.Parent)
	// property: name=peer_bypasspair_wan_port_type, type=STRING macro=copy_to_state
	state.PeerBypasspairWanPortType = types.StringPointerValue(ans.PeerBypasspairWanPortType)
	// property: name=poe_enabled, type=BOOLEAN macro=copy_to_state
	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)
	// property: name=port_channel_config, type=REFERENCE macro=copy_to_state
	if ans.PortChannelConfig == nil {
		state.PortChannelConfig = nil
	} else {
		state.PortChannelConfig = &rsModelPortChannelConfig{}
		// copy_to_state: state=state.PortChannelConfig prefix=rsModel ans=ans.PortChannelConfig properties=2
		tflog.Debug(ctx, "copy_to_state state=state.PortChannelConfig prefix=rsModel ans=ans.PortChannelConfig")
		// property: name=lacp_enabled, type=BOOLEAN macro=copy_to_state
		state.PortChannelConfig.LacpEnabled = types.BoolPointerValue(ans.PortChannelConfig.LacpEnabled)
		// property: name=transmission_mode, type=STRING macro=copy_to_state
		state.PortChannelConfig.TransmissionMode = types.StringPointerValue(ans.PortChannelConfig.TransmissionMode)
	}
	// property: name=power_usage_threshold, type=INTEGER macro=copy_to_state
	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)
	// property: name=pppoe_config, type=REFERENCE macro=copy_to_state
	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &rsModelPppoEInterfaceConfig{}
		// copy_to_state: state=state.PppoeConfig prefix=rsModel ans=ans.PppoeConfig properties=6
		tflog.Debug(ctx, "copy_to_state state=state.PppoeConfig prefix=rsModel ans=ans.PppoeConfig")
		// property: name=host_uniq, type=STRING macro=copy_to_state
		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)
		// property: name=ip_address_type, type=STRING macro=copy_to_state
		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)
		// property: name=password, type=STRING macro=copy_to_state
		state.PppoeConfig.Password = types.StringPointerValue(plan.PppoeConfig.Password.ValueStringPointer())
		// this property is sensitive and will be stored in the state's internal key name
		state.PppoeConfig.PasswordInternalKeyName = types.StringValue(GenerateRandomString(16))
		// store value if needed
		if !state.PppoeConfig.Password.IsNull() {
			encryptedPassword, _ := Encrypt([]byte(state.PppoeConfig.Password.String()))
			resp.Private.SetKey(ctx, state.PppoeConfig.PasswordInternalKeyName.String(), []byte(encryptedPassword))
		}
		// property: name=reconnection_delay, type=INTEGER macro=copy_to_state
		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)
		// property: name=service_name, type=STRING macro=copy_to_state
		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)
		// property: name=username, type=STRING macro=copy_to_state
		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}
	// property: name=scope, type=STRING macro=copy_to_state
	state.Scope = types.StringPointerValue(ans.Scope)
	// property: name=secondary_ip_configs, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.SecondaryIpConfigs == nil {
		state.SecondaryIpConfigs = nil
	} else if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = []rsModelSecondaryIPConfig{}
	} else {
		state.SecondaryIpConfigs = make([]rsModelSecondaryIPConfig, 0, len(ans.SecondaryIpConfigs))
		for varLoopSecondaryIpConfigsIndex, varLoopSecondaryIpConfigs := range ans.SecondaryIpConfigs {
			// add a new item
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, rsModelSecondaryIPConfig{})
			// copy_to_state: state=state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel ans=varLoopSecondaryIpConfigs properties=2
			tflog.Debug(ctx, "copy_to_state state=state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex] prefix=rsModel ans=varLoopSecondaryIpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Ipv4Address = types.StringPointerValue(varLoopSecondaryIpConfigs.Ipv4Address)
			// property: name=scope, type=STRING macro=copy_to_state
			state.SecondaryIpConfigs[varLoopSecondaryIpConfigsIndex].Scope = types.StringPointerValue(varLoopSecondaryIpConfigs.Scope)
		}
	}
	// property: name=service_link_config, type=REFERENCE macro=copy_to_state
	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &rsModelServiceLinkV4{}
		// copy_to_state: state=state.ServiceLinkConfig prefix=rsModel ans=ans.ServiceLinkConfig properties=8
		tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig prefix=rsModel ans=ans.ServiceLinkConfig")
		// property: name=gre_config, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &rsModelGREConfig{}
			// copy_to_state: state=state.ServiceLinkConfig.GreConfig prefix=rsModel ans=ans.ServiceLinkConfig.GreConfig properties=4
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.GreConfig prefix=rsModel ans=ans.ServiceLinkConfig.GreConfig")
			// property: name=csum, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)
			// property: name=keepalive_enable, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)
			// property: name=keepalive_fail_count, type=INTEGER macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)
			// property: name=keepalive_interval, type=INTEGER macro=copy_to_state
			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}
		// property: name=ipsec_config, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &rsModelIPSECConfigV1{}
			// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig")
			// property: name=authentication, type=REFERENCE macro=copy_to_state
			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &rsModelIPSECAuthenticationV1{}
				// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication properties=22
				tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig.Authentication prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication")
				// property: name=certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)
				// property: name=certificate_profile_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)
				// property: name=comment, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)
				// property: name=ikev1_params, type=REFERENCE macro=copy_to_state
				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &rsModelIKEV1Params{}
					// copy_to_state: state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params properties=5
					tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params prefix=rsModel ans=ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params")
					// property: name=xauth_id, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)
					// property: name=xauth_secret, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret.ValueStringPointer())
					// this property is sensitive and will be stored in the state's internal key name
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretInternalKeyName = types.StringValue(GenerateRandomString(16))
					// store value if needed
					if !state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret.IsNull() {
						encryptedXauthSecret, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret.String()))
						resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretInternalKeyName.String(), []byte(encryptedXauthSecret))
					}
					// property: name=xauth_secret_encrypted, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted.ValueStringPointer())
					// this property is sensitive and will be stored in the state's internal key name
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncryptedInternalKeyName = types.StringValue(GenerateRandomString(16))
					// store value if needed
					if !state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted.IsNull() {
						encryptedXauthSecretEncrypted, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted.String()))
						resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncryptedInternalKeyName.String(), []byte(encryptedXauthSecretEncrypted))
					}
					// property: name=xauth_secret_hash, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash.ValueStringPointer())
					// this property is sensitive and will be stored in the state's internal key name
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHashInternalKeyName = types.StringValue(GenerateRandomString(16))
					// store value if needed
					if !state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash.IsNull() {
						encryptedXauthSecretHash, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash.String()))
						resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHashInternalKeyName.String(), []byte(encryptedXauthSecretHash))
					}
					// property: name=xauth_type, type=STRING macro=copy_to_state
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}
				// property: name=local_ca_certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)
				// property: name=local_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)
				// property: name=local_id_custom, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)
				// property: name=local_pa_certificate_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)
				// property: name=pa_master_key_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)
				// property: name=passphrase, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)
				// property: name=passphrase_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)
				// property: name=peer_id_check, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)
				// property: name=permit_peer_id_mismatch, type=BOOLEAN macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)
				// property: name=private_key, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)
				// property: name=private_key_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)
				// property: name=remote_ca_certificate, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)
				// property: name=remote_id, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)
				// property: name=secret, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.Secret.ValueStringPointer())
				// this property is sensitive and will be stored in the state's internal key name
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretInternalKeyName = types.StringValue(GenerateRandomString(16))
				// store value if needed
				if !state.ServiceLinkConfig.IpsecConfig.Authentication.Secret.IsNull() {
					encryptedSecret, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.Secret.String()))
					resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretInternalKeyName.String(), []byte(encryptedSecret))
				}
				// property: name=secret_encrypted, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted.ValueStringPointer())
				// this property is sensitive and will be stored in the state's internal key name
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncryptedInternalKeyName = types.StringValue(GenerateRandomString(16))
				// store value if needed
				if !state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted.IsNull() {
					encryptedSecretEncrypted, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted.String()))
					resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncryptedInternalKeyName.String(), []byte(encryptedSecretEncrypted))
				}
				// property: name=secret_hash, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash.ValueStringPointer())
				// this property is sensitive and will be stored in the state's internal key name
				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHashInternalKeyName = types.StringValue(GenerateRandomString(16))
				// store value if needed
				if !state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash.IsNull() {
					encryptedSecretHash, _ := Encrypt([]byte(state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash.String()))
					resp.Private.SetKey(ctx, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHashInternalKeyName.String(), []byte(encryptedSecretHash))
				}
				// property: name=strict_validation_peer_extended_key_use, type=BOOLEAN macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)
				// property: name=type, type=STRING macro=copy_to_state
				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)
			}
			// property: name=ipsec_profile_id, type=STRING macro=copy_to_state
			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}
		// property: name=last_parent, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)
		// property: name=parent, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)
		// property: name=passive_mode, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &rsModelPassiveMode{}
			// copy_to_state: state=state.ServiceLinkConfig.PassiveMode prefix=rsModel ans=ans.ServiceLinkConfig.PassiveMode properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.PassiveMode prefix=rsModel ans=ans.ServiceLinkConfig.PassiveMode")
			// property: name=enable, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)
			// property: name=peer_ip_dynamic, type=BOOLEAN macro=copy_to_state
			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}
		// property: name=peer, type=REFERENCE macro=copy_to_state
		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &rsModelPeerInfo{}
			// copy_to_state: state=state.ServiceLinkConfig.Peer prefix=rsModel ans=ans.ServiceLinkConfig.Peer properties=2
			tflog.Debug(ctx, "copy_to_state state=state.ServiceLinkConfig.Peer prefix=rsModel ans=ans.ServiceLinkConfig.Peer")
			// property: name=hostname, type=STRING macro=copy_to_state
			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)
			// property: name=ip_addresses, type=ARRAY_PRIMITIVE macro=copy_to_state
			varIpAddresses, errIpAddresses := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = varIpAddresses
			resp.Diagnostics.Append(errIpAddresses.Errors()...)
		}
		// property: name=service_endpoint_id, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)
		// property: name=type, type=STRING macro=copy_to_state
		state.ServiceLinkConfig.Type = types.StringPointerValue(ans.ServiceLinkConfig.Type)
	}
	// property: name=sgi_apply_static_tag, type=BOOLEAN macro=copy_to_state
	state.SgiApplyStaticTag = types.BoolPointerValue(ans.SgiApplyStaticTag)
	// property: name=site_wan_interface_ids, type=ARRAY_PRIMITIVE macro=copy_to_state
	varSiteWanInterfaceIds, errSiteWanInterfaceIds := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = varSiteWanInterfaceIds
	resp.Diagnostics.Append(errSiteWanInterfaceIds.Errors()...)
	// property: name=static_arp_configs, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.StaticArpConfigs == nil {
		state.StaticArpConfigs = nil
	} else if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = []rsModelStaticARPConfig{}
	} else {
		state.StaticArpConfigs = make([]rsModelStaticARPConfig, 0, len(ans.StaticArpConfigs))
		for varLoopStaticArpConfigsIndex, varLoopStaticArpConfigs := range ans.StaticArpConfigs {
			// add a new item
			state.StaticArpConfigs = append(state.StaticArpConfigs, rsModelStaticARPConfig{})
			// copy_to_state: state=state.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel ans=varLoopStaticArpConfigs properties=2
			tflog.Debug(ctx, "copy_to_state state=state.StaticArpConfigs[varLoopStaticArpConfigsIndex] prefix=rsModel ans=varLoopStaticArpConfigs")
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.StaticArpConfigs[varLoopStaticArpConfigsIndex].Ipv4Address = types.StringPointerValue(varLoopStaticArpConfigs.Ipv4Address)
			// property: name=mac_address, type=STRING macro=copy_to_state
			state.StaticArpConfigs[varLoopStaticArpConfigsIndex].MacAddress = types.StringPointerValue(varLoopStaticArpConfigs.MacAddress)
		}
	}
	// property: name=sub_interface, type=REFERENCE macro=copy_to_state
	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &rsModelSubInterface{}
		// copy_to_state: state=state.SubInterface prefix=rsModel ans=ans.SubInterface properties=1
		tflog.Debug(ctx, "copy_to_state state=state.SubInterface prefix=rsModel ans=ans.SubInterface")
		// property: name=vlan_id, type=INTEGER macro=copy_to_state
		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}
	// property: name=switch_port_config, type=REFERENCE macro=copy_to_state
	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &rsModelSwitchPortConfig{}
		// copy_to_state: state=state.SwitchPortConfig prefix=rsModel ans=ans.SwitchPortConfig properties=12
		tflog.Debug(ctx, "copy_to_state state=state.SwitchPortConfig prefix=rsModel ans=ans.SwitchPortConfig")
		// property: name=access_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)
		// property: name=bpdu_guard_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)
		// property: name=forward_fast_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)
		// property: name=native_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)
		// property: name=root_guard_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)
		// property: name=storm_control_config, type=REFERENCE macro=copy_to_state
		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &rsModelStormControlConfig{}
			// copy_to_state: state=state.SwitchPortConfig.StormControlConfig prefix=rsModel ans=ans.SwitchPortConfig.StormControlConfig properties=3
			tflog.Debug(ctx, "copy_to_state state=state.SwitchPortConfig.StormControlConfig prefix=rsModel ans=ans.SwitchPortConfig.StormControlConfig")
			// property: name=broadcast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)
			// property: name=multicast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)
			// property: name=unicast_threshold, type=INTEGER macro=copy_to_state
			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}
		// property: name=stp_port_cost, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)
		// property: name=stp_port_enabled, type=BOOLEAN macro=copy_to_state
		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)
		// property: name=stp_port_priority, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)
		// property: name=trunk_vlans, type=ARRAY_PRIMITIVE macro=copy_to_state
		varTrunkVlans, errTrunkVlans := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = varTrunkVlans
		resp.Diagnostics.Append(errTrunkVlans.Errors()...)
		// property: name=vlan_mode, type=STRING macro=copy_to_state
		state.SwitchPortConfig.VlanMode = types.StringPointerValue(ans.SwitchPortConfig.VlanMode)
		// property: name=voice_vlan_id, type=INTEGER macro=copy_to_state
		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	// property: name=type, type=STRING macro=copy_to_state
	state.Type = types.StringPointerValue(ans.Type)
	// property: name=used_for, type=STRING macro=copy_to_state
	state.UsedFor = types.StringPointerValue(ans.UsedFor)
	// property: name=vlan_config, type=REFERENCE macro=copy_to_state
	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &rsModelVlanConfig{}
		// copy_to_state: state=state.VlanConfig prefix=rsModel ans=ans.VlanConfig properties=3
		tflog.Debug(ctx, "copy_to_state state=state.VlanConfig prefix=rsModel ans=ans.VlanConfig")
		// property: name=mstp_instance, type=INTEGER macro=copy_to_state
		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)
		// property: name=vlan_id, type=INTEGER macro=copy_to_state
		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)
		// property: name=voice_enabled, type=BOOLEAN macro=copy_to_state
		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}
	// property: name=vrf_context_id, type=STRING macro=copy_to_state
	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)
	return true
}

func (r *elementInterfaceResource) doDelete(ctx context.Context, state *rsModelInterfaceScreenV4N20, resp *resource.DeleteResponse) bool {
	// read object id
	tfid := state.Tfid.ValueString()
	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "prismasdwan_element_interface",
		"locMap":                      map[string]int{"prefix_id": 0},
	})

	// tokens must match
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) < 3 {
		resp.Diagnostics.AddError("error in prismasdwan_element_interface ID format", "Expected 3 tokens")
		return false
	}

	// Prepare input for the API endpoint.
	delete_request := &sdwan_client.SdwanClientRequestResponse{}
	delete_request.ResourceType = "prismasdwan_element_interface"
	delete_request.Method = "DELETE"
	delete_request.Path = "/sdwan/v4.20/api/sites/{site_id}/elements/{element_id}/interfaces/{interface_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, state.TfParameters)
	delete_request.PathParameters = &params
	// add last parameter as ObjectID
	(*delete_request.PathParameters)["interface_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*delete_request.PathParameters)[param[0]] = &param[1]
	}

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, delete_request)
	if delete_request.ResponseErr != nil {
		if !IsObjectNotFound(*delete_request.ResponseErr) {
			resp.Diagnostics.AddError("error deleting prismasdwan_element_interface", (*delete_request.ResponseErr).Error())
			return false
		}
	}
	return true
}

// Performs the Create(POST) Operation on the Resource
// TfID is pulled from plan to use in the creation request
// Path Parameters are encoded into TfID itself
func (r *elementInterfaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "executing resource create for prismasdwan_element_interface")
	var plan rsModelInterfaceScreenV4N20
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make post call
	var state rsModelInterfaceScreenV4N20
	if r.doPost(ctx, &plan, &state, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Read(GET) Operation on the Resource
// TfID is pulled from state to use in the read request
// Path Parameters are extracted TfID itself
func (r *elementInterfaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	tflog.Info(ctx, "executing resource read for prismasdwan_element_interface")
	var savestate, state rsModelInterfaceScreenV4N20
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a get call
	if r.doGet(ctx, &state, &savestate, &resp.State, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Update(PUT) Operation on the Resource
// TfID is pulled from state to use in the read request
// Path Parameters are extracted TfID itself
// TfID must match in state and plan, else error is thrown
func (r *elementInterfaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	tflog.Info(ctx, "executing resource update for prismasdwan_element_interface")
	var plan, state rsModelInterfaceScreenV4N20
	// copy state from TF
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// copy plan from TF
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a put call
	if r.doPut(ctx, &plan, &state, &resp.State, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Delete Operation on the Resource
// TfID is pulled from state to use in the deletion request
// Path Parameters are extracted from the TfID itself
func (r *elementInterfaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	tflog.Info(ctx, "executing resource delete for prismasdwan_element_interface")
	var state rsModelInterfaceScreenV4N20
	// copy state from TF
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a delete call
	if r.doDelete(ctx, &state, resp) {
		resp.State.RemoveResource(ctx)
	}
}

func (r *elementInterfaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

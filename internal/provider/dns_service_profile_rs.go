package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"encoding/json"
	"strings"

	sdwan "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk"
	sdwan_schema "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas"
	sdwan_client "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/services"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/tfsdk"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/tidwall/sjson"
)

// +-----------------------------------------------------------------
// | Schema Map Summary (size=goLangStructMap=29)
// | Computed Resource Name=dnsserviceprofiles
// +-----------------------------------------------------------------
// | DnsServersV2 HasID=false
// | DnsForwardConfigV2 HasID=false
// | MxHostRecord HasID=false
// | TxtRecord HasID=false
// | PtrRecords HasID=false
// | CnameRecords HasID=false
// | DnsResourceRecords HasID=false
// | CaaRecord HasID=false
// | NaptrRecords HasID=false
// | SrvHost HasID=false
// | SynthDomain HasID=false
// | HostRecord HasID=false
// | SOA HasID=false
// | Zone HasID=false
// | Server HasID=false
// | AuthoritativeConfig HasID=false
// | DomainsToAddress HasID=false
// | KeyDigest HasID=false
// | TrustAnchor HasID=false
// | DnsSecConfig HasID=false
// | DnsRebindConfig HasID=false
// | CacheConfig HasID=false
// | Alias HasID=false
// | DnsResponseOverrides HasID=false
// | Subnet HasID=false
// | CustomerPremisesEquipment HasID=false
// | ClientMac HasID=false
// | DnsQueriesMetadata HasID=false
// | DnsServiceProfileV2N1 HasID=true
// +-----------------------------------------------------------------

// Resource.
var (
	_ resource.Resource                = &dnsServiceProfileResource{}
	_ resource.ResourceWithConfigure   = &dnsServiceProfileResource{}
	_ resource.ResourceWithImportState = &dnsServiceProfileResource{}
)

// To enable this data source for TF Provider, go to `provider.go` and inject this into the function
// as below:
//
//	func (p *SdwanProvider) Resources(_ context.Context) []func() resource.Resource {
//	  	return []func() resource.Resource{
//	     ... <other existing resources>
//	     NewDnsServiceProfileResource,
//	     // -- append next resource above -- //
//	     }
//	  }
func NewDnsServiceProfileResource() resource.Resource {
	return &dnsServiceProfileResource{}
}

type dnsServiceProfileResource struct {
	client *sdwan.Client
}

// Metadata returns the data source type name.
func (r *dnsServiceProfileResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = "prismasdwan_dns_service_profile"
}

// Schema defines the schema for this data source.
func (r *dnsServiceProfileResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",
		Attributes: map[string]rsschema.Attribute{
			"tfid": rsschema.StringAttribute{
				Computed: true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			// rest all properties to be read from GET API Schema schema=DnsServiceProfileV2N1
			// generic x_parameters is added to accomodate path parameters
			"x_parameters": rsschema.MapAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				ElementType: types.StringType,
			},
			// property: name=_etag, type=INTEGER macro=rss_schema
			"x_etag": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=_etag, type=INTEGER macro=rss_schema
			// property: name=_schema, type=INTEGER macro=rss_schema
			"x_schema": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=_schema, type=INTEGER macro=rss_schema
			// property: name=authoritative_config, type=REFERENCE macro=rss_schema
			"authoritative_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=caa_records, type=ARRAY_REFERENCE macro=rss_schema
					"caa_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=flags, type=STRING macro=rss_schema
								"flags": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=flags, type=STRING macro=rss_schema
								// property: name=name, type=STRING macro=rss_schema
								"name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=name, type=STRING macro=rss_schema
								// property: name=tag, type=STRING macro=rss_schema
								"tag": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=tag, type=STRING macro=rss_schema
								// property: name=value, type=STRING macro=rss_schema
								"value": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=value, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=value, type=STRING macro=rss_schema
					// property: name=cname_records, type=ARRAY_REFERENCE macro=rss_schema
					"cname_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=name, type=ARRAY_PRIMITIVE macro=rss_schema
								"name": rsschema.ListAttribute{
									Required:    false,
									Computed:    false,
									Optional:    true,
									Sensitive:   false,
									ElementType: types.StringType,
								},
								// key name holder for attribute: name=name, type=ARRAY_PRIMITIVE macro=rss_schema
								// property: name=target, type=STRING macro=rss_schema
								"target": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=target, type=STRING macro=rss_schema
								// property: name=ttl, type=INTEGER macro=rss_schema
								"ttl": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ttl, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=ttl, type=INTEGER macro=rss_schema
					// property: name=dns_resource_records, type=ARRAY_REFERENCE macro=rss_schema
					"dns_resource_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=hex_data, type=STRING macro=rss_schema
								"hex_data": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=hex_data, type=STRING macro=rss_schema
								// property: name=name, type=STRING macro=rss_schema
								"name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=name, type=STRING macro=rss_schema
								// property: name=rr_number, type=INTEGER macro=rss_schema
								"rr_number": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=rr_number, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=rr_number, type=INTEGER macro=rss_schema
					// property: name=host_records, type=ARRAY_REFERENCE macro=rss_schema
					"host_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=domain_names, type=ARRAY_PRIMITIVE macro=rss_schema
								"domain_names": rsschema.ListAttribute{
									Required:    false,
									Computed:    false,
									Optional:    true,
									Sensitive:   false,
									ElementType: types.StringType,
								},
								// key name holder for attribute: name=domain_names, type=ARRAY_PRIMITIVE macro=rss_schema
								// property: name=ipv4_address, type=STRING macro=rss_schema
								"ipv4_address": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipv4_address, type=STRING macro=rss_schema
								// property: name=ipv6_address, type=STRING macro=rss_schema
								"ipv6_address": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipv6_address, type=STRING macro=rss_schema
								// property: name=ttl, type=INTEGER macro=rss_schema
								"ttl": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ttl, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=ttl, type=INTEGER macro=rss_schema
					// property: name=mx_host_records, type=ARRAY_REFERENCE macro=rss_schema
					"mx_host_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=hostname, type=STRING macro=rss_schema
								"hostname": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=hostname, type=STRING macro=rss_schema
								// property: name=mx_name, type=STRING macro=rss_schema
								"mx_name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=mx_name, type=STRING macro=rss_schema
								// property: name=preference, type=INTEGER macro=rss_schema
								"preference": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=preference, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=preference, type=INTEGER macro=rss_schema
					// property: name=naptr_records, type=ARRAY_REFERENCE macro=rss_schema
					"naptr_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=flags, type=STRING macro=rss_schema
								"flags": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=flags, type=STRING macro=rss_schema
								// property: name=name, type=STRING macro=rss_schema
								"name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=name, type=STRING macro=rss_schema
								// property: name=order, type=INTEGER macro=rss_schema
								"order": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=order, type=INTEGER macro=rss_schema
								// property: name=preference, type=INTEGER macro=rss_schema
								"preference": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=preference, type=INTEGER macro=rss_schema
								// property: name=regexp, type=STRING macro=rss_schema
								"regexp": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=regexp, type=STRING macro=rss_schema
								// property: name=replacement, type=STRING macro=rss_schema
								"replacement": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=replacement, type=STRING macro=rss_schema
								// property: name=service, type=STRING macro=rss_schema
								"service": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=service, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=service, type=STRING macro=rss_schema
					// property: name=peers, type=ARRAY_PRIMITIVE macro=rss_schema
					"peers": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=peers, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=ptr_records, type=ARRAY_REFERENCE macro=rss_schema
					"ptr_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=name, type=STRING macro=rss_schema
								"name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=name, type=STRING macro=rss_schema
								// property: name=target, type=STRING macro=rss_schema
								"target": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=target, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=target, type=STRING macro=rss_schema
					// property: name=secondary_servers, type=ARRAY_PRIMITIVE macro=rss_schema
					"secondary_servers": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=secondary_servers, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=servers, type=ARRAY_REFERENCE macro=rss_schema
					"servers": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=dnsservicerole_id, type=STRING macro=rss_schema
								"dnsservicerole_id": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=dnsservicerole_id, type=STRING macro=rss_schema
								// property: name=domain_name, type=STRING macro=rss_schema
								"domain_name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=domain_name, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=domain_name, type=STRING macro=rss_schema
					// property: name=soa, type=ARRAY_REFERENCE macro=rss_schema
					"soa": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=expiry, type=INTEGER macro=rss_schema
								"expiry": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=expiry, type=INTEGER macro=rss_schema
								// property: name=host_master, type=STRING macro=rss_schema
								"host_master": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=host_master, type=STRING macro=rss_schema
								// property: name=refresh, type=INTEGER macro=rss_schema
								"refresh": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=refresh, type=INTEGER macro=rss_schema
								// property: name=retry, type=INTEGER macro=rss_schema
								"retry": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=retry, type=INTEGER macro=rss_schema
								// property: name=serial_number, type=INTEGER macro=rss_schema
								"serial_number": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=serial_number, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=serial_number, type=INTEGER macro=rss_schema
					// property: name=srv_hosts, type=ARRAY_REFERENCE macro=rss_schema
					"srv_hosts": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=domain_name, type=STRING macro=rss_schema
								"domain_name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=domain_name, type=STRING macro=rss_schema
								// property: name=port, type=INTEGER macro=rss_schema
								"port": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=port, type=INTEGER macro=rss_schema
								// property: name=priority, type=INTEGER macro=rss_schema
								"priority": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=priority, type=INTEGER macro=rss_schema
								// property: name=protocol, type=STRING macro=rss_schema
								"protocol": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=protocol, type=STRING macro=rss_schema
								// property: name=service, type=STRING macro=rss_schema
								"service": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=service, type=STRING macro=rss_schema
								// property: name=target, type=INTEGER macro=rss_schema
								"target": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=target, type=INTEGER macro=rss_schema
								// property: name=weight, type=INTEGER macro=rss_schema
								"weight": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=weight, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=weight, type=INTEGER macro=rss_schema
					// property: name=synth_domains, type=ARRAY_REFERENCE macro=rss_schema
					"synth_domains": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=domain, type=STRING macro=rss_schema
								"domain": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=domain, type=STRING macro=rss_schema
								// property: name=end_ipaddress, type=STRING macro=rss_schema
								"end_ipaddress": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=end_ipaddress, type=STRING macro=rss_schema
								// property: name=ipaddress_prefix, type=STRING macro=rss_schema
								"ipaddress_prefix": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipaddress_prefix, type=STRING macro=rss_schema
								// property: name=prefix, type=STRING macro=rss_schema
								"prefix": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=prefix, type=STRING macro=rss_schema
								// property: name=start_ipaddress, type=STRING macro=rss_schema
								"start_ipaddress": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=start_ipaddress, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=start_ipaddress, type=STRING macro=rss_schema
					// property: name=ttl, type=INTEGER macro=rss_schema
					"ttl": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=ttl, type=INTEGER macro=rss_schema
					// property: name=txt_records, type=ARRAY_REFERENCE macro=rss_schema
					"txt_records": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=domain_name, type=STRING macro=rss_schema
								"domain_name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=domain_name, type=STRING macro=rss_schema
								// property: name=texts, type=ARRAY_PRIMITIVE macro=rss_schema
								"texts": rsschema.ListAttribute{
									Required:    false,
									Computed:    false,
									Optional:    true,
									Sensitive:   false,
									ElementType: types.StringType,
								},
								// key name holder for attribute: name=texts, type=ARRAY_PRIMITIVE macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=texts, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=zones, type=ARRAY_REFERENCE macro=rss_schema
					"zones": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=domain_name, type=STRING macro=rss_schema
								"domain_name": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=domain_name, type=STRING macro=rss_schema
								// property: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=rss_schema
								"exclude_prefix": rsschema.ListAttribute{
									Required:    false,
									Computed:    false,
									Optional:    true,
									Sensitive:   false,
									ElementType: types.StringType,
								},
								// key name holder for attribute: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=rss_schema
								// property: name=include_prefix, type=ARRAY_PRIMITIVE macro=rss_schema
								"include_prefix": rsschema.ListAttribute{
									Required:    false,
									Computed:    false,
									Optional:    true,
									Sensitive:   false,
									ElementType: types.StringType,
								},
								// key name holder for attribute: name=include_prefix, type=ARRAY_PRIMITIVE macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=include_prefix, type=ARRAY_PRIMITIVE macro=rss_schema
				},
			},
			// key name holder for attribute: name=include_prefix, type=ARRAY_PRIMITIVE macro=rss_schema
			// property: name=cache_config, type=REFERENCE macro=rss_schema
			"cache_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=cache_size, type=INTEGER macro=rss_schema
					"cache_size": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=cache_size, type=INTEGER macro=rss_schema
					// property: name=disable_negative_caching, type=BOOLEAN macro=rss_schema
					"disable_negative_caching": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=disable_negative_caching, type=BOOLEAN macro=rss_schema
					// property: name=max_cache_ttl, type=INTEGER macro=rss_schema
					"max_cache_ttl": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=max_cache_ttl, type=INTEGER macro=rss_schema
					// property: name=min_cache_ttl, type=INTEGER macro=rss_schema
					"min_cache_ttl": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=min_cache_ttl, type=INTEGER macro=rss_schema
					// property: name=negative_cache_ttl, type=INTEGER macro=rss_schema
					"negative_cache_ttl": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=negative_cache_ttl, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=negative_cache_ttl, type=INTEGER macro=rss_schema
			// property: name=description, type=STRING macro=rss_schema
			"description": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=description, type=STRING macro=rss_schema
			// property: name=dns_forward_config, type=REFERENCE macro=rss_schema
			"dns_forward_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=dns_servers, type=ARRAY_REFERENCE macro=rss_schema
					"dns_servers": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=address_family, type=STRING macro=rss_schema
								"address_family": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=address_family, type=STRING macro=rss_schema
								// property: name=dnsserver_ip, type=STRING macro=rss_schema
								"dnsserver_ip": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=dnsserver_ip, type=STRING macro=rss_schema
								// property: name=dnsserver_port, type=INTEGER macro=rss_schema
								"dnsserver_port": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=dnsserver_port, type=INTEGER macro=rss_schema
								// property: name=domain_names, type=ARRAY_PRIMITIVE macro=rss_schema
								"domain_names": rsschema.ListAttribute{
									Required:    false,
									Computed:    false,
									Optional:    true,
									Sensitive:   false,
									ElementType: types.StringType,
								},
								// key name holder for attribute: name=domain_names, type=ARRAY_PRIMITIVE macro=rss_schema
								// property: name=forward_dnsservicerole_id, type=STRING macro=rss_schema
								"forward_dnsservicerole_id": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=forward_dnsservicerole_id, type=STRING macro=rss_schema
								// property: name=ip_prefix, type=STRING macro=rss_schema
								"ip_prefix": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ip_prefix, type=STRING macro=rss_schema
								// property: name=source_port, type=INTEGER macro=rss_schema
								"source_port": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=source_port, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=source_port, type=INTEGER macro=rss_schema
					// property: name=max_source_port, type=INTEGER macro=rss_schema
					"max_source_port": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=max_source_port, type=INTEGER macro=rss_schema
					// property: name=min_source_port, type=INTEGER macro=rss_schema
					"min_source_port": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=min_source_port, type=INTEGER macro=rss_schema
					// property: name=send_to_all_dns_servers, type=BOOLEAN macro=rss_schema
					"send_to_all_dns_servers": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=send_to_all_dns_servers, type=BOOLEAN macro=rss_schema
				},
			},
			// key name holder for attribute: name=send_to_all_dns_servers, type=BOOLEAN macro=rss_schema
			// property: name=dns_queries_metadata, type=REFERENCE macro=rss_schema
			"dns_queries_metadata": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=add_client_mac, type=REFERENCE macro=rss_schema
					"add_client_mac": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=mac_encoding_format, type=STRING macro=rss_schema
							"mac_encoding_format": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=mac_encoding_format, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=mac_encoding_format, type=STRING macro=rss_schema
					// property: name=add_customer_premises_equipment, type=REFERENCE macro=rss_schema
					"add_customer_premises_equipment": rsschema.SingleNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						Attributes: map[string]rsschema.Attribute{
							// property: name=identifier_text, type=STRING macro=rss_schema
							"identifier_text": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=identifier_text, type=STRING macro=rss_schema
							// property: name=type, type=STRING macro=rss_schema
							"type": rsschema.StringAttribute{
								Required:  false,
								Computed:  false,
								Optional:  true,
								Sensitive: false,
							},
							// key name holder for attribute: name=type, type=STRING macro=rss_schema
						},
					},
					// key name holder for attribute: name=type, type=STRING macro=rss_schema
					// property: name=add_subnets, type=ARRAY_REFERENCE macro=rss_schema
					"add_subnets": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=ipv4_address, type=STRING macro=rss_schema
								"ipv4_address": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipv4_address, type=STRING macro=rss_schema
								// property: name=ipv4_prefix_length, type=INTEGER macro=rss_schema
								"ipv4_prefix_length": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipv4_prefix_length, type=INTEGER macro=rss_schema
								// property: name=ipv6_address, type=STRING macro=rss_schema
								"ipv6_address": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipv6_address, type=STRING macro=rss_schema
								// property: name=ipv6_prefix_length, type=INTEGER macro=rss_schema
								"ipv6_prefix_length": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=ipv6_prefix_length, type=INTEGER macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=ipv6_prefix_length, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=ipv6_prefix_length, type=INTEGER macro=rss_schema
			// property: name=dns_rebind_config, type=REFERENCE macro=rss_schema
			"dns_rebind_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=enable_localhost_rebind, type=BOOLEAN macro=rss_schema
					"enable_localhost_rebind": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=enable_localhost_rebind, type=BOOLEAN macro=rss_schema
					// property: name=rebind_domains, type=ARRAY_PRIMITIVE macro=rss_schema
					"rebind_domains": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=rebind_domains, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=stop_dns_rebind_privateip, type=BOOLEAN macro=rss_schema
					"stop_dns_rebind_privateip": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=stop_dns_rebind_privateip, type=BOOLEAN macro=rss_schema
				},
			},
			// key name holder for attribute: name=stop_dns_rebind_privateip, type=BOOLEAN macro=rss_schema
			// property: name=dns_response_overrides, type=REFERENCE macro=rss_schema
			"dns_response_overrides": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=aliases, type=ARRAY_REFERENCE macro=rss_schema
					"aliases": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=mask, type=INTEGER macro=rss_schema
								"mask": rsschema.Int64Attribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=mask, type=INTEGER macro=rss_schema
								// property: name=original_end_ip, type=STRING macro=rss_schema
								"original_end_ip": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=original_end_ip, type=STRING macro=rss_schema
								// property: name=original_ip, type=STRING macro=rss_schema
								"original_ip": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=original_ip, type=STRING macro=rss_schema
								// property: name=original_start_ip, type=STRING macro=rss_schema
								"original_start_ip": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=original_start_ip, type=STRING macro=rss_schema
								// property: name=replace_ip, type=STRING macro=rss_schema
								"replace_ip": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=replace_ip, type=STRING macro=rss_schema
							},
						},
					},
					// key name holder for attribute: name=replace_ip, type=STRING macro=rss_schema
					// property: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=rss_schema
					"bogus_nx_domains": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=disable_private_ip_lookups, type=BOOLEAN macro=rss_schema
					"disable_private_ip_lookups": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=disable_private_ip_lookups, type=BOOLEAN macro=rss_schema
					// property: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=rss_schema
					"ignore_ip_addresses": rsschema.ListAttribute{
						Required:    false,
						Computed:    false,
						Optional:    true,
						Sensitive:   false,
						ElementType: types.StringType,
					},
					// key name holder for attribute: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=rss_schema
					// property: name=local_ttl, type=INTEGER macro=rss_schema
					"local_ttl": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=local_ttl, type=INTEGER macro=rss_schema
					// property: name=max_ttl, type=INTEGER macro=rss_schema
					"max_ttl": rsschema.Int64Attribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=max_ttl, type=INTEGER macro=rss_schema
				},
			},
			// key name holder for attribute: name=max_ttl, type=INTEGER macro=rss_schema
			// property: name=dnssec_config, type=REFERENCE macro=rss_schema
			"dnssec_config": rsschema.SingleNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				Attributes: map[string]rsschema.Attribute{
					// property: name=disable_dnssec_timecheck, type=BOOLEAN macro=rss_schema
					"disable_dnssec_timecheck": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=disable_dnssec_timecheck, type=BOOLEAN macro=rss_schema
					// property: name=dns_check_unsigned, type=BOOLEAN macro=rss_schema
					"dns_check_unsigned": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=dns_check_unsigned, type=BOOLEAN macro=rss_schema
					// property: name=enabled, type=BOOLEAN macro=rss_schema
					"enabled": rsschema.BoolAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
					},
					// key name holder for attribute: name=enabled, type=BOOLEAN macro=rss_schema
					// property: name=trust_anchors, type=ARRAY_REFERENCE macro=rss_schema
					"trust_anchors": rsschema.ListNestedAttribute{
						Required:  false,
						Computed:  false,
						Optional:  true,
						Sensitive: false,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// property: name=class, type=STRING macro=rss_schema
								"class": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=class, type=STRING macro=rss_schema
								// property: name=domain, type=STRING macro=rss_schema
								"domain": rsschema.StringAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: false,
								},
								// key name holder for attribute: name=domain, type=STRING macro=rss_schema
								// property: name=key_digest, type=REFERENCE macro=rss_schema
								"key_digest": rsschema.SingleNestedAttribute{
									Required:  false,
									Computed:  false,
									Optional:  true,
									Sensitive: true,
									Attributes: map[string]rsschema.Attribute{
										// property: name=algorithm, type=INTEGER macro=rss_schema
										"algorithm": rsschema.Int64Attribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=algorithm, type=INTEGER macro=rss_schema
										// property: name=digest, type=STRING macro=rss_schema
										"digest": rsschema.StringAttribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=digest, type=STRING macro=rss_schema
										// property: name=digest_type, type=INTEGER macro=rss_schema
										"digest_type": rsschema.Int64Attribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: false,
										},
										// key name holder for attribute: name=digest_type, type=INTEGER macro=rss_schema
										// property: name=key_tag, type=INTEGER macro=rss_schema
										"key_tag": rsschema.Int64Attribute{
											Required:  false,
											Computed:  false,
											Optional:  true,
											Sensitive: true,
										},
										// key name holder for attribute: name=key_tag, type=INTEGER macro=rss_schema
										"key_tag_internal_key_name": rsschema.Int64Attribute{
											Required:  false,
											Computed:  true,
											Optional:  true,
											Sensitive: false,
										},
									},
								},
								// key name holder for attribute: name=key_tag, type=INTEGER macro=rss_schema
								"key_tag_internal_key_name": rsschema.Int64Attribute{
									Required:  false,
									Computed:  true,
									Optional:  true,
									Sensitive: false,
								},
							},
						},
					},
					// key name holder for attribute: name=key_tag, type=INTEGER macro=rss_schema
					"key_tag_internal_key_name": rsschema.Int64Attribute{
						Required:  false,
						Computed:  true,
						Optional:  true,
						Sensitive: false,
					},
				},
			},
			// key name holder for attribute: name=key_tag, type=INTEGER macro=rss_schema
			"key_tag_internal_key_name": rsschema.Int64Attribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// property: name=domains_to_addresses, type=ARRAY_REFERENCE macro=rss_schema
			"domains_to_addresses": rsschema.ListNestedAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// property: name=domain_names, type=ARRAY_PRIMITIVE macro=rss_schema
						"domain_names": rsschema.ListAttribute{
							Required:    false,
							Computed:    false,
							Optional:    true,
							Sensitive:   false,
							ElementType: types.StringType,
						},
						// key name holder for attribute: name=domain_names, type=ARRAY_PRIMITIVE macro=rss_schema
						// property: name=ipv4_address, type=STRING macro=rss_schema
						"ipv4_address": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=ipv4_address, type=STRING macro=rss_schema
						// property: name=ipv6_address, type=STRING macro=rss_schema
						"ipv6_address": rsschema.StringAttribute{
							Required:  false,
							Computed:  false,
							Optional:  true,
							Sensitive: false,
						},
						// key name holder for attribute: name=ipv6_address, type=STRING macro=rss_schema
					},
				},
			},
			// key name holder for attribute: name=ipv6_address, type=STRING macro=rss_schema
			// property: name=edns_packet_max, type=INTEGER macro=rss_schema
			"edns_packet_max": rsschema.Int64Attribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=edns_packet_max, type=INTEGER macro=rss_schema
			// property: name=enable_dns_loop_detection, type=BOOLEAN macro=rss_schema
			"enable_dns_loop_detection": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=enable_dns_loop_detection, type=BOOLEAN macro=rss_schema
			// property: name=enable_dnssec_proxy, type=BOOLEAN macro=rss_schema
			"enable_dnssec_proxy": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=enable_dnssec_proxy, type=BOOLEAN macro=rss_schema
			// property: name=enable_strict_domain_name, type=BOOLEAN macro=rss_schema
			"enable_strict_domain_name": rsschema.BoolAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=enable_strict_domain_name, type=BOOLEAN macro=rss_schema
			// property: name=id, type=STRING macro=rss_schema
			"id": rsschema.StringAttribute{
				Required:  false,
				Computed:  true,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=id, type=STRING macro=rss_schema
			// property: name=listen_dnsservicerole_id, type=STRING macro=rss_schema
			"listen_dnsservicerole_id": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=listen_dnsservicerole_id, type=STRING macro=rss_schema
			// property: name=listen_port, type=INTEGER macro=rss_schema
			"listen_port": rsschema.Int64Attribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=listen_port, type=INTEGER macro=rss_schema
			// property: name=name, type=STRING macro=rss_schema
			"name": rsschema.StringAttribute{
				Required:  false,
				Computed:  false,
				Optional:  true,
				Sensitive: false,
			},
			// key name holder for attribute: name=name, type=STRING macro=rss_schema
			// property: name=tags, type=SET_PRIMITIVE macro=rss_schema
			"tags": rsschema.SetAttribute{
				Required:    false,
				Computed:    false,
				Optional:    true,
				Sensitive:   false,
				ElementType: types.StringType,
			},
			// key name holder for attribute: name=tags, type=SET_PRIMITIVE macro=rss_schema
		},
	}
}

// Configure prepares the struct.
func (r *dnsServiceProfileResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}
	r.client = req.ProviderData.(*sdwan.Client)
}

// in some apis the status code is not consistent and hence we may have to act upon
// specific error codes instead
func (r *dnsServiceProfileResource) GetHttpStatusCode(request *sdwan_client.SdwanClientRequestResponse) int {
	if request.ResponseErrorCode == nil {
		return request.ResponseStatusCode
	}
	switch *request.ResponseErrorCode {
	case "OBJECT_NOT_FOUND":
		return 404
	default:
		return request.ResponseStatusCode
	}
}

func (r *dnsServiceProfileResource) doPost(ctx context.Context, plan *rsModelDnsServiceProfileV2N1, state *rsModelDnsServiceProfileV2N1, resp *resource.CreateResponse) bool {
	tflog.Info(ctx, "executing http post for prismasdwan_dns_service_profile")
	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "prismasdwan_dns_service_profile",
		"terraform_provider_function": "Create",
	})

	// Prepare input for the API endpoint.
	create_request := &sdwan_client.SdwanClientRequestResponse{}
	create_request.Method = "POST"
	create_request.Path = "/sdwan/v2.1/api/dnsserviceprofiles"

	// copy parameters from plan always
	params := make(map[string]*string)
	create_request.PathParameters = &params

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// prepare request from state
	var body = &sdwan_schema.DnsServiceProfileV2N1{}

	// copy from plan to body
	// copy_from_plan: body=body prefix=rsModel plan=plan properties=20
	// property: name=_etag, type=INTEGER macro=copy_from_plan
	body.Etag = Int64ValueOrNil(plan.Etag)
	// property: name=_schema, type=INTEGER macro=copy_from_plan
	body.Schema = Int64ValueOrNil(plan.Schema)
	// property: name=authoritative_config, type=REFERENCE macro=copy_from_plan
	if plan.AuthoritativeConfig != nil {
		body.AuthoritativeConfig = &sdwan_schema.AuthoritativeConfig{}
		// copy_from_plan: body=body.AuthoritativeConfig prefix=rsModel plan=plan.AuthoritativeConfig properties=16
		// property: name=caa_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.CaaRecords == nil {
			body.AuthoritativeConfig.CaaRecords = nil
		} else if len(plan.AuthoritativeConfig.CaaRecords) == 0 {
			body.AuthoritativeConfig.CaaRecords = []sdwan_schema.CaaRecord{}
		} else {
			body.AuthoritativeConfig.CaaRecords = make([]sdwan_schema.CaaRecord, 0, len(plan.AuthoritativeConfig.CaaRecords))
			for varLoopCaaRecordsIndex, varLoopCaaRecords := range plan.AuthoritativeConfig.CaaRecords {
				// add a new item
				body.AuthoritativeConfig.CaaRecords = append(body.AuthoritativeConfig.CaaRecords, sdwan_schema.CaaRecord{})
				// copy_from_plan: body=body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex] prefix=rsModel plan=varLoopCaaRecords properties=4
				// property: name=flags, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Flags = StringValueOrNil(varLoopCaaRecords.Flags)
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Name = StringValueOrNil(varLoopCaaRecords.Name)
				// property: name=tag, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Tag = StringValueOrNil(varLoopCaaRecords.Tag)
				// property: name=value, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Value = StringValueOrNil(varLoopCaaRecords.Value)
			}
		}
		// property: name=cname_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.CnameRecords == nil {
			body.AuthoritativeConfig.CnameRecords = nil
		} else if len(plan.AuthoritativeConfig.CnameRecords) == 0 {
			body.AuthoritativeConfig.CnameRecords = []sdwan_schema.CnameRecords{}
		} else {
			body.AuthoritativeConfig.CnameRecords = make([]sdwan_schema.CnameRecords, 0, len(plan.AuthoritativeConfig.CnameRecords))
			for varLoopCnameRecordsIndex, varLoopCnameRecords := range plan.AuthoritativeConfig.CnameRecords {
				// add a new item
				body.AuthoritativeConfig.CnameRecords = append(body.AuthoritativeConfig.CnameRecords, sdwan_schema.CnameRecords{})
				// copy_from_plan: body=body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex] prefix=rsModel plan=varLoopCnameRecords properties=3
				// property: name=name, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Name = ListStringValueOrNil(ctx, varLoopCnameRecords.Name)
				// property: name=target, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Target = StringValueOrNil(varLoopCnameRecords.Target)
				// property: name=ttl, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Ttl = Int64ValueOrNil(varLoopCnameRecords.Ttl)
			}
		}
		// property: name=dns_resource_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.DnsResourceRecords == nil {
			body.AuthoritativeConfig.DnsResourceRecords = nil
		} else if len(plan.AuthoritativeConfig.DnsResourceRecords) == 0 {
			body.AuthoritativeConfig.DnsResourceRecords = []sdwan_schema.DnsResourceRecords{}
		} else {
			body.AuthoritativeConfig.DnsResourceRecords = make([]sdwan_schema.DnsResourceRecords, 0, len(plan.AuthoritativeConfig.DnsResourceRecords))
			for varLoopDnsResourceRecordsIndex, varLoopDnsResourceRecords := range plan.AuthoritativeConfig.DnsResourceRecords {
				// add a new item
				body.AuthoritativeConfig.DnsResourceRecords = append(body.AuthoritativeConfig.DnsResourceRecords, sdwan_schema.DnsResourceRecords{})
				// copy_from_plan: body=body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex] prefix=rsModel plan=varLoopDnsResourceRecords properties=3
				// property: name=hex_data, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].HexData = StringValueOrNil(varLoopDnsResourceRecords.HexData)
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].Name = StringValueOrNil(varLoopDnsResourceRecords.Name)
				// property: name=rr_number, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].RrNumber = Int64ValueOrNil(varLoopDnsResourceRecords.RrNumber)
			}
		}
		// property: name=host_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.HostRecords == nil {
			body.AuthoritativeConfig.HostRecords = nil
		} else if len(plan.AuthoritativeConfig.HostRecords) == 0 {
			body.AuthoritativeConfig.HostRecords = []sdwan_schema.HostRecord{}
		} else {
			body.AuthoritativeConfig.HostRecords = make([]sdwan_schema.HostRecord, 0, len(plan.AuthoritativeConfig.HostRecords))
			for varLoopHostRecordsIndex, varLoopHostRecords := range plan.AuthoritativeConfig.HostRecords {
				// add a new item
				body.AuthoritativeConfig.HostRecords = append(body.AuthoritativeConfig.HostRecords, sdwan_schema.HostRecord{})
				// copy_from_plan: body=body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex] prefix=rsModel plan=varLoopHostRecords properties=4
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].DomainNames = ListStringValueOrNil(ctx, varLoopHostRecords.DomainNames)
				// property: name=ipv4_address, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv4Address = StringValueOrNil(varLoopHostRecords.Ipv4Address)
				// property: name=ipv6_address, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv6Address = StringValueOrNil(varLoopHostRecords.Ipv6Address)
				// property: name=ttl, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ttl = Int64ValueOrNil(varLoopHostRecords.Ttl)
			}
		}
		// property: name=mx_host_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.MxHostRecords == nil {
			body.AuthoritativeConfig.MxHostRecords = nil
		} else if len(plan.AuthoritativeConfig.MxHostRecords) == 0 {
			body.AuthoritativeConfig.MxHostRecords = []sdwan_schema.MxHostRecord{}
		} else {
			body.AuthoritativeConfig.MxHostRecords = make([]sdwan_schema.MxHostRecord, 0, len(plan.AuthoritativeConfig.MxHostRecords))
			for varLoopMxHostRecordsIndex, varLoopMxHostRecords := range plan.AuthoritativeConfig.MxHostRecords {
				// add a new item
				body.AuthoritativeConfig.MxHostRecords = append(body.AuthoritativeConfig.MxHostRecords, sdwan_schema.MxHostRecord{})
				// copy_from_plan: body=body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex] prefix=rsModel plan=varLoopMxHostRecords properties=3
				// property: name=hostname, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Hostname = StringValueOrNil(varLoopMxHostRecords.Hostname)
				// property: name=mx_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].MxName = StringValueOrNil(varLoopMxHostRecords.MxName)
				// property: name=preference, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Preference = Int64ValueOrNil(varLoopMxHostRecords.Preference)
			}
		}
		// property: name=naptr_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.NaptrRecords == nil {
			body.AuthoritativeConfig.NaptrRecords = nil
		} else if len(plan.AuthoritativeConfig.NaptrRecords) == 0 {
			body.AuthoritativeConfig.NaptrRecords = []sdwan_schema.NaptrRecords{}
		} else {
			body.AuthoritativeConfig.NaptrRecords = make([]sdwan_schema.NaptrRecords, 0, len(plan.AuthoritativeConfig.NaptrRecords))
			for varLoopNaptrRecordsIndex, varLoopNaptrRecords := range plan.AuthoritativeConfig.NaptrRecords {
				// add a new item
				body.AuthoritativeConfig.NaptrRecords = append(body.AuthoritativeConfig.NaptrRecords, sdwan_schema.NaptrRecords{})
				// copy_from_plan: body=body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex] prefix=rsModel plan=varLoopNaptrRecords properties=7
				// property: name=flags, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Flags = StringValueOrNil(varLoopNaptrRecords.Flags)
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Name = StringValueOrNil(varLoopNaptrRecords.Name)
				// property: name=order, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Order = Int64ValueOrNil(varLoopNaptrRecords.Order)
				// property: name=preference, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Preference = Int64ValueOrNil(varLoopNaptrRecords.Preference)
				// property: name=regexp, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Regexp = StringValueOrNil(varLoopNaptrRecords.Regexp)
				// property: name=replacement, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Replacement = StringValueOrNil(varLoopNaptrRecords.Replacement)
				// property: name=service, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Service = StringValueOrNil(varLoopNaptrRecords.Service)
			}
		}
		// property: name=peers, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.AuthoritativeConfig.Peers = ListStringValueOrNil(ctx, plan.AuthoritativeConfig.Peers)
		// property: name=ptr_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.PtrRecords == nil {
			body.AuthoritativeConfig.PtrRecords = nil
		} else if len(plan.AuthoritativeConfig.PtrRecords) == 0 {
			body.AuthoritativeConfig.PtrRecords = []sdwan_schema.PtrRecords{}
		} else {
			body.AuthoritativeConfig.PtrRecords = make([]sdwan_schema.PtrRecords, 0, len(plan.AuthoritativeConfig.PtrRecords))
			for varLoopPtrRecordsIndex, varLoopPtrRecords := range plan.AuthoritativeConfig.PtrRecords {
				// add a new item
				body.AuthoritativeConfig.PtrRecords = append(body.AuthoritativeConfig.PtrRecords, sdwan_schema.PtrRecords{})
				// copy_from_plan: body=body.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex] prefix=rsModel plan=varLoopPtrRecords properties=2
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Name = StringValueOrNil(varLoopPtrRecords.Name)
				// property: name=target, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Target = StringValueOrNil(varLoopPtrRecords.Target)
			}
		}
		// property: name=secondary_servers, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.AuthoritativeConfig.SecondaryServers = ListStringValueOrNil(ctx, plan.AuthoritativeConfig.SecondaryServers)
		// property: name=servers, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.Servers == nil {
			body.AuthoritativeConfig.Servers = nil
		} else if len(plan.AuthoritativeConfig.Servers) == 0 {
			body.AuthoritativeConfig.Servers = []sdwan_schema.Server{}
		} else {
			body.AuthoritativeConfig.Servers = make([]sdwan_schema.Server, 0, len(plan.AuthoritativeConfig.Servers))
			for varLoopServersIndex, varLoopServers := range plan.AuthoritativeConfig.Servers {
				// add a new item
				body.AuthoritativeConfig.Servers = append(body.AuthoritativeConfig.Servers, sdwan_schema.Server{})
				// copy_from_plan: body=body.AuthoritativeConfig.Servers[varLoopServersIndex] prefix=rsModel plan=varLoopServers properties=2
				// property: name=dnsservicerole_id, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Servers[varLoopServersIndex].DnsserviceroleId = StringValueOrNil(varLoopServers.DnsserviceroleId)
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Servers[varLoopServersIndex].DomainName = StringValueOrNil(varLoopServers.DomainName)
			}
		}
		// property: name=soa, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.Soa == nil {
			body.AuthoritativeConfig.Soa = nil
		} else if len(plan.AuthoritativeConfig.Soa) == 0 {
			body.AuthoritativeConfig.Soa = []sdwan_schema.SOA{}
		} else {
			body.AuthoritativeConfig.Soa = make([]sdwan_schema.SOA, 0, len(plan.AuthoritativeConfig.Soa))
			for varLoopSoaIndex, varLoopSoa := range plan.AuthoritativeConfig.Soa {
				// add a new item
				body.AuthoritativeConfig.Soa = append(body.AuthoritativeConfig.Soa, sdwan_schema.SOA{})
				// copy_from_plan: body=body.AuthoritativeConfig.Soa[varLoopSoaIndex] prefix=rsModel plan=varLoopSoa properties=5
				// property: name=expiry, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].Expiry = Int64ValueOrNil(varLoopSoa.Expiry)
				// property: name=host_master, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].HostMaster = StringValueOrNil(varLoopSoa.HostMaster)
				// property: name=refresh, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].Refresh = Int64ValueOrNil(varLoopSoa.Refresh)
				// property: name=retry, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].Retry = Int64ValueOrNil(varLoopSoa.Retry)
				// property: name=serial_number, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].SerialNumber = Int64ValueOrNil(varLoopSoa.SerialNumber)
			}
		}
		// property: name=srv_hosts, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.SrvHosts == nil {
			body.AuthoritativeConfig.SrvHosts = nil
		} else if len(plan.AuthoritativeConfig.SrvHosts) == 0 {
			body.AuthoritativeConfig.SrvHosts = []sdwan_schema.SrvHost{}
		} else {
			body.AuthoritativeConfig.SrvHosts = make([]sdwan_schema.SrvHost, 0, len(plan.AuthoritativeConfig.SrvHosts))
			for varLoopSrvHostsIndex, varLoopSrvHosts := range plan.AuthoritativeConfig.SrvHosts {
				// add a new item
				body.AuthoritativeConfig.SrvHosts = append(body.AuthoritativeConfig.SrvHosts, sdwan_schema.SrvHost{})
				// copy_from_plan: body=body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex] prefix=rsModel plan=varLoopSrvHosts properties=7
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].DomainName = StringValueOrNil(varLoopSrvHosts.DomainName)
				// property: name=port, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Port = Int64ValueOrNil(varLoopSrvHosts.Port)
				// property: name=priority, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Priority = Int64ValueOrNil(varLoopSrvHosts.Priority)
				// property: name=protocol, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Protocol = StringValueOrNil(varLoopSrvHosts.Protocol)
				// property: name=service, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Service = StringValueOrNil(varLoopSrvHosts.Service)
				// property: name=target, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Target = Int64ValueOrNil(varLoopSrvHosts.Target)
				// property: name=weight, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Weight = Int64ValueOrNil(varLoopSrvHosts.Weight)
			}
		}
		// property: name=synth_domains, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.SynthDomains == nil {
			body.AuthoritativeConfig.SynthDomains = nil
		} else if len(plan.AuthoritativeConfig.SynthDomains) == 0 {
			body.AuthoritativeConfig.SynthDomains = []sdwan_schema.SynthDomain{}
		} else {
			body.AuthoritativeConfig.SynthDomains = make([]sdwan_schema.SynthDomain, 0, len(plan.AuthoritativeConfig.SynthDomains))
			for varLoopSynthDomainsIndex, varLoopSynthDomains := range plan.AuthoritativeConfig.SynthDomains {
				// add a new item
				body.AuthoritativeConfig.SynthDomains = append(body.AuthoritativeConfig.SynthDomains, sdwan_schema.SynthDomain{})
				// copy_from_plan: body=body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex] prefix=rsModel plan=varLoopSynthDomains properties=5
				// property: name=domain, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Domain = StringValueOrNil(varLoopSynthDomains.Domain)
				// property: name=end_ipaddress, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].EndIpaddress = StringValueOrNil(varLoopSynthDomains.EndIpaddress)
				// property: name=ipaddress_prefix, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].IpaddressPrefix = StringValueOrNil(varLoopSynthDomains.IpaddressPrefix)
				// property: name=prefix, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Prefix = StringValueOrNil(varLoopSynthDomains.Prefix)
				// property: name=start_ipaddress, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].StartIpaddress = StringValueOrNil(varLoopSynthDomains.StartIpaddress)
			}
		}
		// property: name=ttl, type=INTEGER macro=copy_from_plan
		body.AuthoritativeConfig.Ttl = Int64ValueOrNil(plan.AuthoritativeConfig.Ttl)
		// property: name=txt_records, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.TxtRecords == nil {
			body.AuthoritativeConfig.TxtRecords = nil
		} else if len(plan.AuthoritativeConfig.TxtRecords) == 0 {
			body.AuthoritativeConfig.TxtRecords = []sdwan_schema.TxtRecord{}
		} else {
			body.AuthoritativeConfig.TxtRecords = make([]sdwan_schema.TxtRecord, 0, len(plan.AuthoritativeConfig.TxtRecords))
			for varLoopTxtRecordsIndex, varLoopTxtRecords := range plan.AuthoritativeConfig.TxtRecords {
				// add a new item
				body.AuthoritativeConfig.TxtRecords = append(body.AuthoritativeConfig.TxtRecords, sdwan_schema.TxtRecord{})
				// copy_from_plan: body=body.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex] prefix=rsModel plan=varLoopTxtRecords properties=2
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].DomainName = StringValueOrNil(varLoopTxtRecords.DomainName)
				// property: name=texts, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].Texts = ListStringValueOrNil(ctx, varLoopTxtRecords.Texts)
			}
		}
		// property: name=zones, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.AuthoritativeConfig.Zones == nil {
			body.AuthoritativeConfig.Zones = nil
		} else if len(plan.AuthoritativeConfig.Zones) == 0 {
			body.AuthoritativeConfig.Zones = []sdwan_schema.Zone{}
		} else {
			body.AuthoritativeConfig.Zones = make([]sdwan_schema.Zone, 0, len(plan.AuthoritativeConfig.Zones))
			for varLoopZonesIndex, varLoopZones := range plan.AuthoritativeConfig.Zones {
				// add a new item
				body.AuthoritativeConfig.Zones = append(body.AuthoritativeConfig.Zones, sdwan_schema.Zone{})
				// copy_from_plan: body=body.AuthoritativeConfig.Zones[varLoopZonesIndex] prefix=rsModel plan=varLoopZones properties=3
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Zones[varLoopZonesIndex].DomainName = StringValueOrNil(varLoopZones.DomainName)
				// property: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.Zones[varLoopZonesIndex].ExcludePrefix = ListStringValueOrNil(ctx, varLoopZones.ExcludePrefix)
				// property: name=include_prefix, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.Zones[varLoopZonesIndex].IncludePrefix = ListStringValueOrNil(ctx, varLoopZones.IncludePrefix)
			}
		}
	}
	// property: name=cache_config, type=REFERENCE macro=copy_from_plan
	if plan.CacheConfig != nil {
		body.CacheConfig = &sdwan_schema.CacheConfig{}
		// copy_from_plan: body=body.CacheConfig prefix=rsModel plan=plan.CacheConfig properties=5
		// property: name=cache_size, type=INTEGER macro=copy_from_plan
		body.CacheConfig.CacheSize = Int64ValueOrNil(plan.CacheConfig.CacheSize)
		// property: name=disable_negative_caching, type=BOOLEAN macro=copy_from_plan
		body.CacheConfig.DisableNegativeCaching = BoolValueOrNil(plan.CacheConfig.DisableNegativeCaching)
		// property: name=max_cache_ttl, type=INTEGER macro=copy_from_plan
		body.CacheConfig.MaxCacheTtl = Int64ValueOrNil(plan.CacheConfig.MaxCacheTtl)
		// property: name=min_cache_ttl, type=INTEGER macro=copy_from_plan
		body.CacheConfig.MinCacheTtl = Int64ValueOrNil(plan.CacheConfig.MinCacheTtl)
		// property: name=negative_cache_ttl, type=INTEGER macro=copy_from_plan
		body.CacheConfig.NegativeCacheTtl = Int64ValueOrNil(plan.CacheConfig.NegativeCacheTtl)
	}
	// property: name=description, type=STRING macro=copy_from_plan
	body.Description = StringValueOrNil(plan.Description)
	// property: name=dns_forward_config, type=REFERENCE macro=copy_from_plan
	if plan.DnsForwardConfig != nil {
		body.DnsForwardConfig = &sdwan_schema.DnsForwardConfigV2{}
		// copy_from_plan: body=body.DnsForwardConfig prefix=rsModel plan=plan.DnsForwardConfig properties=4
		// property: name=dns_servers, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.DnsForwardConfig.DnsServers == nil {
			body.DnsForwardConfig.DnsServers = nil
		} else if len(plan.DnsForwardConfig.DnsServers) == 0 {
			body.DnsForwardConfig.DnsServers = []sdwan_schema.DnsServersV2{}
		} else {
			body.DnsForwardConfig.DnsServers = make([]sdwan_schema.DnsServersV2, 0, len(plan.DnsForwardConfig.DnsServers))
			for varLoopDnsServersIndex, varLoopDnsServers := range plan.DnsForwardConfig.DnsServers {
				// add a new item
				body.DnsForwardConfig.DnsServers = append(body.DnsForwardConfig.DnsServers, sdwan_schema.DnsServersV2{})
				// copy_from_plan: body=body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex] prefix=rsModel plan=varLoopDnsServers properties=7
				// property: name=address_family, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].AddressFamily = StringValueOrNil(varLoopDnsServers.AddressFamily)
				// property: name=dnsserver_ip, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverIp = StringValueOrNil(varLoopDnsServers.DnsserverIp)
				// property: name=dnsserver_port, type=INTEGER macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverPort = Int64ValueOrNil(varLoopDnsServers.DnsserverPort)
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DomainNames = ListStringValueOrNil(ctx, varLoopDnsServers.DomainNames)
				// property: name=forward_dnsservicerole_id, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].ForwardDnsserviceroleId = StringValueOrNil(varLoopDnsServers.ForwardDnsserviceroleId)
				// property: name=ip_prefix, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].IpPrefix = StringValueOrNil(varLoopDnsServers.IpPrefix)
				// property: name=source_port, type=INTEGER macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].SourcePort = Int64ValueOrNil(varLoopDnsServers.SourcePort)
			}
		}
		// property: name=max_source_port, type=INTEGER macro=copy_from_plan
		body.DnsForwardConfig.MaxSourcePort = Int64ValueOrNil(plan.DnsForwardConfig.MaxSourcePort)
		// property: name=min_source_port, type=INTEGER macro=copy_from_plan
		body.DnsForwardConfig.MinSourcePort = Int64ValueOrNil(plan.DnsForwardConfig.MinSourcePort)
		// property: name=send_to_all_dns_servers, type=BOOLEAN macro=copy_from_plan
		body.DnsForwardConfig.SendToAllDnsServers = BoolValueOrNil(plan.DnsForwardConfig.SendToAllDnsServers)
	}
	// property: name=dns_queries_metadata, type=REFERENCE macro=copy_from_plan
	if plan.DnsQueriesMetadata != nil {
		body.DnsQueriesMetadata = &sdwan_schema.DnsQueriesMetadata{}
		// copy_from_plan: body=body.DnsQueriesMetadata prefix=rsModel plan=plan.DnsQueriesMetadata properties=3
		// property: name=add_client_mac, type=REFERENCE macro=copy_from_plan
		if plan.DnsQueriesMetadata.AddClientMac != nil {
			body.DnsQueriesMetadata.AddClientMac = &sdwan_schema.ClientMac{}
			// copy_from_plan: body=body.DnsQueriesMetadata.AddClientMac prefix=rsModel plan=plan.DnsQueriesMetadata.AddClientMac properties=1
			// property: name=mac_encoding_format, type=STRING macro=copy_from_plan
			body.DnsQueriesMetadata.AddClientMac.MacEncodingFormat = StringValueOrNil(plan.DnsQueriesMetadata.AddClientMac.MacEncodingFormat)
		}
		// property: name=add_customer_premises_equipment, type=REFERENCE macro=copy_from_plan
		if plan.DnsQueriesMetadata.AddCustomerPremisesEquipment != nil {
			body.DnsQueriesMetadata.AddCustomerPremisesEquipment = &sdwan_schema.CustomerPremisesEquipment{}
			// copy_from_plan: body=body.DnsQueriesMetadata.AddCustomerPremisesEquipment prefix=rsModel plan=plan.DnsQueriesMetadata.AddCustomerPremisesEquipment properties=2
			// property: name=identifier_text, type=STRING macro=copy_from_plan
			body.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText = StringValueOrNil(plan.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText)
			// property: name=type, type=STRING macro=copy_from_plan
			body.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type = StringValueOrNil(plan.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type)
		}
		// property: name=add_subnets, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.DnsQueriesMetadata.AddSubnets == nil {
			body.DnsQueriesMetadata.AddSubnets = nil
		} else if len(plan.DnsQueriesMetadata.AddSubnets) == 0 {
			body.DnsQueriesMetadata.AddSubnets = []sdwan_schema.Subnet{}
		} else {
			body.DnsQueriesMetadata.AddSubnets = make([]sdwan_schema.Subnet, 0, len(plan.DnsQueriesMetadata.AddSubnets))
			for varLoopAddSubnetsIndex, varLoopAddSubnets := range plan.DnsQueriesMetadata.AddSubnets {
				// add a new item
				body.DnsQueriesMetadata.AddSubnets = append(body.DnsQueriesMetadata.AddSubnets, sdwan_schema.Subnet{})
				// copy_from_plan: body=body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex] prefix=rsModel plan=varLoopAddSubnets properties=4
				// property: name=ipv4_address, type=STRING macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4Address = StringValueOrNil(varLoopAddSubnets.Ipv4Address)
				// property: name=ipv4_prefix_length, type=INTEGER macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4PrefixLength = Int64ValueOrNil(varLoopAddSubnets.Ipv4PrefixLength)
				// property: name=ipv6_address, type=STRING macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6Address = StringValueOrNil(varLoopAddSubnets.Ipv6Address)
				// property: name=ipv6_prefix_length, type=INTEGER macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6PrefixLength = Int64ValueOrNil(varLoopAddSubnets.Ipv6PrefixLength)
			}
		}
	}
	// property: name=dns_rebind_config, type=REFERENCE macro=copy_from_plan
	if plan.DnsRebindConfig != nil {
		body.DnsRebindConfig = &sdwan_schema.DnsRebindConfig{}
		// copy_from_plan: body=body.DnsRebindConfig prefix=rsModel plan=plan.DnsRebindConfig properties=3
		// property: name=enable_localhost_rebind, type=BOOLEAN macro=copy_from_plan
		body.DnsRebindConfig.EnableLocalhostRebind = BoolValueOrNil(plan.DnsRebindConfig.EnableLocalhostRebind)
		// property: name=rebind_domains, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.DnsRebindConfig.RebindDomains = ListStringValueOrNil(ctx, plan.DnsRebindConfig.RebindDomains)
		// property: name=stop_dns_rebind_privateip, type=BOOLEAN macro=copy_from_plan
		body.DnsRebindConfig.StopDnsRebindPrivateip = BoolValueOrNil(plan.DnsRebindConfig.StopDnsRebindPrivateip)
	}
	// property: name=dns_response_overrides, type=REFERENCE macro=copy_from_plan
	if plan.DnsResponseOverrides != nil {
		body.DnsResponseOverrides = &sdwan_schema.DnsResponseOverrides{}
		// copy_from_plan: body=body.DnsResponseOverrides prefix=rsModel plan=plan.DnsResponseOverrides properties=6
		// property: name=aliases, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.DnsResponseOverrides.Aliases == nil {
			body.DnsResponseOverrides.Aliases = nil
		} else if len(plan.DnsResponseOverrides.Aliases) == 0 {
			body.DnsResponseOverrides.Aliases = []sdwan_schema.Alias{}
		} else {
			body.DnsResponseOverrides.Aliases = make([]sdwan_schema.Alias, 0, len(plan.DnsResponseOverrides.Aliases))
			for varLoopAliasesIndex, varLoopAliases := range plan.DnsResponseOverrides.Aliases {
				// add a new item
				body.DnsResponseOverrides.Aliases = append(body.DnsResponseOverrides.Aliases, sdwan_schema.Alias{})
				// copy_from_plan: body=body.DnsResponseOverrides.Aliases[varLoopAliasesIndex] prefix=rsModel plan=varLoopAliases properties=5
				// property: name=mask, type=INTEGER macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].Mask = Int64ValueOrNil(varLoopAliases.Mask)
				// property: name=original_end_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalEndIp = StringValueOrNil(varLoopAliases.OriginalEndIp)
				// property: name=original_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalIp = StringValueOrNil(varLoopAliases.OriginalIp)
				// property: name=original_start_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalStartIp = StringValueOrNil(varLoopAliases.OriginalStartIp)
				// property: name=replace_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].ReplaceIp = StringValueOrNil(varLoopAliases.ReplaceIp)
			}
		}
		// property: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.DnsResponseOverrides.BogusNxDomains = ListStringValueOrNil(ctx, plan.DnsResponseOverrides.BogusNxDomains)
		// property: name=disable_private_ip_lookups, type=BOOLEAN macro=copy_from_plan
		body.DnsResponseOverrides.DisablePrivateIpLookups = BoolValueOrNil(plan.DnsResponseOverrides.DisablePrivateIpLookups)
		// property: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=copy_from_plan
		body.DnsResponseOverrides.IgnoreIpAddresses = ListStringValueOrNil(ctx, plan.DnsResponseOverrides.IgnoreIpAddresses)
		// property: name=local_ttl, type=INTEGER macro=copy_from_plan
		body.DnsResponseOverrides.LocalTtl = Int64ValueOrNil(plan.DnsResponseOverrides.LocalTtl)
		// property: name=max_ttl, type=INTEGER macro=copy_from_plan
		body.DnsResponseOverrides.MaxTtl = Int64ValueOrNil(plan.DnsResponseOverrides.MaxTtl)
	}
	// property: name=dnssec_config, type=REFERENCE macro=copy_from_plan
	if plan.DnssecConfig != nil {
		body.DnssecConfig = &sdwan_schema.DnsSecConfig{}
		// copy_from_plan: body=body.DnssecConfig prefix=rsModel plan=plan.DnssecConfig properties=4
		// property: name=disable_dnssec_timecheck, type=BOOLEAN macro=copy_from_plan
		body.DnssecConfig.DisableDnssecTimecheck = BoolValueOrNil(plan.DnssecConfig.DisableDnssecTimecheck)
		// property: name=dns_check_unsigned, type=BOOLEAN macro=copy_from_plan
		body.DnssecConfig.DnsCheckUnsigned = BoolValueOrNil(plan.DnssecConfig.DnsCheckUnsigned)
		// property: name=enabled, type=BOOLEAN macro=copy_from_plan
		body.DnssecConfig.Enabled = BoolValueOrNil(plan.DnssecConfig.Enabled)
		// property: name=trust_anchors, type=ARRAY_REFERENCE macro=copy_from_plan
		if plan.DnssecConfig.TrustAnchors == nil {
			body.DnssecConfig.TrustAnchors = nil
		} else if len(plan.DnssecConfig.TrustAnchors) == 0 {
			body.DnssecConfig.TrustAnchors = []sdwan_schema.TrustAnchor{}
		} else {
			body.DnssecConfig.TrustAnchors = make([]sdwan_schema.TrustAnchor, 0, len(plan.DnssecConfig.TrustAnchors))
			for varLoopTrustAnchorsIndex, varLoopTrustAnchors := range plan.DnssecConfig.TrustAnchors {
				// add a new item
				body.DnssecConfig.TrustAnchors = append(body.DnssecConfig.TrustAnchors, sdwan_schema.TrustAnchor{})
				// copy_from_plan: body=body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex] prefix=rsModel plan=varLoopTrustAnchors properties=3
				// property: name=class, type=STRING macro=copy_from_plan
				body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Class = StringValueOrNil(varLoopTrustAnchors.Class)
				// property: name=domain, type=STRING macro=copy_from_plan
				body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Domain = StringValueOrNil(varLoopTrustAnchors.Domain)
				// property: name=key_digest, type=REFERENCE macro=copy_from_plan
				if varLoopTrustAnchors.KeyDigest != nil {
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = &sdwan_schema.KeyDigest{}
					// copy_from_plan: body=body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest prefix=rsModel plan=varLoopTrustAnchors.KeyDigest properties=4
					// property: name=algorithm, type=INTEGER macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Algorithm = Int64ValueOrNil(varLoopTrustAnchors.KeyDigest.Algorithm)
					// property: name=digest, type=STRING macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Digest = StringValueOrNil(varLoopTrustAnchors.KeyDigest.Digest)
					// property: name=digest_type, type=INTEGER macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.DigestType = Int64ValueOrNil(varLoopTrustAnchors.KeyDigest.DigestType)
					// property: name=key_tag, type=INTEGER macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.KeyTag = Int64ValueOrNil(varLoopTrustAnchors.KeyDigest.KeyTag)
				}
			}
		}
	}
	// property: name=domains_to_addresses, type=ARRAY_REFERENCE macro=copy_from_plan
	if plan.DomainsToAddresses == nil {
		body.DomainsToAddresses = nil
	} else if len(plan.DomainsToAddresses) == 0 {
		body.DomainsToAddresses = []sdwan_schema.DomainsToAddress{}
	} else {
		body.DomainsToAddresses = make([]sdwan_schema.DomainsToAddress, 0, len(plan.DomainsToAddresses))
		for varLoopDomainsToAddressesIndex, varLoopDomainsToAddresses := range plan.DomainsToAddresses {
			// add a new item
			body.DomainsToAddresses = append(body.DomainsToAddresses, sdwan_schema.DomainsToAddress{})
			// copy_from_plan: body=body.DomainsToAddresses[varLoopDomainsToAddressesIndex] prefix=rsModel plan=varLoopDomainsToAddresses properties=3
			// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.DomainsToAddresses[varLoopDomainsToAddressesIndex].DomainNames = ListStringValueOrNil(ctx, varLoopDomainsToAddresses.DomainNames)
			// property: name=ipv4_address, type=STRING macro=copy_from_plan
			body.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv4Address = StringValueOrNil(varLoopDomainsToAddresses.Ipv4Address)
			// property: name=ipv6_address, type=STRING macro=copy_from_plan
			body.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv6Address = StringValueOrNil(varLoopDomainsToAddresses.Ipv6Address)
		}
	}
	// property: name=edns_packet_max, type=INTEGER macro=copy_from_plan
	body.EdnsPacketMax = Int64ValueOrNil(plan.EdnsPacketMax)
	// property: name=enable_dns_loop_detection, type=BOOLEAN macro=copy_from_plan
	body.EnableDnsLoopDetection = BoolValueOrNil(plan.EnableDnsLoopDetection)
	// property: name=enable_dnssec_proxy, type=BOOLEAN macro=copy_from_plan
	body.EnableDnssecProxy = BoolValueOrNil(plan.EnableDnssecProxy)
	// property: name=enable_strict_domain_name, type=BOOLEAN macro=copy_from_plan
	body.EnableStrictDomainName = BoolValueOrNil(plan.EnableStrictDomainName)
	// property: name=id, type=STRING macro=copy_from_plan
	body.Id = StringValueOrNil(plan.Id)
	// property: name=listen_dnsservicerole_id, type=STRING macro=copy_from_plan
	body.ListenDnsserviceroleId = StringValueOrNil(plan.ListenDnsserviceroleId)
	// property: name=listen_port, type=INTEGER macro=copy_from_plan
	body.ListenPort = Int64ValueOrNil(plan.ListenPort)
	// property: name=name, type=STRING macro=copy_from_plan
	body.Name = StringValueOrNil(plan.Name)
	// property: name=tags, type=SET_PRIMITIVE macro=copy_from_plan
	body.Tags = SetStringValueOrNil(ctx, plan.Tags)

	// convert body to map
	json_body, err := json.Marshal(body)
	if err != nil {
		resp.Diagnostics.AddError("error marshaling struct DnsServiceProfileV2N1 to JSON:", err.Error())
		return false
	}

	// process http json path
	request_body_string := string(json_body)
	// inject overrides
	request_body_string, _ = sjson.Delete(request_body_string, "id")
	request_body_string, _ = sjson.Delete(request_body_string, "_etag")
	request_body_string, _ = sjson.Set(request_body_string, "_schema", 0)
	// copy pointer
	create_request.RequestBody = &request_body_string

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, create_request)
	if create_request.ResponseErr != nil {
		tflog.Info(ctx, "create request failed for prismasdwan_dns_service_profile", map[string]any{
			"terraform_provider_function": "Create",
			"resource_name":               "prismasdwan_dns_service_profile",
			"path":                        create_request.FinalPath,
		})
		tflog.Debug(ctx, "create request failed for prismasdwan_dns_service_profile", map[string]any{
			"terraform_provider_function": "Create",
			"resource_name":               "prismasdwan_dns_service_profile",
			"path":                        create_request.FinalPath,
			"request":                     create_request.ToString(),
		})
		resp.Diagnostics.AddError("error creating prismasdwan_dns_service_profile", (*create_request.ResponseErr).Error())
		return false
	}

	// process http json path
	response_body_string := string(*create_request.ResponseBytes)
	// inject overrides
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// start copying attributes
	var ans sdwan_schema.DnsServiceProfileV2N1
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to DnsServiceProfileV2N1 in create", json_err.Error())
		return false
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return false
	}
	// ID Format: Id:Param1=Value1:Param2=Value2:...:ParamN=ValueN
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
		for p, v := range *create_request.PathParameters {
			idBuilder.WriteString(IdSeparator)
			idBuilder.WriteString(p)
			idBuilder.WriteString("=")
			idBuilder.WriteString(*v)
		}
	}
	// set the tf id for the resource created
	state.Tfid = types.StringValue(idBuilder.String())
	state.TfParameters = plan.TfParameters
	tflog.Info(ctx, "created prismasdwan_dns_service_profile with ID", map[string]any{"tfid": state.Tfid.ValueString()})

	// Store the answer to state. schema=DnsServiceProfileV2N1
	// copy_to_state: state=state prefix=rsModel ans=ans properties=20
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=authoritative_config, type=REFERENCE macro=copy_to_state
	if ans.AuthoritativeConfig == nil {
		state.AuthoritativeConfig = nil
	} else {
		state.AuthoritativeConfig = &rsModelAuthoritativeConfig{}
		// copy_to_state: state=state.AuthoritativeConfig prefix=rsModel ans=ans.AuthoritativeConfig properties=16
		// property: name=caa_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.CaaRecords == nil {
			state.AuthoritativeConfig.CaaRecords = nil
		} else if len(ans.AuthoritativeConfig.CaaRecords) == 0 {
			state.AuthoritativeConfig.CaaRecords = []rsModelCaaRecord{}
		} else {
			state.AuthoritativeConfig.CaaRecords = make([]rsModelCaaRecord, 0, len(ans.AuthoritativeConfig.CaaRecords))
			for varLoopCaaRecordsIndex, varLoopCaaRecords := range ans.AuthoritativeConfig.CaaRecords {
				// add a new item
				state.AuthoritativeConfig.CaaRecords = append(state.AuthoritativeConfig.CaaRecords, rsModelCaaRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex] prefix=rsModel ans=varLoopCaaRecords properties=4
				// property: name=flags, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Flags = types.StringPointerValue(varLoopCaaRecords.Flags)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Name = types.StringPointerValue(varLoopCaaRecords.Name)
				// property: name=tag, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Tag = types.StringPointerValue(varLoopCaaRecords.Tag)
				// property: name=value, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Value = types.StringPointerValue(varLoopCaaRecords.Value)
			}
		}
		// property: name=cname_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.CnameRecords == nil {
			state.AuthoritativeConfig.CnameRecords = nil
		} else if len(ans.AuthoritativeConfig.CnameRecords) == 0 {
			state.AuthoritativeConfig.CnameRecords = []rsModelCnameRecords{}
		} else {
			state.AuthoritativeConfig.CnameRecords = make([]rsModelCnameRecords, 0, len(ans.AuthoritativeConfig.CnameRecords))
			for varLoopCnameRecordsIndex, varLoopCnameRecords := range ans.AuthoritativeConfig.CnameRecords {
				// add a new item
				state.AuthoritativeConfig.CnameRecords = append(state.AuthoritativeConfig.CnameRecords, rsModelCnameRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex] prefix=rsModel ans=varLoopCnameRecords properties=3
				// property: name=name, type=ARRAY_PRIMITIVE macro=copy_to_state
				varName, errName := types.ListValueFrom(ctx, types.StringType, varLoopCnameRecords.Name)
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Name = varName
				resp.Diagnostics.Append(errName.Errors()...)
				// property: name=target, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Target = types.StringPointerValue(varLoopCnameRecords.Target)
				// property: name=ttl, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Ttl = types.Int64PointerValue(varLoopCnameRecords.Ttl)
			}
		}
		// property: name=dns_resource_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.DnsResourceRecords == nil {
			state.AuthoritativeConfig.DnsResourceRecords = nil
		} else if len(ans.AuthoritativeConfig.DnsResourceRecords) == 0 {
			state.AuthoritativeConfig.DnsResourceRecords = []rsModelDnsResourceRecords{}
		} else {
			state.AuthoritativeConfig.DnsResourceRecords = make([]rsModelDnsResourceRecords, 0, len(ans.AuthoritativeConfig.DnsResourceRecords))
			for varLoopDnsResourceRecordsIndex, varLoopDnsResourceRecords := range ans.AuthoritativeConfig.DnsResourceRecords {
				// add a new item
				state.AuthoritativeConfig.DnsResourceRecords = append(state.AuthoritativeConfig.DnsResourceRecords, rsModelDnsResourceRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex] prefix=rsModel ans=varLoopDnsResourceRecords properties=3
				// property: name=hex_data, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].HexData = types.StringPointerValue(varLoopDnsResourceRecords.HexData)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].Name = types.StringPointerValue(varLoopDnsResourceRecords.Name)
				// property: name=rr_number, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].RrNumber = types.Int64PointerValue(varLoopDnsResourceRecords.RrNumber)
			}
		}
		// property: name=host_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.HostRecords == nil {
			state.AuthoritativeConfig.HostRecords = nil
		} else if len(ans.AuthoritativeConfig.HostRecords) == 0 {
			state.AuthoritativeConfig.HostRecords = []rsModelHostRecord{}
		} else {
			state.AuthoritativeConfig.HostRecords = make([]rsModelHostRecord, 0, len(ans.AuthoritativeConfig.HostRecords))
			for varLoopHostRecordsIndex, varLoopHostRecords := range ans.AuthoritativeConfig.HostRecords {
				// add a new item
				state.AuthoritativeConfig.HostRecords = append(state.AuthoritativeConfig.HostRecords, rsModelHostRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex] prefix=rsModel ans=varLoopHostRecords properties=4
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
				varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopHostRecords.DomainNames)
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].DomainNames = varDomainNames
				resp.Diagnostics.Append(errDomainNames.Errors()...)
				// property: name=ipv4_address, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv4Address = types.StringPointerValue(varLoopHostRecords.Ipv4Address)
				// property: name=ipv6_address, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv6Address = types.StringPointerValue(varLoopHostRecords.Ipv6Address)
				// property: name=ttl, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ttl = types.Int64PointerValue(varLoopHostRecords.Ttl)
			}
		}
		// property: name=mx_host_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.MxHostRecords == nil {
			state.AuthoritativeConfig.MxHostRecords = nil
		} else if len(ans.AuthoritativeConfig.MxHostRecords) == 0 {
			state.AuthoritativeConfig.MxHostRecords = []rsModelMxHostRecord{}
		} else {
			state.AuthoritativeConfig.MxHostRecords = make([]rsModelMxHostRecord, 0, len(ans.AuthoritativeConfig.MxHostRecords))
			for varLoopMxHostRecordsIndex, varLoopMxHostRecords := range ans.AuthoritativeConfig.MxHostRecords {
				// add a new item
				state.AuthoritativeConfig.MxHostRecords = append(state.AuthoritativeConfig.MxHostRecords, rsModelMxHostRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex] prefix=rsModel ans=varLoopMxHostRecords properties=3
				// property: name=hostname, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Hostname = types.StringPointerValue(varLoopMxHostRecords.Hostname)
				// property: name=mx_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].MxName = types.StringPointerValue(varLoopMxHostRecords.MxName)
				// property: name=preference, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Preference = types.Int64PointerValue(varLoopMxHostRecords.Preference)
			}
		}
		// property: name=naptr_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.NaptrRecords == nil {
			state.AuthoritativeConfig.NaptrRecords = nil
		} else if len(ans.AuthoritativeConfig.NaptrRecords) == 0 {
			state.AuthoritativeConfig.NaptrRecords = []rsModelNaptrRecords{}
		} else {
			state.AuthoritativeConfig.NaptrRecords = make([]rsModelNaptrRecords, 0, len(ans.AuthoritativeConfig.NaptrRecords))
			for varLoopNaptrRecordsIndex, varLoopNaptrRecords := range ans.AuthoritativeConfig.NaptrRecords {
				// add a new item
				state.AuthoritativeConfig.NaptrRecords = append(state.AuthoritativeConfig.NaptrRecords, rsModelNaptrRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex] prefix=rsModel ans=varLoopNaptrRecords properties=7
				// property: name=flags, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Flags = types.StringPointerValue(varLoopNaptrRecords.Flags)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Name = types.StringPointerValue(varLoopNaptrRecords.Name)
				// property: name=order, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Order = types.Int64PointerValue(varLoopNaptrRecords.Order)
				// property: name=preference, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Preference = types.Int64PointerValue(varLoopNaptrRecords.Preference)
				// property: name=regexp, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Regexp = types.StringPointerValue(varLoopNaptrRecords.Regexp)
				// property: name=replacement, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Replacement = types.StringPointerValue(varLoopNaptrRecords.Replacement)
				// property: name=service, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Service = types.StringPointerValue(varLoopNaptrRecords.Service)
			}
		}
		// property: name=peers, type=ARRAY_PRIMITIVE macro=copy_to_state
		varPeers, errPeers := types.ListValueFrom(ctx, types.StringType, ans.AuthoritativeConfig.Peers)
		state.AuthoritativeConfig.Peers = varPeers
		resp.Diagnostics.Append(errPeers.Errors()...)
		// property: name=ptr_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.PtrRecords == nil {
			state.AuthoritativeConfig.PtrRecords = nil
		} else if len(ans.AuthoritativeConfig.PtrRecords) == 0 {
			state.AuthoritativeConfig.PtrRecords = []rsModelPtrRecords{}
		} else {
			state.AuthoritativeConfig.PtrRecords = make([]rsModelPtrRecords, 0, len(ans.AuthoritativeConfig.PtrRecords))
			for varLoopPtrRecordsIndex, varLoopPtrRecords := range ans.AuthoritativeConfig.PtrRecords {
				// add a new item
				state.AuthoritativeConfig.PtrRecords = append(state.AuthoritativeConfig.PtrRecords, rsModelPtrRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex] prefix=rsModel ans=varLoopPtrRecords properties=2
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Name = types.StringPointerValue(varLoopPtrRecords.Name)
				// property: name=target, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Target = types.StringPointerValue(varLoopPtrRecords.Target)
			}
		}
		// property: name=secondary_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
		varSecondaryServers, errSecondaryServers := types.ListValueFrom(ctx, types.StringType, ans.AuthoritativeConfig.SecondaryServers)
		state.AuthoritativeConfig.SecondaryServers = varSecondaryServers
		resp.Diagnostics.Append(errSecondaryServers.Errors()...)
		// property: name=servers, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Servers == nil {
			state.AuthoritativeConfig.Servers = nil
		} else if len(ans.AuthoritativeConfig.Servers) == 0 {
			state.AuthoritativeConfig.Servers = []rsModelServer{}
		} else {
			state.AuthoritativeConfig.Servers = make([]rsModelServer, 0, len(ans.AuthoritativeConfig.Servers))
			for varLoopServersIndex, varLoopServers := range ans.AuthoritativeConfig.Servers {
				// add a new item
				state.AuthoritativeConfig.Servers = append(state.AuthoritativeConfig.Servers, rsModelServer{})
				// copy_to_state: state=state.AuthoritativeConfig.Servers[varLoopServersIndex] prefix=rsModel ans=varLoopServers properties=2
				// property: name=dnsservicerole_id, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Servers[varLoopServersIndex].DnsserviceroleId = types.StringPointerValue(varLoopServers.DnsserviceroleId)
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Servers[varLoopServersIndex].DomainName = types.StringPointerValue(varLoopServers.DomainName)
			}
		}
		// property: name=soa, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Soa == nil {
			state.AuthoritativeConfig.Soa = nil
		} else if len(ans.AuthoritativeConfig.Soa) == 0 {
			state.AuthoritativeConfig.Soa = []rsModelSOA{}
		} else {
			state.AuthoritativeConfig.Soa = make([]rsModelSOA, 0, len(ans.AuthoritativeConfig.Soa))
			for varLoopSoaIndex, varLoopSoa := range ans.AuthoritativeConfig.Soa {
				// add a new item
				state.AuthoritativeConfig.Soa = append(state.AuthoritativeConfig.Soa, rsModelSOA{})
				// copy_to_state: state=state.AuthoritativeConfig.Soa[varLoopSoaIndex] prefix=rsModel ans=varLoopSoa properties=5
				// property: name=expiry, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Expiry = types.Int64PointerValue(varLoopSoa.Expiry)
				// property: name=host_master, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].HostMaster = types.StringPointerValue(varLoopSoa.HostMaster)
				// property: name=refresh, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Refresh = types.Int64PointerValue(varLoopSoa.Refresh)
				// property: name=retry, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Retry = types.Int64PointerValue(varLoopSoa.Retry)
				// property: name=serial_number, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].SerialNumber = types.Int64PointerValue(varLoopSoa.SerialNumber)
			}
		}
		// property: name=srv_hosts, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.SrvHosts == nil {
			state.AuthoritativeConfig.SrvHosts = nil
		} else if len(ans.AuthoritativeConfig.SrvHosts) == 0 {
			state.AuthoritativeConfig.SrvHosts = []rsModelSrvHost{}
		} else {
			state.AuthoritativeConfig.SrvHosts = make([]rsModelSrvHost, 0, len(ans.AuthoritativeConfig.SrvHosts))
			for varLoopSrvHostsIndex, varLoopSrvHosts := range ans.AuthoritativeConfig.SrvHosts {
				// add a new item
				state.AuthoritativeConfig.SrvHosts = append(state.AuthoritativeConfig.SrvHosts, rsModelSrvHost{})
				// copy_to_state: state=state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex] prefix=rsModel ans=varLoopSrvHosts properties=7
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].DomainName = types.StringPointerValue(varLoopSrvHosts.DomainName)
				// property: name=port, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Port = types.Int64PointerValue(varLoopSrvHosts.Port)
				// property: name=priority, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Priority = types.Int64PointerValue(varLoopSrvHosts.Priority)
				// property: name=protocol, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Protocol = types.StringPointerValue(varLoopSrvHosts.Protocol)
				// property: name=service, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Service = types.StringPointerValue(varLoopSrvHosts.Service)
				// property: name=target, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Target = types.Int64PointerValue(varLoopSrvHosts.Target)
				// property: name=weight, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Weight = types.Int64PointerValue(varLoopSrvHosts.Weight)
			}
		}
		// property: name=synth_domains, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.SynthDomains == nil {
			state.AuthoritativeConfig.SynthDomains = nil
		} else if len(ans.AuthoritativeConfig.SynthDomains) == 0 {
			state.AuthoritativeConfig.SynthDomains = []rsModelSynthDomain{}
		} else {
			state.AuthoritativeConfig.SynthDomains = make([]rsModelSynthDomain, 0, len(ans.AuthoritativeConfig.SynthDomains))
			for varLoopSynthDomainsIndex, varLoopSynthDomains := range ans.AuthoritativeConfig.SynthDomains {
				// add a new item
				state.AuthoritativeConfig.SynthDomains = append(state.AuthoritativeConfig.SynthDomains, rsModelSynthDomain{})
				// copy_to_state: state=state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex] prefix=rsModel ans=varLoopSynthDomains properties=5
				// property: name=domain, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Domain = types.StringPointerValue(varLoopSynthDomains.Domain)
				// property: name=end_ipaddress, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].EndIpaddress = types.StringPointerValue(varLoopSynthDomains.EndIpaddress)
				// property: name=ipaddress_prefix, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].IpaddressPrefix = types.StringPointerValue(varLoopSynthDomains.IpaddressPrefix)
				// property: name=prefix, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Prefix = types.StringPointerValue(varLoopSynthDomains.Prefix)
				// property: name=start_ipaddress, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].StartIpaddress = types.StringPointerValue(varLoopSynthDomains.StartIpaddress)
			}
		}
		// property: name=ttl, type=INTEGER macro=copy_to_state
		state.AuthoritativeConfig.Ttl = types.Int64PointerValue(ans.AuthoritativeConfig.Ttl)
		// property: name=txt_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.TxtRecords == nil {
			state.AuthoritativeConfig.TxtRecords = nil
		} else if len(ans.AuthoritativeConfig.TxtRecords) == 0 {
			state.AuthoritativeConfig.TxtRecords = []rsModelTxtRecord{}
		} else {
			state.AuthoritativeConfig.TxtRecords = make([]rsModelTxtRecord, 0, len(ans.AuthoritativeConfig.TxtRecords))
			for varLoopTxtRecordsIndex, varLoopTxtRecords := range ans.AuthoritativeConfig.TxtRecords {
				// add a new item
				state.AuthoritativeConfig.TxtRecords = append(state.AuthoritativeConfig.TxtRecords, rsModelTxtRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex] prefix=rsModel ans=varLoopTxtRecords properties=2
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].DomainName = types.StringPointerValue(varLoopTxtRecords.DomainName)
				// property: name=texts, type=ARRAY_PRIMITIVE macro=copy_to_state
				varTexts, errTexts := types.ListValueFrom(ctx, types.StringType, varLoopTxtRecords.Texts)
				state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].Texts = varTexts
				resp.Diagnostics.Append(errTexts.Errors()...)
			}
		}
		// property: name=zones, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Zones == nil {
			state.AuthoritativeConfig.Zones = nil
		} else if len(ans.AuthoritativeConfig.Zones) == 0 {
			state.AuthoritativeConfig.Zones = []rsModelZone{}
		} else {
			state.AuthoritativeConfig.Zones = make([]rsModelZone, 0, len(ans.AuthoritativeConfig.Zones))
			for varLoopZonesIndex, varLoopZones := range ans.AuthoritativeConfig.Zones {
				// add a new item
				state.AuthoritativeConfig.Zones = append(state.AuthoritativeConfig.Zones, rsModelZone{})
				// copy_to_state: state=state.AuthoritativeConfig.Zones[varLoopZonesIndex] prefix=rsModel ans=varLoopZones properties=3
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].DomainName = types.StringPointerValue(varLoopZones.DomainName)
				// property: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=copy_to_state
				varExcludePrefix, errExcludePrefix := types.ListValueFrom(ctx, types.StringType, varLoopZones.ExcludePrefix)
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].ExcludePrefix = varExcludePrefix
				resp.Diagnostics.Append(errExcludePrefix.Errors()...)
				// property: name=include_prefix, type=ARRAY_PRIMITIVE macro=copy_to_state
				varIncludePrefix, errIncludePrefix := types.ListValueFrom(ctx, types.StringType, varLoopZones.IncludePrefix)
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].IncludePrefix = varIncludePrefix
				resp.Diagnostics.Append(errIncludePrefix.Errors()...)
			}
		}
	}
	// property: name=cache_config, type=REFERENCE macro=copy_to_state
	if ans.CacheConfig == nil {
		state.CacheConfig = nil
	} else {
		state.CacheConfig = &rsModelCacheConfig{}
		// copy_to_state: state=state.CacheConfig prefix=rsModel ans=ans.CacheConfig properties=5
		// property: name=cache_size, type=INTEGER macro=copy_to_state
		state.CacheConfig.CacheSize = types.Int64PointerValue(ans.CacheConfig.CacheSize)
		// property: name=disable_negative_caching, type=BOOLEAN macro=copy_to_state
		state.CacheConfig.DisableNegativeCaching = types.BoolPointerValue(ans.CacheConfig.DisableNegativeCaching)
		// property: name=max_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.MaxCacheTtl = types.Int64PointerValue(ans.CacheConfig.MaxCacheTtl)
		// property: name=min_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.MinCacheTtl = types.Int64PointerValue(ans.CacheConfig.MinCacheTtl)
		// property: name=negative_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.NegativeCacheTtl = types.Int64PointerValue(ans.CacheConfig.NegativeCacheTtl)
	}
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=dns_forward_config, type=REFERENCE macro=copy_to_state
	if ans.DnsForwardConfig == nil {
		state.DnsForwardConfig = nil
	} else {
		state.DnsForwardConfig = &rsModelDnsForwardConfigV2{}
		// copy_to_state: state=state.DnsForwardConfig prefix=rsModel ans=ans.DnsForwardConfig properties=4
		// property: name=dns_servers, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsForwardConfig.DnsServers == nil {
			state.DnsForwardConfig.DnsServers = nil
		} else if len(ans.DnsForwardConfig.DnsServers) == 0 {
			state.DnsForwardConfig.DnsServers = []rsModelDnsServersV2{}
		} else {
			state.DnsForwardConfig.DnsServers = make([]rsModelDnsServersV2, 0, len(ans.DnsForwardConfig.DnsServers))
			for varLoopDnsServersIndex, varLoopDnsServers := range ans.DnsForwardConfig.DnsServers {
				// add a new item
				state.DnsForwardConfig.DnsServers = append(state.DnsForwardConfig.DnsServers, rsModelDnsServersV2{})
				// copy_to_state: state=state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex] prefix=rsModel ans=varLoopDnsServers properties=7
				// property: name=address_family, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].AddressFamily = types.StringPointerValue(varLoopDnsServers.AddressFamily)
				// property: name=dnsserver_ip, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverIp = types.StringPointerValue(varLoopDnsServers.DnsserverIp)
				// property: name=dnsserver_port, type=INTEGER macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverPort = types.Int64PointerValue(varLoopDnsServers.DnsserverPort)
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
				varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopDnsServers.DomainNames)
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DomainNames = varDomainNames
				resp.Diagnostics.Append(errDomainNames.Errors()...)
				// property: name=forward_dnsservicerole_id, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].ForwardDnsserviceroleId = types.StringPointerValue(varLoopDnsServers.ForwardDnsserviceroleId)
				// property: name=ip_prefix, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].IpPrefix = types.StringPointerValue(varLoopDnsServers.IpPrefix)
				// property: name=source_port, type=INTEGER macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].SourcePort = types.Int64PointerValue(varLoopDnsServers.SourcePort)
			}
		}
		// property: name=max_source_port, type=INTEGER macro=copy_to_state
		state.DnsForwardConfig.MaxSourcePort = types.Int64PointerValue(ans.DnsForwardConfig.MaxSourcePort)
		// property: name=min_source_port, type=INTEGER macro=copy_to_state
		state.DnsForwardConfig.MinSourcePort = types.Int64PointerValue(ans.DnsForwardConfig.MinSourcePort)
		// property: name=send_to_all_dns_servers, type=BOOLEAN macro=copy_to_state
		state.DnsForwardConfig.SendToAllDnsServers = types.BoolPointerValue(ans.DnsForwardConfig.SendToAllDnsServers)
	}
	// property: name=dns_queries_metadata, type=REFERENCE macro=copy_to_state
	if ans.DnsQueriesMetadata == nil {
		state.DnsQueriesMetadata = nil
	} else {
		state.DnsQueriesMetadata = &rsModelDnsQueriesMetadata{}
		// copy_to_state: state=state.DnsQueriesMetadata prefix=rsModel ans=ans.DnsQueriesMetadata properties=3
		// property: name=add_client_mac, type=REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddClientMac == nil {
			state.DnsQueriesMetadata.AddClientMac = nil
		} else {
			state.DnsQueriesMetadata.AddClientMac = &rsModelClientMac{}
			// copy_to_state: state=state.DnsQueriesMetadata.AddClientMac prefix=rsModel ans=ans.DnsQueriesMetadata.AddClientMac properties=1
			// property: name=mac_encoding_format, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddClientMac.MacEncodingFormat = types.StringPointerValue(ans.DnsQueriesMetadata.AddClientMac.MacEncodingFormat)
		}
		// property: name=add_customer_premises_equipment, type=REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddCustomerPremisesEquipment == nil {
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment = nil
		} else {
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment = &rsModelCustomerPremisesEquipment{}
			// copy_to_state: state=state.DnsQueriesMetadata.AddCustomerPremisesEquipment prefix=rsModel ans=ans.DnsQueriesMetadata.AddCustomerPremisesEquipment properties=2
			// property: name=identifier_text, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText = types.StringPointerValue(ans.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText)
			// property: name=type, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type = types.StringPointerValue(ans.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type)
		}
		// property: name=add_subnets, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddSubnets == nil {
			state.DnsQueriesMetadata.AddSubnets = nil
		} else if len(ans.DnsQueriesMetadata.AddSubnets) == 0 {
			state.DnsQueriesMetadata.AddSubnets = []rsModelSubnet{}
		} else {
			state.DnsQueriesMetadata.AddSubnets = make([]rsModelSubnet, 0, len(ans.DnsQueriesMetadata.AddSubnets))
			for varLoopAddSubnetsIndex, varLoopAddSubnets := range ans.DnsQueriesMetadata.AddSubnets {
				// add a new item
				state.DnsQueriesMetadata.AddSubnets = append(state.DnsQueriesMetadata.AddSubnets, rsModelSubnet{})
				// copy_to_state: state=state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex] prefix=rsModel ans=varLoopAddSubnets properties=4
				// property: name=ipv4_address, type=STRING macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4Address = types.StringPointerValue(varLoopAddSubnets.Ipv4Address)
				// property: name=ipv4_prefix_length, type=INTEGER macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4PrefixLength = types.Int64PointerValue(varLoopAddSubnets.Ipv4PrefixLength)
				// property: name=ipv6_address, type=STRING macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6Address = types.StringPointerValue(varLoopAddSubnets.Ipv6Address)
				// property: name=ipv6_prefix_length, type=INTEGER macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6PrefixLength = types.Int64PointerValue(varLoopAddSubnets.Ipv6PrefixLength)
			}
		}
	}
	// property: name=dns_rebind_config, type=REFERENCE macro=copy_to_state
	if ans.DnsRebindConfig == nil {
		state.DnsRebindConfig = nil
	} else {
		state.DnsRebindConfig = &rsModelDnsRebindConfig{}
		// copy_to_state: state=state.DnsRebindConfig prefix=rsModel ans=ans.DnsRebindConfig properties=3
		// property: name=enable_localhost_rebind, type=BOOLEAN macro=copy_to_state
		state.DnsRebindConfig.EnableLocalhostRebind = types.BoolPointerValue(ans.DnsRebindConfig.EnableLocalhostRebind)
		// property: name=rebind_domains, type=ARRAY_PRIMITIVE macro=copy_to_state
		varRebindDomains, errRebindDomains := types.ListValueFrom(ctx, types.StringType, ans.DnsRebindConfig.RebindDomains)
		state.DnsRebindConfig.RebindDomains = varRebindDomains
		resp.Diagnostics.Append(errRebindDomains.Errors()...)
		// property: name=stop_dns_rebind_privateip, type=BOOLEAN macro=copy_to_state
		state.DnsRebindConfig.StopDnsRebindPrivateip = types.BoolPointerValue(ans.DnsRebindConfig.StopDnsRebindPrivateip)
	}
	// property: name=dns_response_overrides, type=REFERENCE macro=copy_to_state
	if ans.DnsResponseOverrides == nil {
		state.DnsResponseOverrides = nil
	} else {
		state.DnsResponseOverrides = &rsModelDnsResponseOverrides{}
		// copy_to_state: state=state.DnsResponseOverrides prefix=rsModel ans=ans.DnsResponseOverrides properties=6
		// property: name=aliases, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsResponseOverrides.Aliases == nil {
			state.DnsResponseOverrides.Aliases = nil
		} else if len(ans.DnsResponseOverrides.Aliases) == 0 {
			state.DnsResponseOverrides.Aliases = []rsModelAlias{}
		} else {
			state.DnsResponseOverrides.Aliases = make([]rsModelAlias, 0, len(ans.DnsResponseOverrides.Aliases))
			for varLoopAliasesIndex, varLoopAliases := range ans.DnsResponseOverrides.Aliases {
				// add a new item
				state.DnsResponseOverrides.Aliases = append(state.DnsResponseOverrides.Aliases, rsModelAlias{})
				// copy_to_state: state=state.DnsResponseOverrides.Aliases[varLoopAliasesIndex] prefix=rsModel ans=varLoopAliases properties=5
				// property: name=mask, type=INTEGER macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].Mask = types.Int64PointerValue(varLoopAliases.Mask)
				// property: name=original_end_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalEndIp = types.StringPointerValue(varLoopAliases.OriginalEndIp)
				// property: name=original_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalIp = types.StringPointerValue(varLoopAliases.OriginalIp)
				// property: name=original_start_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalStartIp = types.StringPointerValue(varLoopAliases.OriginalStartIp)
				// property: name=replace_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].ReplaceIp = types.StringPointerValue(varLoopAliases.ReplaceIp)
			}
		}
		// property: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=copy_to_state
		varBogusNxDomains, errBogusNxDomains := types.ListValueFrom(ctx, types.StringType, ans.DnsResponseOverrides.BogusNxDomains)
		state.DnsResponseOverrides.BogusNxDomains = varBogusNxDomains
		resp.Diagnostics.Append(errBogusNxDomains.Errors()...)
		// property: name=disable_private_ip_lookups, type=BOOLEAN macro=copy_to_state
		state.DnsResponseOverrides.DisablePrivateIpLookups = types.BoolPointerValue(ans.DnsResponseOverrides.DisablePrivateIpLookups)
		// property: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=copy_to_state
		varIgnoreIpAddresses, errIgnoreIpAddresses := types.ListValueFrom(ctx, types.StringType, ans.DnsResponseOverrides.IgnoreIpAddresses)
		state.DnsResponseOverrides.IgnoreIpAddresses = varIgnoreIpAddresses
		resp.Diagnostics.Append(errIgnoreIpAddresses.Errors()...)
		// property: name=local_ttl, type=INTEGER macro=copy_to_state
		state.DnsResponseOverrides.LocalTtl = types.Int64PointerValue(ans.DnsResponseOverrides.LocalTtl)
		// property: name=max_ttl, type=INTEGER macro=copy_to_state
		state.DnsResponseOverrides.MaxTtl = types.Int64PointerValue(ans.DnsResponseOverrides.MaxTtl)
	}
	// property: name=dnssec_config, type=REFERENCE macro=copy_to_state
	if ans.DnssecConfig == nil {
		state.DnssecConfig = nil
	} else {
		state.DnssecConfig = &rsModelDnsSecConfig{}
		// copy_to_state: state=state.DnssecConfig prefix=rsModel ans=ans.DnssecConfig properties=4
		// property: name=disable_dnssec_timecheck, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.DisableDnssecTimecheck = types.BoolPointerValue(ans.DnssecConfig.DisableDnssecTimecheck)
		// property: name=dns_check_unsigned, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.DnsCheckUnsigned = types.BoolPointerValue(ans.DnssecConfig.DnsCheckUnsigned)
		// property: name=enabled, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.Enabled = types.BoolPointerValue(ans.DnssecConfig.Enabled)
		// property: name=trust_anchors, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnssecConfig.TrustAnchors == nil {
			state.DnssecConfig.TrustAnchors = nil
		} else if len(ans.DnssecConfig.TrustAnchors) == 0 {
			state.DnssecConfig.TrustAnchors = []rsModelTrustAnchor{}
		} else {
			state.DnssecConfig.TrustAnchors = make([]rsModelTrustAnchor, 0, len(ans.DnssecConfig.TrustAnchors))
			for varLoopTrustAnchorsIndex, varLoopTrustAnchors := range ans.DnssecConfig.TrustAnchors {
				// add a new item
				state.DnssecConfig.TrustAnchors = append(state.DnssecConfig.TrustAnchors, rsModelTrustAnchor{})
				// copy_to_state: state=state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex] prefix=rsModel ans=varLoopTrustAnchors properties=3
				// property: name=class, type=STRING macro=copy_to_state
				state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Class = types.StringPointerValue(varLoopTrustAnchors.Class)
				// property: name=domain, type=STRING macro=copy_to_state
				state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Domain = types.StringPointerValue(varLoopTrustAnchors.Domain)
				// property: name=key_digest, type=REFERENCE macro=copy_to_state
				if varLoopTrustAnchors.KeyDigest == nil {
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = nil
				} else {
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = &rsModelKeyDigest{}
					// copy_to_state: state=state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest prefix=rsModel ans=varLoopTrustAnchors.KeyDigest properties=4
					// property: name=algorithm, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Algorithm = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.Algorithm)
					// property: name=digest, type=STRING macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Digest = types.StringPointerValue(varLoopTrustAnchors.KeyDigest.Digest)
					// property: name=digest_type, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.DigestType = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.DigestType)
					// property: name=key_tag, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.KeyTag = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.KeyTag)
				}
			}
		}
	}
	// property: name=domains_to_addresses, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.DomainsToAddresses == nil {
		state.DomainsToAddresses = nil
	} else if len(ans.DomainsToAddresses) == 0 {
		state.DomainsToAddresses = []rsModelDomainsToAddress{}
	} else {
		state.DomainsToAddresses = make([]rsModelDomainsToAddress, 0, len(ans.DomainsToAddresses))
		for varLoopDomainsToAddressesIndex, varLoopDomainsToAddresses := range ans.DomainsToAddresses {
			// add a new item
			state.DomainsToAddresses = append(state.DomainsToAddresses, rsModelDomainsToAddress{})
			// copy_to_state: state=state.DomainsToAddresses[varLoopDomainsToAddressesIndex] prefix=rsModel ans=varLoopDomainsToAddresses properties=3
			// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
			varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopDomainsToAddresses.DomainNames)
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].DomainNames = varDomainNames
			resp.Diagnostics.Append(errDomainNames.Errors()...)
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv4Address = types.StringPointerValue(varLoopDomainsToAddresses.Ipv4Address)
			// property: name=ipv6_address, type=STRING macro=copy_to_state
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv6Address = types.StringPointerValue(varLoopDomainsToAddresses.Ipv6Address)
		}
	}
	// property: name=edns_packet_max, type=INTEGER macro=copy_to_state
	state.EdnsPacketMax = types.Int64PointerValue(ans.EdnsPacketMax)
	// property: name=enable_dns_loop_detection, type=BOOLEAN macro=copy_to_state
	state.EnableDnsLoopDetection = types.BoolPointerValue(ans.EnableDnsLoopDetection)
	// property: name=enable_dnssec_proxy, type=BOOLEAN macro=copy_to_state
	state.EnableDnssecProxy = types.BoolPointerValue(ans.EnableDnssecProxy)
	// property: name=enable_strict_domain_name, type=BOOLEAN macro=copy_to_state
	state.EnableStrictDomainName = types.BoolPointerValue(ans.EnableStrictDomainName)
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=listen_dnsservicerole_id, type=STRING macro=copy_to_state
	state.ListenDnsserviceroleId = types.StringPointerValue(ans.ListenDnsserviceroleId)
	// property: name=listen_port, type=INTEGER macro=copy_to_state
	state.ListenPort = types.Int64PointerValue(ans.ListenPort)
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	return true
}

func (r *dnsServiceProfileResource) doGet(ctx context.Context, state *rsModelDnsServiceProfileV2N1, savestate *rsModelDnsServiceProfileV2N1, State *tfsdk.State, resp *resource.ReadResponse) bool {
	// Basic logging.
	tfid := savestate.Tfid.ValueString()
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "prismasdwan_dns_service_profile",
		"tfid":                        tfid,
	})

	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 1 {
		resp.Diagnostics.AddError("error in prismasdwan_dns_service_profile ID format", "Expected 1 tokens")
		return false
	}

	// Prepare to read the config.
	svc := sdwan_client.NewClient(r.client)

	// Prepare input for the API endpoint.
	read_request := &sdwan_client.SdwanClientRequestResponse{}
	read_request.Method = "GET"
	read_request.Path = "/sdwan/v2.1/api/dnsserviceprofiles/{dnsservice_role_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, savestate.TfParameters)
	read_request.PathParameters = &params
	// add last parameter as ObjectID
	(*read_request.PathParameters)["dnsservice_role_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*read_request.PathParameters)[param[0]] = &param[1]
	}

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, read_request)
	if read_request.ResponseErr != nil {
		if IsObjectNotFound(*read_request.ResponseErr) {
			State.RemoveResource(ctx)
		} else if r.GetHttpStatusCode(read_request) == 404 {
			State.RemoveResource(ctx)
		} else {
			tflog.Info(ctx, "read request failed for prismasdwan_dns_service_profile", map[string]any{
				"terraform_provider_function": "Read",
				"resource_name":               "prismasdwan_dns_service_profile",
				"path":                        read_request.FinalPath,
				"request":                     read_request.ToString(),
			})
			resp.Diagnostics.AddError("error reading prismasdwan_dns_service_profile from sdwan servers", (*read_request.ResponseErr).Error())
		}
		return false
	}

	// process http json path
	response_body_string := string(*read_request.ResponseBytes)
	// inject overrides
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// Store the answer to state. schema=DnsServiceProfileV2N1
	state.Tfid = savestate.Tfid
	// copy parameters from savestate as they are
	if savestate.TfParameters.IsNull() {
		state.TfParameters = types.MapNull(types.StringType)
	} else {
		state.TfParameters = savestate.TfParameters
	}
	// start copying attributes
	var ans sdwan_schema.DnsServiceProfileV2N1
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to DnsServiceProfileV2N1 in read", json_err.Error())
		return false
	}
	// lets copy all items into state
	// copy_to_state: state=state prefix=rsModel ans=ans properties=20
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=authoritative_config, type=REFERENCE macro=copy_to_state
	if ans.AuthoritativeConfig == nil {
		state.AuthoritativeConfig = nil
	} else {
		state.AuthoritativeConfig = &rsModelAuthoritativeConfig{}
		// copy_to_state: state=state.AuthoritativeConfig prefix=rsModel ans=ans.AuthoritativeConfig properties=16
		// property: name=caa_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.CaaRecords == nil {
			state.AuthoritativeConfig.CaaRecords = nil
		} else if len(ans.AuthoritativeConfig.CaaRecords) == 0 {
			state.AuthoritativeConfig.CaaRecords = []rsModelCaaRecord{}
		} else {
			state.AuthoritativeConfig.CaaRecords = make([]rsModelCaaRecord, 0, len(ans.AuthoritativeConfig.CaaRecords))
			for varLoopCaaRecordsIndex, varLoopCaaRecords := range ans.AuthoritativeConfig.CaaRecords {
				// add a new item
				state.AuthoritativeConfig.CaaRecords = append(state.AuthoritativeConfig.CaaRecords, rsModelCaaRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex] prefix=rsModel ans=varLoopCaaRecords properties=4
				// property: name=flags, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Flags = types.StringPointerValue(varLoopCaaRecords.Flags)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Name = types.StringPointerValue(varLoopCaaRecords.Name)
				// property: name=tag, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Tag = types.StringPointerValue(varLoopCaaRecords.Tag)
				// property: name=value, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Value = types.StringPointerValue(varLoopCaaRecords.Value)
			}
		}
		// property: name=cname_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.CnameRecords == nil {
			state.AuthoritativeConfig.CnameRecords = nil
		} else if len(ans.AuthoritativeConfig.CnameRecords) == 0 {
			state.AuthoritativeConfig.CnameRecords = []rsModelCnameRecords{}
		} else {
			state.AuthoritativeConfig.CnameRecords = make([]rsModelCnameRecords, 0, len(ans.AuthoritativeConfig.CnameRecords))
			for varLoopCnameRecordsIndex, varLoopCnameRecords := range ans.AuthoritativeConfig.CnameRecords {
				// add a new item
				state.AuthoritativeConfig.CnameRecords = append(state.AuthoritativeConfig.CnameRecords, rsModelCnameRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex] prefix=rsModel ans=varLoopCnameRecords properties=3
				// property: name=name, type=ARRAY_PRIMITIVE macro=copy_to_state
				varName, errName := types.ListValueFrom(ctx, types.StringType, varLoopCnameRecords.Name)
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Name = varName
				resp.Diagnostics.Append(errName.Errors()...)
				// property: name=target, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Target = types.StringPointerValue(varLoopCnameRecords.Target)
				// property: name=ttl, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Ttl = types.Int64PointerValue(varLoopCnameRecords.Ttl)
			}
		}
		// property: name=dns_resource_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.DnsResourceRecords == nil {
			state.AuthoritativeConfig.DnsResourceRecords = nil
		} else if len(ans.AuthoritativeConfig.DnsResourceRecords) == 0 {
			state.AuthoritativeConfig.DnsResourceRecords = []rsModelDnsResourceRecords{}
		} else {
			state.AuthoritativeConfig.DnsResourceRecords = make([]rsModelDnsResourceRecords, 0, len(ans.AuthoritativeConfig.DnsResourceRecords))
			for varLoopDnsResourceRecordsIndex, varLoopDnsResourceRecords := range ans.AuthoritativeConfig.DnsResourceRecords {
				// add a new item
				state.AuthoritativeConfig.DnsResourceRecords = append(state.AuthoritativeConfig.DnsResourceRecords, rsModelDnsResourceRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex] prefix=rsModel ans=varLoopDnsResourceRecords properties=3
				// property: name=hex_data, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].HexData = types.StringPointerValue(varLoopDnsResourceRecords.HexData)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].Name = types.StringPointerValue(varLoopDnsResourceRecords.Name)
				// property: name=rr_number, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].RrNumber = types.Int64PointerValue(varLoopDnsResourceRecords.RrNumber)
			}
		}
		// property: name=host_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.HostRecords == nil {
			state.AuthoritativeConfig.HostRecords = nil
		} else if len(ans.AuthoritativeConfig.HostRecords) == 0 {
			state.AuthoritativeConfig.HostRecords = []rsModelHostRecord{}
		} else {
			state.AuthoritativeConfig.HostRecords = make([]rsModelHostRecord, 0, len(ans.AuthoritativeConfig.HostRecords))
			for varLoopHostRecordsIndex, varLoopHostRecords := range ans.AuthoritativeConfig.HostRecords {
				// add a new item
				state.AuthoritativeConfig.HostRecords = append(state.AuthoritativeConfig.HostRecords, rsModelHostRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex] prefix=rsModel ans=varLoopHostRecords properties=4
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
				varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopHostRecords.DomainNames)
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].DomainNames = varDomainNames
				resp.Diagnostics.Append(errDomainNames.Errors()...)
				// property: name=ipv4_address, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv4Address = types.StringPointerValue(varLoopHostRecords.Ipv4Address)
				// property: name=ipv6_address, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv6Address = types.StringPointerValue(varLoopHostRecords.Ipv6Address)
				// property: name=ttl, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ttl = types.Int64PointerValue(varLoopHostRecords.Ttl)
			}
		}
		// property: name=mx_host_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.MxHostRecords == nil {
			state.AuthoritativeConfig.MxHostRecords = nil
		} else if len(ans.AuthoritativeConfig.MxHostRecords) == 0 {
			state.AuthoritativeConfig.MxHostRecords = []rsModelMxHostRecord{}
		} else {
			state.AuthoritativeConfig.MxHostRecords = make([]rsModelMxHostRecord, 0, len(ans.AuthoritativeConfig.MxHostRecords))
			for varLoopMxHostRecordsIndex, varLoopMxHostRecords := range ans.AuthoritativeConfig.MxHostRecords {
				// add a new item
				state.AuthoritativeConfig.MxHostRecords = append(state.AuthoritativeConfig.MxHostRecords, rsModelMxHostRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex] prefix=rsModel ans=varLoopMxHostRecords properties=3
				// property: name=hostname, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Hostname = types.StringPointerValue(varLoopMxHostRecords.Hostname)
				// property: name=mx_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].MxName = types.StringPointerValue(varLoopMxHostRecords.MxName)
				// property: name=preference, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Preference = types.Int64PointerValue(varLoopMxHostRecords.Preference)
			}
		}
		// property: name=naptr_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.NaptrRecords == nil {
			state.AuthoritativeConfig.NaptrRecords = nil
		} else if len(ans.AuthoritativeConfig.NaptrRecords) == 0 {
			state.AuthoritativeConfig.NaptrRecords = []rsModelNaptrRecords{}
		} else {
			state.AuthoritativeConfig.NaptrRecords = make([]rsModelNaptrRecords, 0, len(ans.AuthoritativeConfig.NaptrRecords))
			for varLoopNaptrRecordsIndex, varLoopNaptrRecords := range ans.AuthoritativeConfig.NaptrRecords {
				// add a new item
				state.AuthoritativeConfig.NaptrRecords = append(state.AuthoritativeConfig.NaptrRecords, rsModelNaptrRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex] prefix=rsModel ans=varLoopNaptrRecords properties=7
				// property: name=flags, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Flags = types.StringPointerValue(varLoopNaptrRecords.Flags)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Name = types.StringPointerValue(varLoopNaptrRecords.Name)
				// property: name=order, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Order = types.Int64PointerValue(varLoopNaptrRecords.Order)
				// property: name=preference, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Preference = types.Int64PointerValue(varLoopNaptrRecords.Preference)
				// property: name=regexp, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Regexp = types.StringPointerValue(varLoopNaptrRecords.Regexp)
				// property: name=replacement, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Replacement = types.StringPointerValue(varLoopNaptrRecords.Replacement)
				// property: name=service, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Service = types.StringPointerValue(varLoopNaptrRecords.Service)
			}
		}
		// property: name=peers, type=ARRAY_PRIMITIVE macro=copy_to_state
		varPeers, errPeers := types.ListValueFrom(ctx, types.StringType, ans.AuthoritativeConfig.Peers)
		state.AuthoritativeConfig.Peers = varPeers
		resp.Diagnostics.Append(errPeers.Errors()...)
		// property: name=ptr_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.PtrRecords == nil {
			state.AuthoritativeConfig.PtrRecords = nil
		} else if len(ans.AuthoritativeConfig.PtrRecords) == 0 {
			state.AuthoritativeConfig.PtrRecords = []rsModelPtrRecords{}
		} else {
			state.AuthoritativeConfig.PtrRecords = make([]rsModelPtrRecords, 0, len(ans.AuthoritativeConfig.PtrRecords))
			for varLoopPtrRecordsIndex, varLoopPtrRecords := range ans.AuthoritativeConfig.PtrRecords {
				// add a new item
				state.AuthoritativeConfig.PtrRecords = append(state.AuthoritativeConfig.PtrRecords, rsModelPtrRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex] prefix=rsModel ans=varLoopPtrRecords properties=2
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Name = types.StringPointerValue(varLoopPtrRecords.Name)
				// property: name=target, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Target = types.StringPointerValue(varLoopPtrRecords.Target)
			}
		}
		// property: name=secondary_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
		varSecondaryServers, errSecondaryServers := types.ListValueFrom(ctx, types.StringType, ans.AuthoritativeConfig.SecondaryServers)
		state.AuthoritativeConfig.SecondaryServers = varSecondaryServers
		resp.Diagnostics.Append(errSecondaryServers.Errors()...)
		// property: name=servers, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Servers == nil {
			state.AuthoritativeConfig.Servers = nil
		} else if len(ans.AuthoritativeConfig.Servers) == 0 {
			state.AuthoritativeConfig.Servers = []rsModelServer{}
		} else {
			state.AuthoritativeConfig.Servers = make([]rsModelServer, 0, len(ans.AuthoritativeConfig.Servers))
			for varLoopServersIndex, varLoopServers := range ans.AuthoritativeConfig.Servers {
				// add a new item
				state.AuthoritativeConfig.Servers = append(state.AuthoritativeConfig.Servers, rsModelServer{})
				// copy_to_state: state=state.AuthoritativeConfig.Servers[varLoopServersIndex] prefix=rsModel ans=varLoopServers properties=2
				// property: name=dnsservicerole_id, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Servers[varLoopServersIndex].DnsserviceroleId = types.StringPointerValue(varLoopServers.DnsserviceroleId)
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Servers[varLoopServersIndex].DomainName = types.StringPointerValue(varLoopServers.DomainName)
			}
		}
		// property: name=soa, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Soa == nil {
			state.AuthoritativeConfig.Soa = nil
		} else if len(ans.AuthoritativeConfig.Soa) == 0 {
			state.AuthoritativeConfig.Soa = []rsModelSOA{}
		} else {
			state.AuthoritativeConfig.Soa = make([]rsModelSOA, 0, len(ans.AuthoritativeConfig.Soa))
			for varLoopSoaIndex, varLoopSoa := range ans.AuthoritativeConfig.Soa {
				// add a new item
				state.AuthoritativeConfig.Soa = append(state.AuthoritativeConfig.Soa, rsModelSOA{})
				// copy_to_state: state=state.AuthoritativeConfig.Soa[varLoopSoaIndex] prefix=rsModel ans=varLoopSoa properties=5
				// property: name=expiry, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Expiry = types.Int64PointerValue(varLoopSoa.Expiry)
				// property: name=host_master, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].HostMaster = types.StringPointerValue(varLoopSoa.HostMaster)
				// property: name=refresh, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Refresh = types.Int64PointerValue(varLoopSoa.Refresh)
				// property: name=retry, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Retry = types.Int64PointerValue(varLoopSoa.Retry)
				// property: name=serial_number, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].SerialNumber = types.Int64PointerValue(varLoopSoa.SerialNumber)
			}
		}
		// property: name=srv_hosts, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.SrvHosts == nil {
			state.AuthoritativeConfig.SrvHosts = nil
		} else if len(ans.AuthoritativeConfig.SrvHosts) == 0 {
			state.AuthoritativeConfig.SrvHosts = []rsModelSrvHost{}
		} else {
			state.AuthoritativeConfig.SrvHosts = make([]rsModelSrvHost, 0, len(ans.AuthoritativeConfig.SrvHosts))
			for varLoopSrvHostsIndex, varLoopSrvHosts := range ans.AuthoritativeConfig.SrvHosts {
				// add a new item
				state.AuthoritativeConfig.SrvHosts = append(state.AuthoritativeConfig.SrvHosts, rsModelSrvHost{})
				// copy_to_state: state=state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex] prefix=rsModel ans=varLoopSrvHosts properties=7
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].DomainName = types.StringPointerValue(varLoopSrvHosts.DomainName)
				// property: name=port, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Port = types.Int64PointerValue(varLoopSrvHosts.Port)
				// property: name=priority, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Priority = types.Int64PointerValue(varLoopSrvHosts.Priority)
				// property: name=protocol, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Protocol = types.StringPointerValue(varLoopSrvHosts.Protocol)
				// property: name=service, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Service = types.StringPointerValue(varLoopSrvHosts.Service)
				// property: name=target, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Target = types.Int64PointerValue(varLoopSrvHosts.Target)
				// property: name=weight, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Weight = types.Int64PointerValue(varLoopSrvHosts.Weight)
			}
		}
		// property: name=synth_domains, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.SynthDomains == nil {
			state.AuthoritativeConfig.SynthDomains = nil
		} else if len(ans.AuthoritativeConfig.SynthDomains) == 0 {
			state.AuthoritativeConfig.SynthDomains = []rsModelSynthDomain{}
		} else {
			state.AuthoritativeConfig.SynthDomains = make([]rsModelSynthDomain, 0, len(ans.AuthoritativeConfig.SynthDomains))
			for varLoopSynthDomainsIndex, varLoopSynthDomains := range ans.AuthoritativeConfig.SynthDomains {
				// add a new item
				state.AuthoritativeConfig.SynthDomains = append(state.AuthoritativeConfig.SynthDomains, rsModelSynthDomain{})
				// copy_to_state: state=state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex] prefix=rsModel ans=varLoopSynthDomains properties=5
				// property: name=domain, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Domain = types.StringPointerValue(varLoopSynthDomains.Domain)
				// property: name=end_ipaddress, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].EndIpaddress = types.StringPointerValue(varLoopSynthDomains.EndIpaddress)
				// property: name=ipaddress_prefix, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].IpaddressPrefix = types.StringPointerValue(varLoopSynthDomains.IpaddressPrefix)
				// property: name=prefix, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Prefix = types.StringPointerValue(varLoopSynthDomains.Prefix)
				// property: name=start_ipaddress, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].StartIpaddress = types.StringPointerValue(varLoopSynthDomains.StartIpaddress)
			}
		}
		// property: name=ttl, type=INTEGER macro=copy_to_state
		state.AuthoritativeConfig.Ttl = types.Int64PointerValue(ans.AuthoritativeConfig.Ttl)
		// property: name=txt_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.TxtRecords == nil {
			state.AuthoritativeConfig.TxtRecords = nil
		} else if len(ans.AuthoritativeConfig.TxtRecords) == 0 {
			state.AuthoritativeConfig.TxtRecords = []rsModelTxtRecord{}
		} else {
			state.AuthoritativeConfig.TxtRecords = make([]rsModelTxtRecord, 0, len(ans.AuthoritativeConfig.TxtRecords))
			for varLoopTxtRecordsIndex, varLoopTxtRecords := range ans.AuthoritativeConfig.TxtRecords {
				// add a new item
				state.AuthoritativeConfig.TxtRecords = append(state.AuthoritativeConfig.TxtRecords, rsModelTxtRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex] prefix=rsModel ans=varLoopTxtRecords properties=2
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].DomainName = types.StringPointerValue(varLoopTxtRecords.DomainName)
				// property: name=texts, type=ARRAY_PRIMITIVE macro=copy_to_state
				varTexts, errTexts := types.ListValueFrom(ctx, types.StringType, varLoopTxtRecords.Texts)
				state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].Texts = varTexts
				resp.Diagnostics.Append(errTexts.Errors()...)
			}
		}
		// property: name=zones, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Zones == nil {
			state.AuthoritativeConfig.Zones = nil
		} else if len(ans.AuthoritativeConfig.Zones) == 0 {
			state.AuthoritativeConfig.Zones = []rsModelZone{}
		} else {
			state.AuthoritativeConfig.Zones = make([]rsModelZone, 0, len(ans.AuthoritativeConfig.Zones))
			for varLoopZonesIndex, varLoopZones := range ans.AuthoritativeConfig.Zones {
				// add a new item
				state.AuthoritativeConfig.Zones = append(state.AuthoritativeConfig.Zones, rsModelZone{})
				// copy_to_state: state=state.AuthoritativeConfig.Zones[varLoopZonesIndex] prefix=rsModel ans=varLoopZones properties=3
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].DomainName = types.StringPointerValue(varLoopZones.DomainName)
				// property: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=copy_to_state
				varExcludePrefix, errExcludePrefix := types.ListValueFrom(ctx, types.StringType, varLoopZones.ExcludePrefix)
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].ExcludePrefix = varExcludePrefix
				resp.Diagnostics.Append(errExcludePrefix.Errors()...)
				// property: name=include_prefix, type=ARRAY_PRIMITIVE macro=copy_to_state
				varIncludePrefix, errIncludePrefix := types.ListValueFrom(ctx, types.StringType, varLoopZones.IncludePrefix)
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].IncludePrefix = varIncludePrefix
				resp.Diagnostics.Append(errIncludePrefix.Errors()...)
			}
		}
	}
	// property: name=cache_config, type=REFERENCE macro=copy_to_state
	if ans.CacheConfig == nil {
		state.CacheConfig = nil
	} else {
		state.CacheConfig = &rsModelCacheConfig{}
		// copy_to_state: state=state.CacheConfig prefix=rsModel ans=ans.CacheConfig properties=5
		// property: name=cache_size, type=INTEGER macro=copy_to_state
		state.CacheConfig.CacheSize = types.Int64PointerValue(ans.CacheConfig.CacheSize)
		// property: name=disable_negative_caching, type=BOOLEAN macro=copy_to_state
		state.CacheConfig.DisableNegativeCaching = types.BoolPointerValue(ans.CacheConfig.DisableNegativeCaching)
		// property: name=max_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.MaxCacheTtl = types.Int64PointerValue(ans.CacheConfig.MaxCacheTtl)
		// property: name=min_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.MinCacheTtl = types.Int64PointerValue(ans.CacheConfig.MinCacheTtl)
		// property: name=negative_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.NegativeCacheTtl = types.Int64PointerValue(ans.CacheConfig.NegativeCacheTtl)
	}
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=dns_forward_config, type=REFERENCE macro=copy_to_state
	if ans.DnsForwardConfig == nil {
		state.DnsForwardConfig = nil
	} else {
		state.DnsForwardConfig = &rsModelDnsForwardConfigV2{}
		// copy_to_state: state=state.DnsForwardConfig prefix=rsModel ans=ans.DnsForwardConfig properties=4
		// property: name=dns_servers, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsForwardConfig.DnsServers == nil {
			state.DnsForwardConfig.DnsServers = nil
		} else if len(ans.DnsForwardConfig.DnsServers) == 0 {
			state.DnsForwardConfig.DnsServers = []rsModelDnsServersV2{}
		} else {
			state.DnsForwardConfig.DnsServers = make([]rsModelDnsServersV2, 0, len(ans.DnsForwardConfig.DnsServers))
			for varLoopDnsServersIndex, varLoopDnsServers := range ans.DnsForwardConfig.DnsServers {
				// add a new item
				state.DnsForwardConfig.DnsServers = append(state.DnsForwardConfig.DnsServers, rsModelDnsServersV2{})
				// copy_to_state: state=state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex] prefix=rsModel ans=varLoopDnsServers properties=7
				// property: name=address_family, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].AddressFamily = types.StringPointerValue(varLoopDnsServers.AddressFamily)
				// property: name=dnsserver_ip, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverIp = types.StringPointerValue(varLoopDnsServers.DnsserverIp)
				// property: name=dnsserver_port, type=INTEGER macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverPort = types.Int64PointerValue(varLoopDnsServers.DnsserverPort)
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
				varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopDnsServers.DomainNames)
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DomainNames = varDomainNames
				resp.Diagnostics.Append(errDomainNames.Errors()...)
				// property: name=forward_dnsservicerole_id, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].ForwardDnsserviceroleId = types.StringPointerValue(varLoopDnsServers.ForwardDnsserviceroleId)
				// property: name=ip_prefix, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].IpPrefix = types.StringPointerValue(varLoopDnsServers.IpPrefix)
				// property: name=source_port, type=INTEGER macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].SourcePort = types.Int64PointerValue(varLoopDnsServers.SourcePort)
			}
		}
		// property: name=max_source_port, type=INTEGER macro=copy_to_state
		state.DnsForwardConfig.MaxSourcePort = types.Int64PointerValue(ans.DnsForwardConfig.MaxSourcePort)
		// property: name=min_source_port, type=INTEGER macro=copy_to_state
		state.DnsForwardConfig.MinSourcePort = types.Int64PointerValue(ans.DnsForwardConfig.MinSourcePort)
		// property: name=send_to_all_dns_servers, type=BOOLEAN macro=copy_to_state
		state.DnsForwardConfig.SendToAllDnsServers = types.BoolPointerValue(ans.DnsForwardConfig.SendToAllDnsServers)
	}
	// property: name=dns_queries_metadata, type=REFERENCE macro=copy_to_state
	if ans.DnsQueriesMetadata == nil {
		state.DnsQueriesMetadata = nil
	} else {
		state.DnsQueriesMetadata = &rsModelDnsQueriesMetadata{}
		// copy_to_state: state=state.DnsQueriesMetadata prefix=rsModel ans=ans.DnsQueriesMetadata properties=3
		// property: name=add_client_mac, type=REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddClientMac == nil {
			state.DnsQueriesMetadata.AddClientMac = nil
		} else {
			state.DnsQueriesMetadata.AddClientMac = &rsModelClientMac{}
			// copy_to_state: state=state.DnsQueriesMetadata.AddClientMac prefix=rsModel ans=ans.DnsQueriesMetadata.AddClientMac properties=1
			// property: name=mac_encoding_format, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddClientMac.MacEncodingFormat = types.StringPointerValue(ans.DnsQueriesMetadata.AddClientMac.MacEncodingFormat)
		}
		// property: name=add_customer_premises_equipment, type=REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddCustomerPremisesEquipment == nil {
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment = nil
		} else {
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment = &rsModelCustomerPremisesEquipment{}
			// copy_to_state: state=state.DnsQueriesMetadata.AddCustomerPremisesEquipment prefix=rsModel ans=ans.DnsQueriesMetadata.AddCustomerPremisesEquipment properties=2
			// property: name=identifier_text, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText = types.StringPointerValue(ans.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText)
			// property: name=type, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type = types.StringPointerValue(ans.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type)
		}
		// property: name=add_subnets, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddSubnets == nil {
			state.DnsQueriesMetadata.AddSubnets = nil
		} else if len(ans.DnsQueriesMetadata.AddSubnets) == 0 {
			state.DnsQueriesMetadata.AddSubnets = []rsModelSubnet{}
		} else {
			state.DnsQueriesMetadata.AddSubnets = make([]rsModelSubnet, 0, len(ans.DnsQueriesMetadata.AddSubnets))
			for varLoopAddSubnetsIndex, varLoopAddSubnets := range ans.DnsQueriesMetadata.AddSubnets {
				// add a new item
				state.DnsQueriesMetadata.AddSubnets = append(state.DnsQueriesMetadata.AddSubnets, rsModelSubnet{})
				// copy_to_state: state=state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex] prefix=rsModel ans=varLoopAddSubnets properties=4
				// property: name=ipv4_address, type=STRING macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4Address = types.StringPointerValue(varLoopAddSubnets.Ipv4Address)
				// property: name=ipv4_prefix_length, type=INTEGER macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4PrefixLength = types.Int64PointerValue(varLoopAddSubnets.Ipv4PrefixLength)
				// property: name=ipv6_address, type=STRING macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6Address = types.StringPointerValue(varLoopAddSubnets.Ipv6Address)
				// property: name=ipv6_prefix_length, type=INTEGER macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6PrefixLength = types.Int64PointerValue(varLoopAddSubnets.Ipv6PrefixLength)
			}
		}
	}
	// property: name=dns_rebind_config, type=REFERENCE macro=copy_to_state
	if ans.DnsRebindConfig == nil {
		state.DnsRebindConfig = nil
	} else {
		state.DnsRebindConfig = &rsModelDnsRebindConfig{}
		// copy_to_state: state=state.DnsRebindConfig prefix=rsModel ans=ans.DnsRebindConfig properties=3
		// property: name=enable_localhost_rebind, type=BOOLEAN macro=copy_to_state
		state.DnsRebindConfig.EnableLocalhostRebind = types.BoolPointerValue(ans.DnsRebindConfig.EnableLocalhostRebind)
		// property: name=rebind_domains, type=ARRAY_PRIMITIVE macro=copy_to_state
		varRebindDomains, errRebindDomains := types.ListValueFrom(ctx, types.StringType, ans.DnsRebindConfig.RebindDomains)
		state.DnsRebindConfig.RebindDomains = varRebindDomains
		resp.Diagnostics.Append(errRebindDomains.Errors()...)
		// property: name=stop_dns_rebind_privateip, type=BOOLEAN macro=copy_to_state
		state.DnsRebindConfig.StopDnsRebindPrivateip = types.BoolPointerValue(ans.DnsRebindConfig.StopDnsRebindPrivateip)
	}
	// property: name=dns_response_overrides, type=REFERENCE macro=copy_to_state
	if ans.DnsResponseOverrides == nil {
		state.DnsResponseOverrides = nil
	} else {
		state.DnsResponseOverrides = &rsModelDnsResponseOverrides{}
		// copy_to_state: state=state.DnsResponseOverrides prefix=rsModel ans=ans.DnsResponseOverrides properties=6
		// property: name=aliases, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsResponseOverrides.Aliases == nil {
			state.DnsResponseOverrides.Aliases = nil
		} else if len(ans.DnsResponseOverrides.Aliases) == 0 {
			state.DnsResponseOverrides.Aliases = []rsModelAlias{}
		} else {
			state.DnsResponseOverrides.Aliases = make([]rsModelAlias, 0, len(ans.DnsResponseOverrides.Aliases))
			for varLoopAliasesIndex, varLoopAliases := range ans.DnsResponseOverrides.Aliases {
				// add a new item
				state.DnsResponseOverrides.Aliases = append(state.DnsResponseOverrides.Aliases, rsModelAlias{})
				// copy_to_state: state=state.DnsResponseOverrides.Aliases[varLoopAliasesIndex] prefix=rsModel ans=varLoopAliases properties=5
				// property: name=mask, type=INTEGER macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].Mask = types.Int64PointerValue(varLoopAliases.Mask)
				// property: name=original_end_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalEndIp = types.StringPointerValue(varLoopAliases.OriginalEndIp)
				// property: name=original_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalIp = types.StringPointerValue(varLoopAliases.OriginalIp)
				// property: name=original_start_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalStartIp = types.StringPointerValue(varLoopAliases.OriginalStartIp)
				// property: name=replace_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].ReplaceIp = types.StringPointerValue(varLoopAliases.ReplaceIp)
			}
		}
		// property: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=copy_to_state
		varBogusNxDomains, errBogusNxDomains := types.ListValueFrom(ctx, types.StringType, ans.DnsResponseOverrides.BogusNxDomains)
		state.DnsResponseOverrides.BogusNxDomains = varBogusNxDomains
		resp.Diagnostics.Append(errBogusNxDomains.Errors()...)
		// property: name=disable_private_ip_lookups, type=BOOLEAN macro=copy_to_state
		state.DnsResponseOverrides.DisablePrivateIpLookups = types.BoolPointerValue(ans.DnsResponseOverrides.DisablePrivateIpLookups)
		// property: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=copy_to_state
		varIgnoreIpAddresses, errIgnoreIpAddresses := types.ListValueFrom(ctx, types.StringType, ans.DnsResponseOverrides.IgnoreIpAddresses)
		state.DnsResponseOverrides.IgnoreIpAddresses = varIgnoreIpAddresses
		resp.Diagnostics.Append(errIgnoreIpAddresses.Errors()...)
		// property: name=local_ttl, type=INTEGER macro=copy_to_state
		state.DnsResponseOverrides.LocalTtl = types.Int64PointerValue(ans.DnsResponseOverrides.LocalTtl)
		// property: name=max_ttl, type=INTEGER macro=copy_to_state
		state.DnsResponseOverrides.MaxTtl = types.Int64PointerValue(ans.DnsResponseOverrides.MaxTtl)
	}
	// property: name=dnssec_config, type=REFERENCE macro=copy_to_state
	if ans.DnssecConfig == nil {
		state.DnssecConfig = nil
	} else {
		state.DnssecConfig = &rsModelDnsSecConfig{}
		// copy_to_state: state=state.DnssecConfig prefix=rsModel ans=ans.DnssecConfig properties=4
		// property: name=disable_dnssec_timecheck, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.DisableDnssecTimecheck = types.BoolPointerValue(ans.DnssecConfig.DisableDnssecTimecheck)
		// property: name=dns_check_unsigned, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.DnsCheckUnsigned = types.BoolPointerValue(ans.DnssecConfig.DnsCheckUnsigned)
		// property: name=enabled, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.Enabled = types.BoolPointerValue(ans.DnssecConfig.Enabled)
		// property: name=trust_anchors, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnssecConfig.TrustAnchors == nil {
			state.DnssecConfig.TrustAnchors = nil
		} else if len(ans.DnssecConfig.TrustAnchors) == 0 {
			state.DnssecConfig.TrustAnchors = []rsModelTrustAnchor{}
		} else {
			state.DnssecConfig.TrustAnchors = make([]rsModelTrustAnchor, 0, len(ans.DnssecConfig.TrustAnchors))
			for varLoopTrustAnchorsIndex, varLoopTrustAnchors := range ans.DnssecConfig.TrustAnchors {
				// add a new item
				state.DnssecConfig.TrustAnchors = append(state.DnssecConfig.TrustAnchors, rsModelTrustAnchor{})
				// copy_to_state: state=state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex] prefix=rsModel ans=varLoopTrustAnchors properties=3
				// property: name=class, type=STRING macro=copy_to_state
				state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Class = types.StringPointerValue(varLoopTrustAnchors.Class)
				// property: name=domain, type=STRING macro=copy_to_state
				state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Domain = types.StringPointerValue(varLoopTrustAnchors.Domain)
				// property: name=key_digest, type=REFERENCE macro=copy_to_state
				if varLoopTrustAnchors.KeyDigest == nil {
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = nil
				} else {
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = &rsModelKeyDigest{}
					// copy_to_state: state=state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest prefix=rsModel ans=varLoopTrustAnchors.KeyDigest properties=4
					// property: name=algorithm, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Algorithm = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.Algorithm)
					// property: name=digest, type=STRING macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Digest = types.StringPointerValue(varLoopTrustAnchors.KeyDigest.Digest)
					// property: name=digest_type, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.DigestType = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.DigestType)
					// property: name=key_tag, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.KeyTag = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.KeyTag)
				}
			}
		}
	}
	// property: name=domains_to_addresses, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.DomainsToAddresses == nil {
		state.DomainsToAddresses = nil
	} else if len(ans.DomainsToAddresses) == 0 {
		state.DomainsToAddresses = []rsModelDomainsToAddress{}
	} else {
		state.DomainsToAddresses = make([]rsModelDomainsToAddress, 0, len(ans.DomainsToAddresses))
		for varLoopDomainsToAddressesIndex, varLoopDomainsToAddresses := range ans.DomainsToAddresses {
			// add a new item
			state.DomainsToAddresses = append(state.DomainsToAddresses, rsModelDomainsToAddress{})
			// copy_to_state: state=state.DomainsToAddresses[varLoopDomainsToAddressesIndex] prefix=rsModel ans=varLoopDomainsToAddresses properties=3
			// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
			varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopDomainsToAddresses.DomainNames)
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].DomainNames = varDomainNames
			resp.Diagnostics.Append(errDomainNames.Errors()...)
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv4Address = types.StringPointerValue(varLoopDomainsToAddresses.Ipv4Address)
			// property: name=ipv6_address, type=STRING macro=copy_to_state
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv6Address = types.StringPointerValue(varLoopDomainsToAddresses.Ipv6Address)
		}
	}
	// property: name=edns_packet_max, type=INTEGER macro=copy_to_state
	state.EdnsPacketMax = types.Int64PointerValue(ans.EdnsPacketMax)
	// property: name=enable_dns_loop_detection, type=BOOLEAN macro=copy_to_state
	state.EnableDnsLoopDetection = types.BoolPointerValue(ans.EnableDnsLoopDetection)
	// property: name=enable_dnssec_proxy, type=BOOLEAN macro=copy_to_state
	state.EnableDnssecProxy = types.BoolPointerValue(ans.EnableDnssecProxy)
	// property: name=enable_strict_domain_name, type=BOOLEAN macro=copy_to_state
	state.EnableStrictDomainName = types.BoolPointerValue(ans.EnableStrictDomainName)
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=listen_dnsservicerole_id, type=STRING macro=copy_to_state
	state.ListenDnsserviceroleId = types.StringPointerValue(ans.ListenDnsserviceroleId)
	// property: name=listen_port, type=INTEGER macro=copy_to_state
	state.ListenPort = types.Int64PointerValue(ans.ListenPort)
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	return true
}

func (r *dnsServiceProfileResource) doPut(ctx context.Context, plan *rsModelDnsServiceProfileV2N1, state *rsModelDnsServiceProfileV2N1, State *tfsdk.State, resp *resource.UpdateResponse) bool {
	state_tfid := state.Tfid.ValueString()
	plan_tfid := plan.Tfid.ValueString()
	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "prismasdwan_dns_service_profile",
		"state_tfid":                  state_tfid,
		"plan_tfid":                   plan_tfid,
	})

	// both TFID must be SAME!!!
	if state_tfid != plan_tfid {
		resp.Diagnostics.AddError("error updating prismasdwan_dns_service_profile", "state and plan TFID do not match")
		return false
	}

	// split tokens
	tokens := strings.Split(state_tfid, IdSeparator)
	if len(tokens) != 1 {
		resp.Diagnostics.AddError("error in prismasdwan_dns_service_profile ID format", "Expected 1 tokens")
		return false
	}

	// Prepare input for the API endpoint.
	put_request := &sdwan_client.SdwanClientRequestResponse{}
	put_request.Method = "PUT"
	put_request.Path = "/sdwan/v2.1/api/dnsserviceprofiles/{dnsservice_role_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, state.TfParameters)
	put_request.PathParameters = &params
	// add last parameter as ObjectID
	(*put_request.PathParameters)["dnsservice_role_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*put_request.PathParameters)[param[0]] = &param[1]
	}

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// prepare request from state
	var body = &sdwan_schema.DnsServiceProfileV2N1{}

	// now we create the JSON request from the state/plan created by TF
	// below copy code generated from macro copy_from_plan_or_state
	// copy_from_plan_or_state: body=body prefix=rsModel state=state plan=plan properties=20
	// property: name=_etag, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Etag = ValueInt64PointerFromPlanOrState(plan.Etag, state.Etag)
	} else {
		body.Etag = Int64ValueOrNil(plan.Etag)
	}
	// property: name=_schema, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.Schema = ValueInt64PointerFromPlanOrState(plan.Schema, state.Schema)
	} else {
		body.Schema = Int64ValueOrNil(plan.Schema)
	}
	// property: name=authoritative_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.AuthoritativeConfig == nil {
		body.AuthoritativeConfig = nil
	} else {
		body.AuthoritativeConfig = &sdwan_schema.AuthoritativeConfig{}
		// copy_from_plan_or_state: body=body.AuthoritativeConfig prefix=rsModel state=state.AuthoritativeConfig plan=plan.AuthoritativeConfig properties=16
		// property: name=caa_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.CaaRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.CaaRecords == nil) {
			body.AuthoritativeConfig.CaaRecords = nil
		} else if len(plan.AuthoritativeConfig.CaaRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.CaaRecords) == 0) {
			body.AuthoritativeConfig.CaaRecords = []sdwan_schema.CaaRecord{}
		} else if len(plan.AuthoritativeConfig.CaaRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.CaaRecords) != 0) {
			CaaRecordsToUse := plan.AuthoritativeConfig.CaaRecords
			if len(plan.AuthoritativeConfig.CaaRecords) == 0 {
				CaaRecordsToUse = state.AuthoritativeConfig.CaaRecords
			}
			body.AuthoritativeConfig.CaaRecords = make([]sdwan_schema.CaaRecord, 0, len(CaaRecordsToUse))
			for varLoopCaaRecordsIndex, varLoopCaaRecords := range CaaRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.CaaRecords = append(body.AuthoritativeConfig.CaaRecords, sdwan_schema.CaaRecord{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex] prefix=rsModel plan=varLoopCaaRecords properties=4
				// property: name=flags, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Flags = StringValueOrNil(varLoopCaaRecords.Flags)
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Name = StringValueOrNil(varLoopCaaRecords.Name)
				// property: name=tag, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Tag = StringValueOrNil(varLoopCaaRecords.Tag)
				// property: name=value, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Value = StringValueOrNil(varLoopCaaRecords.Value)
			}
		}
		// property: name=cname_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.CnameRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.CnameRecords == nil) {
			body.AuthoritativeConfig.CnameRecords = nil
		} else if len(plan.AuthoritativeConfig.CnameRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.CnameRecords) == 0) {
			body.AuthoritativeConfig.CnameRecords = []sdwan_schema.CnameRecords{}
		} else if len(plan.AuthoritativeConfig.CnameRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.CnameRecords) != 0) {
			CnameRecordsToUse := plan.AuthoritativeConfig.CnameRecords
			if len(plan.AuthoritativeConfig.CnameRecords) == 0 {
				CnameRecordsToUse = state.AuthoritativeConfig.CnameRecords
			}
			body.AuthoritativeConfig.CnameRecords = make([]sdwan_schema.CnameRecords, 0, len(CnameRecordsToUse))
			for varLoopCnameRecordsIndex, varLoopCnameRecords := range CnameRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.CnameRecords = append(body.AuthoritativeConfig.CnameRecords, sdwan_schema.CnameRecords{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex] prefix=rsModel plan=varLoopCnameRecords properties=3
				// property: name=name, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Name = ListStringValueOrNil(ctx, varLoopCnameRecords.Name)
				// property: name=target, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Target = StringValueOrNil(varLoopCnameRecords.Target)
				// property: name=ttl, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Ttl = Int64ValueOrNil(varLoopCnameRecords.Ttl)
			}
		}
		// property: name=dns_resource_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.DnsResourceRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.DnsResourceRecords == nil) {
			body.AuthoritativeConfig.DnsResourceRecords = nil
		} else if len(plan.AuthoritativeConfig.DnsResourceRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.DnsResourceRecords) == 0) {
			body.AuthoritativeConfig.DnsResourceRecords = []sdwan_schema.DnsResourceRecords{}
		} else if len(plan.AuthoritativeConfig.DnsResourceRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.DnsResourceRecords) != 0) {
			DnsResourceRecordsToUse := plan.AuthoritativeConfig.DnsResourceRecords
			if len(plan.AuthoritativeConfig.DnsResourceRecords) == 0 {
				DnsResourceRecordsToUse = state.AuthoritativeConfig.DnsResourceRecords
			}
			body.AuthoritativeConfig.DnsResourceRecords = make([]sdwan_schema.DnsResourceRecords, 0, len(DnsResourceRecordsToUse))
			for varLoopDnsResourceRecordsIndex, varLoopDnsResourceRecords := range DnsResourceRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.DnsResourceRecords = append(body.AuthoritativeConfig.DnsResourceRecords, sdwan_schema.DnsResourceRecords{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex] prefix=rsModel plan=varLoopDnsResourceRecords properties=3
				// property: name=hex_data, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].HexData = StringValueOrNil(varLoopDnsResourceRecords.HexData)
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].Name = StringValueOrNil(varLoopDnsResourceRecords.Name)
				// property: name=rr_number, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].RrNumber = Int64ValueOrNil(varLoopDnsResourceRecords.RrNumber)
			}
		}
		// property: name=host_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.HostRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.HostRecords == nil) {
			body.AuthoritativeConfig.HostRecords = nil
		} else if len(plan.AuthoritativeConfig.HostRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.HostRecords) == 0) {
			body.AuthoritativeConfig.HostRecords = []sdwan_schema.HostRecord{}
		} else if len(plan.AuthoritativeConfig.HostRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.HostRecords) != 0) {
			HostRecordsToUse := plan.AuthoritativeConfig.HostRecords
			if len(plan.AuthoritativeConfig.HostRecords) == 0 {
				HostRecordsToUse = state.AuthoritativeConfig.HostRecords
			}
			body.AuthoritativeConfig.HostRecords = make([]sdwan_schema.HostRecord, 0, len(HostRecordsToUse))
			for varLoopHostRecordsIndex, varLoopHostRecords := range HostRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.HostRecords = append(body.AuthoritativeConfig.HostRecords, sdwan_schema.HostRecord{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex] prefix=rsModel plan=varLoopHostRecords properties=4
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].DomainNames = ListStringValueOrNil(ctx, varLoopHostRecords.DomainNames)
				// property: name=ipv4_address, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv4Address = StringValueOrNil(varLoopHostRecords.Ipv4Address)
				// property: name=ipv6_address, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv6Address = StringValueOrNil(varLoopHostRecords.Ipv6Address)
				// property: name=ttl, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ttl = Int64ValueOrNil(varLoopHostRecords.Ttl)
			}
		}
		// property: name=mx_host_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.MxHostRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.MxHostRecords == nil) {
			body.AuthoritativeConfig.MxHostRecords = nil
		} else if len(plan.AuthoritativeConfig.MxHostRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.MxHostRecords) == 0) {
			body.AuthoritativeConfig.MxHostRecords = []sdwan_schema.MxHostRecord{}
		} else if len(plan.AuthoritativeConfig.MxHostRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.MxHostRecords) != 0) {
			MxHostRecordsToUse := plan.AuthoritativeConfig.MxHostRecords
			if len(plan.AuthoritativeConfig.MxHostRecords) == 0 {
				MxHostRecordsToUse = state.AuthoritativeConfig.MxHostRecords
			}
			body.AuthoritativeConfig.MxHostRecords = make([]sdwan_schema.MxHostRecord, 0, len(MxHostRecordsToUse))
			for varLoopMxHostRecordsIndex, varLoopMxHostRecords := range MxHostRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.MxHostRecords = append(body.AuthoritativeConfig.MxHostRecords, sdwan_schema.MxHostRecord{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex] prefix=rsModel plan=varLoopMxHostRecords properties=3
				// property: name=hostname, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Hostname = StringValueOrNil(varLoopMxHostRecords.Hostname)
				// property: name=mx_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].MxName = StringValueOrNil(varLoopMxHostRecords.MxName)
				// property: name=preference, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Preference = Int64ValueOrNil(varLoopMxHostRecords.Preference)
			}
		}
		// property: name=naptr_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.NaptrRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.NaptrRecords == nil) {
			body.AuthoritativeConfig.NaptrRecords = nil
		} else if len(plan.AuthoritativeConfig.NaptrRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.NaptrRecords) == 0) {
			body.AuthoritativeConfig.NaptrRecords = []sdwan_schema.NaptrRecords{}
		} else if len(plan.AuthoritativeConfig.NaptrRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.NaptrRecords) != 0) {
			NaptrRecordsToUse := plan.AuthoritativeConfig.NaptrRecords
			if len(plan.AuthoritativeConfig.NaptrRecords) == 0 {
				NaptrRecordsToUse = state.AuthoritativeConfig.NaptrRecords
			}
			body.AuthoritativeConfig.NaptrRecords = make([]sdwan_schema.NaptrRecords, 0, len(NaptrRecordsToUse))
			for varLoopNaptrRecordsIndex, varLoopNaptrRecords := range NaptrRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.NaptrRecords = append(body.AuthoritativeConfig.NaptrRecords, sdwan_schema.NaptrRecords{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex] prefix=rsModel plan=varLoopNaptrRecords properties=7
				// property: name=flags, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Flags = StringValueOrNil(varLoopNaptrRecords.Flags)
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Name = StringValueOrNil(varLoopNaptrRecords.Name)
				// property: name=order, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Order = Int64ValueOrNil(varLoopNaptrRecords.Order)
				// property: name=preference, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Preference = Int64ValueOrNil(varLoopNaptrRecords.Preference)
				// property: name=regexp, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Regexp = StringValueOrNil(varLoopNaptrRecords.Regexp)
				// property: name=replacement, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Replacement = StringValueOrNil(varLoopNaptrRecords.Replacement)
				// property: name=service, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Service = StringValueOrNil(varLoopNaptrRecords.Service)
			}
		}
		// property: name=peers, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.AuthoritativeConfig.Peers = ListStringValueOrNil(ctx, plan.AuthoritativeConfig.Peers)
		// property: name=ptr_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.PtrRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.PtrRecords == nil) {
			body.AuthoritativeConfig.PtrRecords = nil
		} else if len(plan.AuthoritativeConfig.PtrRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.PtrRecords) == 0) {
			body.AuthoritativeConfig.PtrRecords = []sdwan_schema.PtrRecords{}
		} else if len(plan.AuthoritativeConfig.PtrRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.PtrRecords) != 0) {
			PtrRecordsToUse := plan.AuthoritativeConfig.PtrRecords
			if len(plan.AuthoritativeConfig.PtrRecords) == 0 {
				PtrRecordsToUse = state.AuthoritativeConfig.PtrRecords
			}
			body.AuthoritativeConfig.PtrRecords = make([]sdwan_schema.PtrRecords, 0, len(PtrRecordsToUse))
			for varLoopPtrRecordsIndex, varLoopPtrRecords := range PtrRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.PtrRecords = append(body.AuthoritativeConfig.PtrRecords, sdwan_schema.PtrRecords{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex] prefix=rsModel plan=varLoopPtrRecords properties=2
				// property: name=name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Name = StringValueOrNil(varLoopPtrRecords.Name)
				// property: name=target, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Target = StringValueOrNil(varLoopPtrRecords.Target)
			}
		}
		// property: name=secondary_servers, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.AuthoritativeConfig.SecondaryServers = ListStringValueOrNil(ctx, plan.AuthoritativeConfig.SecondaryServers)
		// property: name=servers, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.Servers == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.Servers == nil) {
			body.AuthoritativeConfig.Servers = nil
		} else if len(plan.AuthoritativeConfig.Servers) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.Servers) == 0) {
			body.AuthoritativeConfig.Servers = []sdwan_schema.Server{}
		} else if len(plan.AuthoritativeConfig.Servers) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.Servers) != 0) {
			ServersToUse := plan.AuthoritativeConfig.Servers
			if len(plan.AuthoritativeConfig.Servers) == 0 {
				ServersToUse = state.AuthoritativeConfig.Servers
			}
			body.AuthoritativeConfig.Servers = make([]sdwan_schema.Server, 0, len(ServersToUse))
			for varLoopServersIndex, varLoopServers := range ServersToUse {
				// add a new item
				body.AuthoritativeConfig.Servers = append(body.AuthoritativeConfig.Servers, sdwan_schema.Server{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.Servers[varLoopServersIndex] prefix=rsModel plan=varLoopServers properties=2
				// property: name=dnsservicerole_id, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Servers[varLoopServersIndex].DnsserviceroleId = StringValueOrNil(varLoopServers.DnsserviceroleId)
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Servers[varLoopServersIndex].DomainName = StringValueOrNil(varLoopServers.DomainName)
			}
		}
		// property: name=soa, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.Soa == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.Soa == nil) {
			body.AuthoritativeConfig.Soa = nil
		} else if len(plan.AuthoritativeConfig.Soa) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.Soa) == 0) {
			body.AuthoritativeConfig.Soa = []sdwan_schema.SOA{}
		} else if len(plan.AuthoritativeConfig.Soa) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.Soa) != 0) {
			SoaToUse := plan.AuthoritativeConfig.Soa
			if len(plan.AuthoritativeConfig.Soa) == 0 {
				SoaToUse = state.AuthoritativeConfig.Soa
			}
			body.AuthoritativeConfig.Soa = make([]sdwan_schema.SOA, 0, len(SoaToUse))
			for varLoopSoaIndex, varLoopSoa := range SoaToUse {
				// add a new item
				body.AuthoritativeConfig.Soa = append(body.AuthoritativeConfig.Soa, sdwan_schema.SOA{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.Soa[varLoopSoaIndex] prefix=rsModel plan=varLoopSoa properties=5
				// property: name=expiry, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].Expiry = Int64ValueOrNil(varLoopSoa.Expiry)
				// property: name=host_master, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].HostMaster = StringValueOrNil(varLoopSoa.HostMaster)
				// property: name=refresh, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].Refresh = Int64ValueOrNil(varLoopSoa.Refresh)
				// property: name=retry, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].Retry = Int64ValueOrNil(varLoopSoa.Retry)
				// property: name=serial_number, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.Soa[varLoopSoaIndex].SerialNumber = Int64ValueOrNil(varLoopSoa.SerialNumber)
			}
		}
		// property: name=srv_hosts, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.SrvHosts == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.SrvHosts == nil) {
			body.AuthoritativeConfig.SrvHosts = nil
		} else if len(plan.AuthoritativeConfig.SrvHosts) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.SrvHosts) == 0) {
			body.AuthoritativeConfig.SrvHosts = []sdwan_schema.SrvHost{}
		} else if len(plan.AuthoritativeConfig.SrvHosts) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.SrvHosts) != 0) {
			SrvHostsToUse := plan.AuthoritativeConfig.SrvHosts
			if len(plan.AuthoritativeConfig.SrvHosts) == 0 {
				SrvHostsToUse = state.AuthoritativeConfig.SrvHosts
			}
			body.AuthoritativeConfig.SrvHosts = make([]sdwan_schema.SrvHost, 0, len(SrvHostsToUse))
			for varLoopSrvHostsIndex, varLoopSrvHosts := range SrvHostsToUse {
				// add a new item
				body.AuthoritativeConfig.SrvHosts = append(body.AuthoritativeConfig.SrvHosts, sdwan_schema.SrvHost{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex] prefix=rsModel plan=varLoopSrvHosts properties=7
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].DomainName = StringValueOrNil(varLoopSrvHosts.DomainName)
				// property: name=port, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Port = Int64ValueOrNil(varLoopSrvHosts.Port)
				// property: name=priority, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Priority = Int64ValueOrNil(varLoopSrvHosts.Priority)
				// property: name=protocol, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Protocol = StringValueOrNil(varLoopSrvHosts.Protocol)
				// property: name=service, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Service = StringValueOrNil(varLoopSrvHosts.Service)
				// property: name=target, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Target = Int64ValueOrNil(varLoopSrvHosts.Target)
				// property: name=weight, type=INTEGER macro=copy_from_plan
				body.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Weight = Int64ValueOrNil(varLoopSrvHosts.Weight)
			}
		}
		// property: name=synth_domains, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.SynthDomains == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.SynthDomains == nil) {
			body.AuthoritativeConfig.SynthDomains = nil
		} else if len(plan.AuthoritativeConfig.SynthDomains) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.SynthDomains) == 0) {
			body.AuthoritativeConfig.SynthDomains = []sdwan_schema.SynthDomain{}
		} else if len(plan.AuthoritativeConfig.SynthDomains) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.SynthDomains) != 0) {
			SynthDomainsToUse := plan.AuthoritativeConfig.SynthDomains
			if len(plan.AuthoritativeConfig.SynthDomains) == 0 {
				SynthDomainsToUse = state.AuthoritativeConfig.SynthDomains
			}
			body.AuthoritativeConfig.SynthDomains = make([]sdwan_schema.SynthDomain, 0, len(SynthDomainsToUse))
			for varLoopSynthDomainsIndex, varLoopSynthDomains := range SynthDomainsToUse {
				// add a new item
				body.AuthoritativeConfig.SynthDomains = append(body.AuthoritativeConfig.SynthDomains, sdwan_schema.SynthDomain{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex] prefix=rsModel plan=varLoopSynthDomains properties=5
				// property: name=domain, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Domain = StringValueOrNil(varLoopSynthDomains.Domain)
				// property: name=end_ipaddress, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].EndIpaddress = StringValueOrNil(varLoopSynthDomains.EndIpaddress)
				// property: name=ipaddress_prefix, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].IpaddressPrefix = StringValueOrNil(varLoopSynthDomains.IpaddressPrefix)
				// property: name=prefix, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Prefix = StringValueOrNil(varLoopSynthDomains.Prefix)
				// property: name=start_ipaddress, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].StartIpaddress = StringValueOrNil(varLoopSynthDomains.StartIpaddress)
			}
		}
		// property: name=ttl, type=INTEGER macro=copy_from_plan_or_state
		if state.AuthoritativeConfig != nil {
			body.AuthoritativeConfig.Ttl = ValueInt64PointerFromPlanOrState(plan.AuthoritativeConfig.Ttl, state.AuthoritativeConfig.Ttl)
		} else {
			body.AuthoritativeConfig.Ttl = Int64ValueOrNil(plan.AuthoritativeConfig.Ttl)
		}
		// property: name=txt_records, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.TxtRecords == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.TxtRecords == nil) {
			body.AuthoritativeConfig.TxtRecords = nil
		} else if len(plan.AuthoritativeConfig.TxtRecords) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.TxtRecords) == 0) {
			body.AuthoritativeConfig.TxtRecords = []sdwan_schema.TxtRecord{}
		} else if len(plan.AuthoritativeConfig.TxtRecords) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.TxtRecords) != 0) {
			TxtRecordsToUse := plan.AuthoritativeConfig.TxtRecords
			if len(plan.AuthoritativeConfig.TxtRecords) == 0 {
				TxtRecordsToUse = state.AuthoritativeConfig.TxtRecords
			}
			body.AuthoritativeConfig.TxtRecords = make([]sdwan_schema.TxtRecord, 0, len(TxtRecordsToUse))
			for varLoopTxtRecordsIndex, varLoopTxtRecords := range TxtRecordsToUse {
				// add a new item
				body.AuthoritativeConfig.TxtRecords = append(body.AuthoritativeConfig.TxtRecords, sdwan_schema.TxtRecord{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex] prefix=rsModel plan=varLoopTxtRecords properties=2
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].DomainName = StringValueOrNil(varLoopTxtRecords.DomainName)
				// property: name=texts, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].Texts = ListStringValueOrNil(ctx, varLoopTxtRecords.Texts)
			}
		}
		// property: name=zones, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.AuthoritativeConfig.Zones == nil && (state.AuthoritativeConfig == nil || state.AuthoritativeConfig.Zones == nil) {
			body.AuthoritativeConfig.Zones = nil
		} else if len(plan.AuthoritativeConfig.Zones) == 0 && (state.AuthoritativeConfig == nil || len(state.AuthoritativeConfig.Zones) == 0) {
			body.AuthoritativeConfig.Zones = []sdwan_schema.Zone{}
		} else if len(plan.AuthoritativeConfig.Zones) != 0 || (state.AuthoritativeConfig != nil && len(state.AuthoritativeConfig.Zones) != 0) {
			ZonesToUse := plan.AuthoritativeConfig.Zones
			if len(plan.AuthoritativeConfig.Zones) == 0 {
				ZonesToUse = state.AuthoritativeConfig.Zones
			}
			body.AuthoritativeConfig.Zones = make([]sdwan_schema.Zone, 0, len(ZonesToUse))
			for varLoopZonesIndex, varLoopZones := range ZonesToUse {
				// add a new item
				body.AuthoritativeConfig.Zones = append(body.AuthoritativeConfig.Zones, sdwan_schema.Zone{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.AuthoritativeConfig.Zones[varLoopZonesIndex] prefix=rsModel plan=varLoopZones properties=3
				// property: name=domain_name, type=STRING macro=copy_from_plan
				body.AuthoritativeConfig.Zones[varLoopZonesIndex].DomainName = StringValueOrNil(varLoopZones.DomainName)
				// property: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.Zones[varLoopZonesIndex].ExcludePrefix = ListStringValueOrNil(ctx, varLoopZones.ExcludePrefix)
				// property: name=include_prefix, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.AuthoritativeConfig.Zones[varLoopZonesIndex].IncludePrefix = ListStringValueOrNil(ctx, varLoopZones.IncludePrefix)
			}
		}
	}
	// property: name=cache_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.CacheConfig == nil {
		body.CacheConfig = nil
	} else {
		body.CacheConfig = &sdwan_schema.CacheConfig{}
		// copy_from_plan_or_state: body=body.CacheConfig prefix=rsModel state=state.CacheConfig plan=plan.CacheConfig properties=5
		// property: name=cache_size, type=INTEGER macro=copy_from_plan_or_state
		if state.CacheConfig != nil {
			body.CacheConfig.CacheSize = ValueInt64PointerFromPlanOrState(plan.CacheConfig.CacheSize, state.CacheConfig.CacheSize)
		} else {
			body.CacheConfig.CacheSize = Int64ValueOrNil(plan.CacheConfig.CacheSize)
		}
		// property: name=disable_negative_caching, type=BOOLEAN macro=copy_from_plan_or_state
		if state.CacheConfig != nil {
			body.CacheConfig.DisableNegativeCaching = ValueBoolPointerFromPlanOrState(plan.CacheConfig.DisableNegativeCaching, state.CacheConfig.DisableNegativeCaching)
		} else {
			body.CacheConfig.DisableNegativeCaching = BoolValueOrNil(plan.CacheConfig.DisableNegativeCaching)
		}
		// property: name=max_cache_ttl, type=INTEGER macro=copy_from_plan_or_state
		if state.CacheConfig != nil {
			body.CacheConfig.MaxCacheTtl = ValueInt64PointerFromPlanOrState(plan.CacheConfig.MaxCacheTtl, state.CacheConfig.MaxCacheTtl)
		} else {
			body.CacheConfig.MaxCacheTtl = Int64ValueOrNil(plan.CacheConfig.MaxCacheTtl)
		}
		// property: name=min_cache_ttl, type=INTEGER macro=copy_from_plan_or_state
		if state.CacheConfig != nil {
			body.CacheConfig.MinCacheTtl = ValueInt64PointerFromPlanOrState(plan.CacheConfig.MinCacheTtl, state.CacheConfig.MinCacheTtl)
		} else {
			body.CacheConfig.MinCacheTtl = Int64ValueOrNil(plan.CacheConfig.MinCacheTtl)
		}
		// property: name=negative_cache_ttl, type=INTEGER macro=copy_from_plan_or_state
		if state.CacheConfig != nil {
			body.CacheConfig.NegativeCacheTtl = ValueInt64PointerFromPlanOrState(plan.CacheConfig.NegativeCacheTtl, state.CacheConfig.NegativeCacheTtl)
		} else {
			body.CacheConfig.NegativeCacheTtl = Int64ValueOrNil(plan.CacheConfig.NegativeCacheTtl)
		}
	}
	// property: name=description, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Description = ValueStringPointerFromPlanOrState(plan.Description, state.Description)
	} else {
		body.Description = StringValueOrNil(plan.Description)
	}
	// property: name=dns_forward_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.DnsForwardConfig == nil {
		body.DnsForwardConfig = nil
	} else {
		body.DnsForwardConfig = &sdwan_schema.DnsForwardConfigV2{}
		// copy_from_plan_or_state: body=body.DnsForwardConfig prefix=rsModel state=state.DnsForwardConfig plan=plan.DnsForwardConfig properties=4
		// property: name=dns_servers, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.DnsForwardConfig.DnsServers == nil && (state.DnsForwardConfig == nil || state.DnsForwardConfig.DnsServers == nil) {
			body.DnsForwardConfig.DnsServers = nil
		} else if len(plan.DnsForwardConfig.DnsServers) == 0 && (state.DnsForwardConfig == nil || len(state.DnsForwardConfig.DnsServers) == 0) {
			body.DnsForwardConfig.DnsServers = []sdwan_schema.DnsServersV2{}
		} else if len(plan.DnsForwardConfig.DnsServers) != 0 || (state.DnsForwardConfig != nil && len(state.DnsForwardConfig.DnsServers) != 0) {
			DnsServersToUse := plan.DnsForwardConfig.DnsServers
			if len(plan.DnsForwardConfig.DnsServers) == 0 {
				DnsServersToUse = state.DnsForwardConfig.DnsServers
			}
			body.DnsForwardConfig.DnsServers = make([]sdwan_schema.DnsServersV2, 0, len(DnsServersToUse))
			for varLoopDnsServersIndex, varLoopDnsServers := range DnsServersToUse {
				// add a new item
				body.DnsForwardConfig.DnsServers = append(body.DnsForwardConfig.DnsServers, sdwan_schema.DnsServersV2{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex] prefix=rsModel plan=varLoopDnsServers properties=7
				// property: name=address_family, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].AddressFamily = StringValueOrNil(varLoopDnsServers.AddressFamily)
				// property: name=dnsserver_ip, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverIp = StringValueOrNil(varLoopDnsServers.DnsserverIp)
				// property: name=dnsserver_port, type=INTEGER macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverPort = Int64ValueOrNil(varLoopDnsServers.DnsserverPort)
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DomainNames = ListStringValueOrNil(ctx, varLoopDnsServers.DomainNames)
				// property: name=forward_dnsservicerole_id, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].ForwardDnsserviceroleId = StringValueOrNil(varLoopDnsServers.ForwardDnsserviceroleId)
				// property: name=ip_prefix, type=STRING macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].IpPrefix = StringValueOrNil(varLoopDnsServers.IpPrefix)
				// property: name=source_port, type=INTEGER macro=copy_from_plan
				body.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].SourcePort = Int64ValueOrNil(varLoopDnsServers.SourcePort)
			}
		}
		// property: name=max_source_port, type=INTEGER macro=copy_from_plan_or_state
		if state.DnsForwardConfig != nil {
			body.DnsForwardConfig.MaxSourcePort = ValueInt64PointerFromPlanOrState(plan.DnsForwardConfig.MaxSourcePort, state.DnsForwardConfig.MaxSourcePort)
		} else {
			body.DnsForwardConfig.MaxSourcePort = Int64ValueOrNil(plan.DnsForwardConfig.MaxSourcePort)
		}
		// property: name=min_source_port, type=INTEGER macro=copy_from_plan_or_state
		if state.DnsForwardConfig != nil {
			body.DnsForwardConfig.MinSourcePort = ValueInt64PointerFromPlanOrState(plan.DnsForwardConfig.MinSourcePort, state.DnsForwardConfig.MinSourcePort)
		} else {
			body.DnsForwardConfig.MinSourcePort = Int64ValueOrNil(plan.DnsForwardConfig.MinSourcePort)
		}
		// property: name=send_to_all_dns_servers, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnsForwardConfig != nil {
			body.DnsForwardConfig.SendToAllDnsServers = ValueBoolPointerFromPlanOrState(plan.DnsForwardConfig.SendToAllDnsServers, state.DnsForwardConfig.SendToAllDnsServers)
		} else {
			body.DnsForwardConfig.SendToAllDnsServers = BoolValueOrNil(plan.DnsForwardConfig.SendToAllDnsServers)
		}
	}
	// property: name=dns_queries_metadata, type=REFERENCE macro=copy_from_plan_or_state
	if plan.DnsQueriesMetadata == nil {
		body.DnsQueriesMetadata = nil
	} else {
		body.DnsQueriesMetadata = &sdwan_schema.DnsQueriesMetadata{}
		// copy_from_plan_or_state: body=body.DnsQueriesMetadata prefix=rsModel state=state.DnsQueriesMetadata plan=plan.DnsQueriesMetadata properties=3
		// property: name=add_client_mac, type=REFERENCE macro=copy_from_plan_or_state
		if plan.DnsQueriesMetadata.AddClientMac == nil {
			body.DnsQueriesMetadata.AddClientMac = nil
		} else {
			body.DnsQueriesMetadata.AddClientMac = &sdwan_schema.ClientMac{}
			// copy_from_plan_or_state: body=body.DnsQueriesMetadata.AddClientMac prefix=rsModel state=state.DnsQueriesMetadata.AddClientMac plan=plan.DnsQueriesMetadata.AddClientMac properties=1
			// property: name=mac_encoding_format, type=STRING macro=copy_from_plan_or_state
			if state.DnsQueriesMetadata.AddClientMac != nil {
				body.DnsQueriesMetadata.AddClientMac.MacEncodingFormat = ValueStringPointerFromPlanOrState(plan.DnsQueriesMetadata.AddClientMac.MacEncodingFormat, state.DnsQueriesMetadata.AddClientMac.MacEncodingFormat)
			} else {
				body.DnsQueriesMetadata.AddClientMac.MacEncodingFormat = StringValueOrNil(plan.DnsQueriesMetadata.AddClientMac.MacEncodingFormat)
			}
		}
		// property: name=add_customer_premises_equipment, type=REFERENCE macro=copy_from_plan_or_state
		if plan.DnsQueriesMetadata.AddCustomerPremisesEquipment == nil {
			body.DnsQueriesMetadata.AddCustomerPremisesEquipment = nil
		} else {
			body.DnsQueriesMetadata.AddCustomerPremisesEquipment = &sdwan_schema.CustomerPremisesEquipment{}
			// copy_from_plan_or_state: body=body.DnsQueriesMetadata.AddCustomerPremisesEquipment prefix=rsModel state=state.DnsQueriesMetadata.AddCustomerPremisesEquipment plan=plan.DnsQueriesMetadata.AddCustomerPremisesEquipment properties=2
			// property: name=identifier_text, type=STRING macro=copy_from_plan_or_state
			if state.DnsQueriesMetadata.AddCustomerPremisesEquipment != nil {
				body.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText = ValueStringPointerFromPlanOrState(plan.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText, state.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText)
			} else {
				body.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText = StringValueOrNil(plan.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText)
			}
			// property: name=type, type=STRING macro=copy_from_plan_or_state
			if state.DnsQueriesMetadata.AddCustomerPremisesEquipment != nil {
				body.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type = ValueStringPointerFromPlanOrState(plan.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type, state.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type)
			} else {
				body.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type = StringValueOrNil(plan.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type)
			}
		}
		// property: name=add_subnets, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.DnsQueriesMetadata.AddSubnets == nil && (state.DnsQueriesMetadata == nil || state.DnsQueriesMetadata.AddSubnets == nil) {
			body.DnsQueriesMetadata.AddSubnets = nil
		} else if len(plan.DnsQueriesMetadata.AddSubnets) == 0 && (state.DnsQueriesMetadata == nil || len(state.DnsQueriesMetadata.AddSubnets) == 0) {
			body.DnsQueriesMetadata.AddSubnets = []sdwan_schema.Subnet{}
		} else if len(plan.DnsQueriesMetadata.AddSubnets) != 0 || (state.DnsQueriesMetadata != nil && len(state.DnsQueriesMetadata.AddSubnets) != 0) {
			AddSubnetsToUse := plan.DnsQueriesMetadata.AddSubnets
			if len(plan.DnsQueriesMetadata.AddSubnets) == 0 {
				AddSubnetsToUse = state.DnsQueriesMetadata.AddSubnets
			}
			body.DnsQueriesMetadata.AddSubnets = make([]sdwan_schema.Subnet, 0, len(AddSubnetsToUse))
			for varLoopAddSubnetsIndex, varLoopAddSubnets := range AddSubnetsToUse {
				// add a new item
				body.DnsQueriesMetadata.AddSubnets = append(body.DnsQueriesMetadata.AddSubnets, sdwan_schema.Subnet{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex] prefix=rsModel plan=varLoopAddSubnets properties=4
				// property: name=ipv4_address, type=STRING macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4Address = StringValueOrNil(varLoopAddSubnets.Ipv4Address)
				// property: name=ipv4_prefix_length, type=INTEGER macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4PrefixLength = Int64ValueOrNil(varLoopAddSubnets.Ipv4PrefixLength)
				// property: name=ipv6_address, type=STRING macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6Address = StringValueOrNil(varLoopAddSubnets.Ipv6Address)
				// property: name=ipv6_prefix_length, type=INTEGER macro=copy_from_plan
				body.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6PrefixLength = Int64ValueOrNil(varLoopAddSubnets.Ipv6PrefixLength)
			}
		}
	}
	// property: name=dns_rebind_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.DnsRebindConfig == nil {
		body.DnsRebindConfig = nil
	} else {
		body.DnsRebindConfig = &sdwan_schema.DnsRebindConfig{}
		// copy_from_plan_or_state: body=body.DnsRebindConfig prefix=rsModel state=state.DnsRebindConfig plan=plan.DnsRebindConfig properties=3
		// property: name=enable_localhost_rebind, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnsRebindConfig != nil {
			body.DnsRebindConfig.EnableLocalhostRebind = ValueBoolPointerFromPlanOrState(plan.DnsRebindConfig.EnableLocalhostRebind, state.DnsRebindConfig.EnableLocalhostRebind)
		} else {
			body.DnsRebindConfig.EnableLocalhostRebind = BoolValueOrNil(plan.DnsRebindConfig.EnableLocalhostRebind)
		}
		// property: name=rebind_domains, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.DnsRebindConfig.RebindDomains = ListStringValueOrNil(ctx, plan.DnsRebindConfig.RebindDomains)
		// property: name=stop_dns_rebind_privateip, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnsRebindConfig != nil {
			body.DnsRebindConfig.StopDnsRebindPrivateip = ValueBoolPointerFromPlanOrState(plan.DnsRebindConfig.StopDnsRebindPrivateip, state.DnsRebindConfig.StopDnsRebindPrivateip)
		} else {
			body.DnsRebindConfig.StopDnsRebindPrivateip = BoolValueOrNil(plan.DnsRebindConfig.StopDnsRebindPrivateip)
		}
	}
	// property: name=dns_response_overrides, type=REFERENCE macro=copy_from_plan_or_state
	if plan.DnsResponseOverrides == nil {
		body.DnsResponseOverrides = nil
	} else {
		body.DnsResponseOverrides = &sdwan_schema.DnsResponseOverrides{}
		// copy_from_plan_or_state: body=body.DnsResponseOverrides prefix=rsModel state=state.DnsResponseOverrides plan=plan.DnsResponseOverrides properties=6
		// property: name=aliases, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.DnsResponseOverrides.Aliases == nil && (state.DnsResponseOverrides == nil || state.DnsResponseOverrides.Aliases == nil) {
			body.DnsResponseOverrides.Aliases = nil
		} else if len(plan.DnsResponseOverrides.Aliases) == 0 && (state.DnsResponseOverrides == nil || len(state.DnsResponseOverrides.Aliases) == 0) {
			body.DnsResponseOverrides.Aliases = []sdwan_schema.Alias{}
		} else if len(plan.DnsResponseOverrides.Aliases) != 0 || (state.DnsResponseOverrides != nil && len(state.DnsResponseOverrides.Aliases) != 0) {
			AliasesToUse := plan.DnsResponseOverrides.Aliases
			if len(plan.DnsResponseOverrides.Aliases) == 0 {
				AliasesToUse = state.DnsResponseOverrides.Aliases
			}
			body.DnsResponseOverrides.Aliases = make([]sdwan_schema.Alias, 0, len(AliasesToUse))
			for varLoopAliasesIndex, varLoopAliases := range AliasesToUse {
				// add a new item
				body.DnsResponseOverrides.Aliases = append(body.DnsResponseOverrides.Aliases, sdwan_schema.Alias{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.DnsResponseOverrides.Aliases[varLoopAliasesIndex] prefix=rsModel plan=varLoopAliases properties=5
				// property: name=mask, type=INTEGER macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].Mask = Int64ValueOrNil(varLoopAliases.Mask)
				// property: name=original_end_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalEndIp = StringValueOrNil(varLoopAliases.OriginalEndIp)
				// property: name=original_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalIp = StringValueOrNil(varLoopAliases.OriginalIp)
				// property: name=original_start_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalStartIp = StringValueOrNil(varLoopAliases.OriginalStartIp)
				// property: name=replace_ip, type=STRING macro=copy_from_plan
				body.DnsResponseOverrides.Aliases[varLoopAliasesIndex].ReplaceIp = StringValueOrNil(varLoopAliases.ReplaceIp)
			}
		}
		// property: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.DnsResponseOverrides.BogusNxDomains = ListStringValueOrNil(ctx, plan.DnsResponseOverrides.BogusNxDomains)
		// property: name=disable_private_ip_lookups, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnsResponseOverrides != nil {
			body.DnsResponseOverrides.DisablePrivateIpLookups = ValueBoolPointerFromPlanOrState(plan.DnsResponseOverrides.DisablePrivateIpLookups, state.DnsResponseOverrides.DisablePrivateIpLookups)
		} else {
			body.DnsResponseOverrides.DisablePrivateIpLookups = BoolValueOrNil(plan.DnsResponseOverrides.DisablePrivateIpLookups)
		}
		// property: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=copy_from_plan_or_state
		body.DnsResponseOverrides.IgnoreIpAddresses = ListStringValueOrNil(ctx, plan.DnsResponseOverrides.IgnoreIpAddresses)
		// property: name=local_ttl, type=INTEGER macro=copy_from_plan_or_state
		if state.DnsResponseOverrides != nil {
			body.DnsResponseOverrides.LocalTtl = ValueInt64PointerFromPlanOrState(plan.DnsResponseOverrides.LocalTtl, state.DnsResponseOverrides.LocalTtl)
		} else {
			body.DnsResponseOverrides.LocalTtl = Int64ValueOrNil(plan.DnsResponseOverrides.LocalTtl)
		}
		// property: name=max_ttl, type=INTEGER macro=copy_from_plan_or_state
		if state.DnsResponseOverrides != nil {
			body.DnsResponseOverrides.MaxTtl = ValueInt64PointerFromPlanOrState(plan.DnsResponseOverrides.MaxTtl, state.DnsResponseOverrides.MaxTtl)
		} else {
			body.DnsResponseOverrides.MaxTtl = Int64ValueOrNil(plan.DnsResponseOverrides.MaxTtl)
		}
	}
	// property: name=dnssec_config, type=REFERENCE macro=copy_from_plan_or_state
	if plan.DnssecConfig == nil {
		body.DnssecConfig = nil
	} else {
		body.DnssecConfig = &sdwan_schema.DnsSecConfig{}
		// copy_from_plan_or_state: body=body.DnssecConfig prefix=rsModel state=state.DnssecConfig plan=plan.DnssecConfig properties=4
		// property: name=disable_dnssec_timecheck, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnssecConfig != nil {
			body.DnssecConfig.DisableDnssecTimecheck = ValueBoolPointerFromPlanOrState(plan.DnssecConfig.DisableDnssecTimecheck, state.DnssecConfig.DisableDnssecTimecheck)
		} else {
			body.DnssecConfig.DisableDnssecTimecheck = BoolValueOrNil(plan.DnssecConfig.DisableDnssecTimecheck)
		}
		// property: name=dns_check_unsigned, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnssecConfig != nil {
			body.DnssecConfig.DnsCheckUnsigned = ValueBoolPointerFromPlanOrState(plan.DnssecConfig.DnsCheckUnsigned, state.DnssecConfig.DnsCheckUnsigned)
		} else {
			body.DnssecConfig.DnsCheckUnsigned = BoolValueOrNil(plan.DnssecConfig.DnsCheckUnsigned)
		}
		// property: name=enabled, type=BOOLEAN macro=copy_from_plan_or_state
		if state.DnssecConfig != nil {
			body.DnssecConfig.Enabled = ValueBoolPointerFromPlanOrState(plan.DnssecConfig.Enabled, state.DnssecConfig.Enabled)
		} else {
			body.DnssecConfig.Enabled = BoolValueOrNil(plan.DnssecConfig.Enabled)
		}
		// property: name=trust_anchors, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
		if plan.DnssecConfig.TrustAnchors == nil && (state.DnssecConfig == nil || state.DnssecConfig.TrustAnchors == nil) {
			body.DnssecConfig.TrustAnchors = nil
		} else if len(plan.DnssecConfig.TrustAnchors) == 0 && (state.DnssecConfig == nil || len(state.DnssecConfig.TrustAnchors) == 0) {
			body.DnssecConfig.TrustAnchors = []sdwan_schema.TrustAnchor{}
		} else if len(plan.DnssecConfig.TrustAnchors) != 0 || (state.DnssecConfig != nil && len(state.DnssecConfig.TrustAnchors) != 0) {
			TrustAnchorsToUse := plan.DnssecConfig.TrustAnchors
			if len(plan.DnssecConfig.TrustAnchors) == 0 {
				TrustAnchorsToUse = state.DnssecConfig.TrustAnchors
			}
			body.DnssecConfig.TrustAnchors = make([]sdwan_schema.TrustAnchor, 0, len(TrustAnchorsToUse))
			for varLoopTrustAnchorsIndex, varLoopTrustAnchors := range TrustAnchorsToUse {
				// add a new item
				body.DnssecConfig.TrustAnchors = append(body.DnssecConfig.TrustAnchors, sdwan_schema.TrustAnchor{})
				// since we have chosen to stick with either the plan or state, we need to simply copy child properties
				// copy_from_plan: body=body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex] prefix=rsModel plan=varLoopTrustAnchors properties=3
				// property: name=class, type=STRING macro=copy_from_plan
				body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Class = StringValueOrNil(varLoopTrustAnchors.Class)
				// property: name=domain, type=STRING macro=copy_from_plan
				body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Domain = StringValueOrNil(varLoopTrustAnchors.Domain)
				// property: name=key_digest, type=REFERENCE macro=copy_from_plan
				if varLoopTrustAnchors.KeyDigest != nil {
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = &sdwan_schema.KeyDigest{}
					// copy_from_plan: body=body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest prefix=rsModel plan=varLoopTrustAnchors.KeyDigest properties=4
					// property: name=algorithm, type=INTEGER macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Algorithm = Int64ValueOrNil(varLoopTrustAnchors.KeyDigest.Algorithm)
					// property: name=digest, type=STRING macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Digest = StringValueOrNil(varLoopTrustAnchors.KeyDigest.Digest)
					// property: name=digest_type, type=INTEGER macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.DigestType = Int64ValueOrNil(varLoopTrustAnchors.KeyDigest.DigestType)
					// property: name=key_tag, type=INTEGER macro=copy_from_plan
					body.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.KeyTag = Int64ValueOrNil(varLoopTrustAnchors.KeyDigest.KeyTag)
				}
			}
		}
	}
	// property: name=domains_to_addresses, type=ARRAY_REFERENCE macro=copy_from_plan_or_state
	if plan.DomainsToAddresses == nil && (state == nil || state.DomainsToAddresses == nil) {
		body.DomainsToAddresses = nil
	} else if len(plan.DomainsToAddresses) == 0 && (state == nil || len(state.DomainsToAddresses) == 0) {
		body.DomainsToAddresses = []sdwan_schema.DomainsToAddress{}
	} else if len(plan.DomainsToAddresses) != 0 || (state != nil && len(state.DomainsToAddresses) != 0) {
		DomainsToAddressesToUse := plan.DomainsToAddresses
		if len(plan.DomainsToAddresses) == 0 {
			DomainsToAddressesToUse = state.DomainsToAddresses
		}
		body.DomainsToAddresses = make([]sdwan_schema.DomainsToAddress, 0, len(DomainsToAddressesToUse))
		for varLoopDomainsToAddressesIndex, varLoopDomainsToAddresses := range DomainsToAddressesToUse {
			// add a new item
			body.DomainsToAddresses = append(body.DomainsToAddresses, sdwan_schema.DomainsToAddress{})
			// since we have chosen to stick with either the plan or state, we need to simply copy child properties
			// copy_from_plan: body=body.DomainsToAddresses[varLoopDomainsToAddressesIndex] prefix=rsModel plan=varLoopDomainsToAddresses properties=3
			// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_from_plan
			body.DomainsToAddresses[varLoopDomainsToAddressesIndex].DomainNames = ListStringValueOrNil(ctx, varLoopDomainsToAddresses.DomainNames)
			// property: name=ipv4_address, type=STRING macro=copy_from_plan
			body.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv4Address = StringValueOrNil(varLoopDomainsToAddresses.Ipv4Address)
			// property: name=ipv6_address, type=STRING macro=copy_from_plan
			body.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv6Address = StringValueOrNil(varLoopDomainsToAddresses.Ipv6Address)
		}
	}
	// property: name=edns_packet_max, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.EdnsPacketMax = ValueInt64PointerFromPlanOrState(plan.EdnsPacketMax, state.EdnsPacketMax)
	} else {
		body.EdnsPacketMax = Int64ValueOrNil(plan.EdnsPacketMax)
	}
	// property: name=enable_dns_loop_detection, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.EnableDnsLoopDetection = ValueBoolPointerFromPlanOrState(plan.EnableDnsLoopDetection, state.EnableDnsLoopDetection)
	} else {
		body.EnableDnsLoopDetection = BoolValueOrNil(plan.EnableDnsLoopDetection)
	}
	// property: name=enable_dnssec_proxy, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.EnableDnssecProxy = ValueBoolPointerFromPlanOrState(plan.EnableDnssecProxy, state.EnableDnssecProxy)
	} else {
		body.EnableDnssecProxy = BoolValueOrNil(plan.EnableDnssecProxy)
	}
	// property: name=enable_strict_domain_name, type=BOOLEAN macro=copy_from_plan_or_state
	if state != nil {
		body.EnableStrictDomainName = ValueBoolPointerFromPlanOrState(plan.EnableStrictDomainName, state.EnableStrictDomainName)
	} else {
		body.EnableStrictDomainName = BoolValueOrNil(plan.EnableStrictDomainName)
	}
	// property: name=id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Id = ValueStringPointerFromPlanOrState(plan.Id, state.Id)
	} else {
		body.Id = StringValueOrNil(plan.Id)
	}
	// property: name=listen_dnsservicerole_id, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.ListenDnsserviceroleId = ValueStringPointerFromPlanOrState(plan.ListenDnsserviceroleId, state.ListenDnsserviceroleId)
	} else {
		body.ListenDnsserviceroleId = StringValueOrNil(plan.ListenDnsserviceroleId)
	}
	// property: name=listen_port, type=INTEGER macro=copy_from_plan_or_state
	if state != nil {
		body.ListenPort = ValueInt64PointerFromPlanOrState(plan.ListenPort, state.ListenPort)
	} else {
		body.ListenPort = Int64ValueOrNil(plan.ListenPort)
	}
	// property: name=name, type=STRING macro=copy_from_plan_or_state
	if state != nil {
		body.Name = ValueStringPointerFromPlanOrState(plan.Name, state.Name)
	} else {
		body.Name = StringValueOrNil(plan.Name)
	}
	// property: name=tags, type=SET_PRIMITIVE macro=copy_from_plan_or_state
	body.Tags = SetStringValueOrNil(ctx, plan.Tags)

	// convert body to map
	json_body, err := json.Marshal(body)
	if err != nil {
		resp.Diagnostics.AddError("error marshaling struct DnsServiceProfileV2N1 to JSON:", err.Error())
		return false
	}

	// process http json path
	request_body_string := string(json_body)
	// copy pointer
	put_request.RequestBody = &request_body_string

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, put_request)
	if put_request.ResponseErr != nil {
		if IsObjectNotFound(*put_request.ResponseErr) {
			State.RemoveResource(ctx)
		} else if r.GetHttpStatusCode(put_request) == 404 {
			State.RemoveResource(ctx)
		} else {
			tflog.Info(ctx, "update request failed for prismasdwan_dns_service_profile", map[string]any{
				"terraform_provider_function": "Update",
				"resource_name":               "prismasdwan_dns_service_profile",
				"path":                        put_request.FinalPath,
			})
			tflog.Debug(ctx, "update request failed for prismasdwan_dns_service_profile", map[string]any{
				"terraform_provider_function": "Update",
				"resource_name":               "prismasdwan_dns_service_profile",
				"path":                        put_request.FinalPath,
				"request":                     put_request.ToString(),
			})
			resp.Diagnostics.AddError("error updating prismasdwan_dns_service_profile", (*put_request.ResponseErr).Error())
		}
		return false
	}

	// process http json path
	response_body_string := string(*put_request.ResponseBytes)
	// inject overrides
	response_body_string, _ = sjson.Delete(response_body_string, "_created_on_utc")
	response_body_string, _ = sjson.Set(response_body_string, "_schema", 0)

	// start copying attributes
	var ans sdwan_schema.DnsServiceProfileV2N1
	// copy from json response
	json_err := json.Unmarshal([]byte(response_body_string), &ans)
	// if found, exit
	if json_err != nil {
		resp.Diagnostics.AddError("error in json unmarshal to DnsServiceProfileV2N1 in update", json_err.Error())
		return false
	}

	// Store the answer to state. schema=DnsServiceProfileV2N1
	// copy_to_state: state=state prefix=rsModel ans=ans properties=20
	// property: name=_etag, type=INTEGER macro=copy_to_state
	state.Etag = types.Int64PointerValue(ans.Etag)
	// property: name=_schema, type=INTEGER macro=copy_to_state
	state.Schema = types.Int64PointerValue(ans.Schema)
	// property: name=authoritative_config, type=REFERENCE macro=copy_to_state
	if ans.AuthoritativeConfig == nil {
		state.AuthoritativeConfig = nil
	} else {
		state.AuthoritativeConfig = &rsModelAuthoritativeConfig{}
		// copy_to_state: state=state.AuthoritativeConfig prefix=rsModel ans=ans.AuthoritativeConfig properties=16
		// property: name=caa_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.CaaRecords == nil {
			state.AuthoritativeConfig.CaaRecords = nil
		} else if len(ans.AuthoritativeConfig.CaaRecords) == 0 {
			state.AuthoritativeConfig.CaaRecords = []rsModelCaaRecord{}
		} else {
			state.AuthoritativeConfig.CaaRecords = make([]rsModelCaaRecord, 0, len(ans.AuthoritativeConfig.CaaRecords))
			for varLoopCaaRecordsIndex, varLoopCaaRecords := range ans.AuthoritativeConfig.CaaRecords {
				// add a new item
				state.AuthoritativeConfig.CaaRecords = append(state.AuthoritativeConfig.CaaRecords, rsModelCaaRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex] prefix=rsModel ans=varLoopCaaRecords properties=4
				// property: name=flags, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Flags = types.StringPointerValue(varLoopCaaRecords.Flags)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Name = types.StringPointerValue(varLoopCaaRecords.Name)
				// property: name=tag, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Tag = types.StringPointerValue(varLoopCaaRecords.Tag)
				// property: name=value, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CaaRecords[varLoopCaaRecordsIndex].Value = types.StringPointerValue(varLoopCaaRecords.Value)
			}
		}
		// property: name=cname_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.CnameRecords == nil {
			state.AuthoritativeConfig.CnameRecords = nil
		} else if len(ans.AuthoritativeConfig.CnameRecords) == 0 {
			state.AuthoritativeConfig.CnameRecords = []rsModelCnameRecords{}
		} else {
			state.AuthoritativeConfig.CnameRecords = make([]rsModelCnameRecords, 0, len(ans.AuthoritativeConfig.CnameRecords))
			for varLoopCnameRecordsIndex, varLoopCnameRecords := range ans.AuthoritativeConfig.CnameRecords {
				// add a new item
				state.AuthoritativeConfig.CnameRecords = append(state.AuthoritativeConfig.CnameRecords, rsModelCnameRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex] prefix=rsModel ans=varLoopCnameRecords properties=3
				// property: name=name, type=ARRAY_PRIMITIVE macro=copy_to_state
				varName, errName := types.ListValueFrom(ctx, types.StringType, varLoopCnameRecords.Name)
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Name = varName
				resp.Diagnostics.Append(errName.Errors()...)
				// property: name=target, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Target = types.StringPointerValue(varLoopCnameRecords.Target)
				// property: name=ttl, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.CnameRecords[varLoopCnameRecordsIndex].Ttl = types.Int64PointerValue(varLoopCnameRecords.Ttl)
			}
		}
		// property: name=dns_resource_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.DnsResourceRecords == nil {
			state.AuthoritativeConfig.DnsResourceRecords = nil
		} else if len(ans.AuthoritativeConfig.DnsResourceRecords) == 0 {
			state.AuthoritativeConfig.DnsResourceRecords = []rsModelDnsResourceRecords{}
		} else {
			state.AuthoritativeConfig.DnsResourceRecords = make([]rsModelDnsResourceRecords, 0, len(ans.AuthoritativeConfig.DnsResourceRecords))
			for varLoopDnsResourceRecordsIndex, varLoopDnsResourceRecords := range ans.AuthoritativeConfig.DnsResourceRecords {
				// add a new item
				state.AuthoritativeConfig.DnsResourceRecords = append(state.AuthoritativeConfig.DnsResourceRecords, rsModelDnsResourceRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex] prefix=rsModel ans=varLoopDnsResourceRecords properties=3
				// property: name=hex_data, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].HexData = types.StringPointerValue(varLoopDnsResourceRecords.HexData)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].Name = types.StringPointerValue(varLoopDnsResourceRecords.Name)
				// property: name=rr_number, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.DnsResourceRecords[varLoopDnsResourceRecordsIndex].RrNumber = types.Int64PointerValue(varLoopDnsResourceRecords.RrNumber)
			}
		}
		// property: name=host_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.HostRecords == nil {
			state.AuthoritativeConfig.HostRecords = nil
		} else if len(ans.AuthoritativeConfig.HostRecords) == 0 {
			state.AuthoritativeConfig.HostRecords = []rsModelHostRecord{}
		} else {
			state.AuthoritativeConfig.HostRecords = make([]rsModelHostRecord, 0, len(ans.AuthoritativeConfig.HostRecords))
			for varLoopHostRecordsIndex, varLoopHostRecords := range ans.AuthoritativeConfig.HostRecords {
				// add a new item
				state.AuthoritativeConfig.HostRecords = append(state.AuthoritativeConfig.HostRecords, rsModelHostRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex] prefix=rsModel ans=varLoopHostRecords properties=4
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
				varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopHostRecords.DomainNames)
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].DomainNames = varDomainNames
				resp.Diagnostics.Append(errDomainNames.Errors()...)
				// property: name=ipv4_address, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv4Address = types.StringPointerValue(varLoopHostRecords.Ipv4Address)
				// property: name=ipv6_address, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ipv6Address = types.StringPointerValue(varLoopHostRecords.Ipv6Address)
				// property: name=ttl, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.HostRecords[varLoopHostRecordsIndex].Ttl = types.Int64PointerValue(varLoopHostRecords.Ttl)
			}
		}
		// property: name=mx_host_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.MxHostRecords == nil {
			state.AuthoritativeConfig.MxHostRecords = nil
		} else if len(ans.AuthoritativeConfig.MxHostRecords) == 0 {
			state.AuthoritativeConfig.MxHostRecords = []rsModelMxHostRecord{}
		} else {
			state.AuthoritativeConfig.MxHostRecords = make([]rsModelMxHostRecord, 0, len(ans.AuthoritativeConfig.MxHostRecords))
			for varLoopMxHostRecordsIndex, varLoopMxHostRecords := range ans.AuthoritativeConfig.MxHostRecords {
				// add a new item
				state.AuthoritativeConfig.MxHostRecords = append(state.AuthoritativeConfig.MxHostRecords, rsModelMxHostRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex] prefix=rsModel ans=varLoopMxHostRecords properties=3
				// property: name=hostname, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Hostname = types.StringPointerValue(varLoopMxHostRecords.Hostname)
				// property: name=mx_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].MxName = types.StringPointerValue(varLoopMxHostRecords.MxName)
				// property: name=preference, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.MxHostRecords[varLoopMxHostRecordsIndex].Preference = types.Int64PointerValue(varLoopMxHostRecords.Preference)
			}
		}
		// property: name=naptr_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.NaptrRecords == nil {
			state.AuthoritativeConfig.NaptrRecords = nil
		} else if len(ans.AuthoritativeConfig.NaptrRecords) == 0 {
			state.AuthoritativeConfig.NaptrRecords = []rsModelNaptrRecords{}
		} else {
			state.AuthoritativeConfig.NaptrRecords = make([]rsModelNaptrRecords, 0, len(ans.AuthoritativeConfig.NaptrRecords))
			for varLoopNaptrRecordsIndex, varLoopNaptrRecords := range ans.AuthoritativeConfig.NaptrRecords {
				// add a new item
				state.AuthoritativeConfig.NaptrRecords = append(state.AuthoritativeConfig.NaptrRecords, rsModelNaptrRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex] prefix=rsModel ans=varLoopNaptrRecords properties=7
				// property: name=flags, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Flags = types.StringPointerValue(varLoopNaptrRecords.Flags)
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Name = types.StringPointerValue(varLoopNaptrRecords.Name)
				// property: name=order, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Order = types.Int64PointerValue(varLoopNaptrRecords.Order)
				// property: name=preference, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Preference = types.Int64PointerValue(varLoopNaptrRecords.Preference)
				// property: name=regexp, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Regexp = types.StringPointerValue(varLoopNaptrRecords.Regexp)
				// property: name=replacement, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Replacement = types.StringPointerValue(varLoopNaptrRecords.Replacement)
				// property: name=service, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.NaptrRecords[varLoopNaptrRecordsIndex].Service = types.StringPointerValue(varLoopNaptrRecords.Service)
			}
		}
		// property: name=peers, type=ARRAY_PRIMITIVE macro=copy_to_state
		varPeers, errPeers := types.ListValueFrom(ctx, types.StringType, ans.AuthoritativeConfig.Peers)
		state.AuthoritativeConfig.Peers = varPeers
		resp.Diagnostics.Append(errPeers.Errors()...)
		// property: name=ptr_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.PtrRecords == nil {
			state.AuthoritativeConfig.PtrRecords = nil
		} else if len(ans.AuthoritativeConfig.PtrRecords) == 0 {
			state.AuthoritativeConfig.PtrRecords = []rsModelPtrRecords{}
		} else {
			state.AuthoritativeConfig.PtrRecords = make([]rsModelPtrRecords, 0, len(ans.AuthoritativeConfig.PtrRecords))
			for varLoopPtrRecordsIndex, varLoopPtrRecords := range ans.AuthoritativeConfig.PtrRecords {
				// add a new item
				state.AuthoritativeConfig.PtrRecords = append(state.AuthoritativeConfig.PtrRecords, rsModelPtrRecords{})
				// copy_to_state: state=state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex] prefix=rsModel ans=varLoopPtrRecords properties=2
				// property: name=name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Name = types.StringPointerValue(varLoopPtrRecords.Name)
				// property: name=target, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.PtrRecords[varLoopPtrRecordsIndex].Target = types.StringPointerValue(varLoopPtrRecords.Target)
			}
		}
		// property: name=secondary_servers, type=ARRAY_PRIMITIVE macro=copy_to_state
		varSecondaryServers, errSecondaryServers := types.ListValueFrom(ctx, types.StringType, ans.AuthoritativeConfig.SecondaryServers)
		state.AuthoritativeConfig.SecondaryServers = varSecondaryServers
		resp.Diagnostics.Append(errSecondaryServers.Errors()...)
		// property: name=servers, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Servers == nil {
			state.AuthoritativeConfig.Servers = nil
		} else if len(ans.AuthoritativeConfig.Servers) == 0 {
			state.AuthoritativeConfig.Servers = []rsModelServer{}
		} else {
			state.AuthoritativeConfig.Servers = make([]rsModelServer, 0, len(ans.AuthoritativeConfig.Servers))
			for varLoopServersIndex, varLoopServers := range ans.AuthoritativeConfig.Servers {
				// add a new item
				state.AuthoritativeConfig.Servers = append(state.AuthoritativeConfig.Servers, rsModelServer{})
				// copy_to_state: state=state.AuthoritativeConfig.Servers[varLoopServersIndex] prefix=rsModel ans=varLoopServers properties=2
				// property: name=dnsservicerole_id, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Servers[varLoopServersIndex].DnsserviceroleId = types.StringPointerValue(varLoopServers.DnsserviceroleId)
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Servers[varLoopServersIndex].DomainName = types.StringPointerValue(varLoopServers.DomainName)
			}
		}
		// property: name=soa, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Soa == nil {
			state.AuthoritativeConfig.Soa = nil
		} else if len(ans.AuthoritativeConfig.Soa) == 0 {
			state.AuthoritativeConfig.Soa = []rsModelSOA{}
		} else {
			state.AuthoritativeConfig.Soa = make([]rsModelSOA, 0, len(ans.AuthoritativeConfig.Soa))
			for varLoopSoaIndex, varLoopSoa := range ans.AuthoritativeConfig.Soa {
				// add a new item
				state.AuthoritativeConfig.Soa = append(state.AuthoritativeConfig.Soa, rsModelSOA{})
				// copy_to_state: state=state.AuthoritativeConfig.Soa[varLoopSoaIndex] prefix=rsModel ans=varLoopSoa properties=5
				// property: name=expiry, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Expiry = types.Int64PointerValue(varLoopSoa.Expiry)
				// property: name=host_master, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].HostMaster = types.StringPointerValue(varLoopSoa.HostMaster)
				// property: name=refresh, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Refresh = types.Int64PointerValue(varLoopSoa.Refresh)
				// property: name=retry, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].Retry = types.Int64PointerValue(varLoopSoa.Retry)
				// property: name=serial_number, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.Soa[varLoopSoaIndex].SerialNumber = types.Int64PointerValue(varLoopSoa.SerialNumber)
			}
		}
		// property: name=srv_hosts, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.SrvHosts == nil {
			state.AuthoritativeConfig.SrvHosts = nil
		} else if len(ans.AuthoritativeConfig.SrvHosts) == 0 {
			state.AuthoritativeConfig.SrvHosts = []rsModelSrvHost{}
		} else {
			state.AuthoritativeConfig.SrvHosts = make([]rsModelSrvHost, 0, len(ans.AuthoritativeConfig.SrvHosts))
			for varLoopSrvHostsIndex, varLoopSrvHosts := range ans.AuthoritativeConfig.SrvHosts {
				// add a new item
				state.AuthoritativeConfig.SrvHosts = append(state.AuthoritativeConfig.SrvHosts, rsModelSrvHost{})
				// copy_to_state: state=state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex] prefix=rsModel ans=varLoopSrvHosts properties=7
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].DomainName = types.StringPointerValue(varLoopSrvHosts.DomainName)
				// property: name=port, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Port = types.Int64PointerValue(varLoopSrvHosts.Port)
				// property: name=priority, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Priority = types.Int64PointerValue(varLoopSrvHosts.Priority)
				// property: name=protocol, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Protocol = types.StringPointerValue(varLoopSrvHosts.Protocol)
				// property: name=service, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Service = types.StringPointerValue(varLoopSrvHosts.Service)
				// property: name=target, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Target = types.Int64PointerValue(varLoopSrvHosts.Target)
				// property: name=weight, type=INTEGER macro=copy_to_state
				state.AuthoritativeConfig.SrvHosts[varLoopSrvHostsIndex].Weight = types.Int64PointerValue(varLoopSrvHosts.Weight)
			}
		}
		// property: name=synth_domains, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.SynthDomains == nil {
			state.AuthoritativeConfig.SynthDomains = nil
		} else if len(ans.AuthoritativeConfig.SynthDomains) == 0 {
			state.AuthoritativeConfig.SynthDomains = []rsModelSynthDomain{}
		} else {
			state.AuthoritativeConfig.SynthDomains = make([]rsModelSynthDomain, 0, len(ans.AuthoritativeConfig.SynthDomains))
			for varLoopSynthDomainsIndex, varLoopSynthDomains := range ans.AuthoritativeConfig.SynthDomains {
				// add a new item
				state.AuthoritativeConfig.SynthDomains = append(state.AuthoritativeConfig.SynthDomains, rsModelSynthDomain{})
				// copy_to_state: state=state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex] prefix=rsModel ans=varLoopSynthDomains properties=5
				// property: name=domain, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Domain = types.StringPointerValue(varLoopSynthDomains.Domain)
				// property: name=end_ipaddress, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].EndIpaddress = types.StringPointerValue(varLoopSynthDomains.EndIpaddress)
				// property: name=ipaddress_prefix, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].IpaddressPrefix = types.StringPointerValue(varLoopSynthDomains.IpaddressPrefix)
				// property: name=prefix, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].Prefix = types.StringPointerValue(varLoopSynthDomains.Prefix)
				// property: name=start_ipaddress, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.SynthDomains[varLoopSynthDomainsIndex].StartIpaddress = types.StringPointerValue(varLoopSynthDomains.StartIpaddress)
			}
		}
		// property: name=ttl, type=INTEGER macro=copy_to_state
		state.AuthoritativeConfig.Ttl = types.Int64PointerValue(ans.AuthoritativeConfig.Ttl)
		// property: name=txt_records, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.TxtRecords == nil {
			state.AuthoritativeConfig.TxtRecords = nil
		} else if len(ans.AuthoritativeConfig.TxtRecords) == 0 {
			state.AuthoritativeConfig.TxtRecords = []rsModelTxtRecord{}
		} else {
			state.AuthoritativeConfig.TxtRecords = make([]rsModelTxtRecord, 0, len(ans.AuthoritativeConfig.TxtRecords))
			for varLoopTxtRecordsIndex, varLoopTxtRecords := range ans.AuthoritativeConfig.TxtRecords {
				// add a new item
				state.AuthoritativeConfig.TxtRecords = append(state.AuthoritativeConfig.TxtRecords, rsModelTxtRecord{})
				// copy_to_state: state=state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex] prefix=rsModel ans=varLoopTxtRecords properties=2
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].DomainName = types.StringPointerValue(varLoopTxtRecords.DomainName)
				// property: name=texts, type=ARRAY_PRIMITIVE macro=copy_to_state
				varTexts, errTexts := types.ListValueFrom(ctx, types.StringType, varLoopTxtRecords.Texts)
				state.AuthoritativeConfig.TxtRecords[varLoopTxtRecordsIndex].Texts = varTexts
				resp.Diagnostics.Append(errTexts.Errors()...)
			}
		}
		// property: name=zones, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.AuthoritativeConfig.Zones == nil {
			state.AuthoritativeConfig.Zones = nil
		} else if len(ans.AuthoritativeConfig.Zones) == 0 {
			state.AuthoritativeConfig.Zones = []rsModelZone{}
		} else {
			state.AuthoritativeConfig.Zones = make([]rsModelZone, 0, len(ans.AuthoritativeConfig.Zones))
			for varLoopZonesIndex, varLoopZones := range ans.AuthoritativeConfig.Zones {
				// add a new item
				state.AuthoritativeConfig.Zones = append(state.AuthoritativeConfig.Zones, rsModelZone{})
				// copy_to_state: state=state.AuthoritativeConfig.Zones[varLoopZonesIndex] prefix=rsModel ans=varLoopZones properties=3
				// property: name=domain_name, type=STRING macro=copy_to_state
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].DomainName = types.StringPointerValue(varLoopZones.DomainName)
				// property: name=exclude_prefix, type=ARRAY_PRIMITIVE macro=copy_to_state
				varExcludePrefix, errExcludePrefix := types.ListValueFrom(ctx, types.StringType, varLoopZones.ExcludePrefix)
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].ExcludePrefix = varExcludePrefix
				resp.Diagnostics.Append(errExcludePrefix.Errors()...)
				// property: name=include_prefix, type=ARRAY_PRIMITIVE macro=copy_to_state
				varIncludePrefix, errIncludePrefix := types.ListValueFrom(ctx, types.StringType, varLoopZones.IncludePrefix)
				state.AuthoritativeConfig.Zones[varLoopZonesIndex].IncludePrefix = varIncludePrefix
				resp.Diagnostics.Append(errIncludePrefix.Errors()...)
			}
		}
	}
	// property: name=cache_config, type=REFERENCE macro=copy_to_state
	if ans.CacheConfig == nil {
		state.CacheConfig = nil
	} else {
		state.CacheConfig = &rsModelCacheConfig{}
		// copy_to_state: state=state.CacheConfig prefix=rsModel ans=ans.CacheConfig properties=5
		// property: name=cache_size, type=INTEGER macro=copy_to_state
		state.CacheConfig.CacheSize = types.Int64PointerValue(ans.CacheConfig.CacheSize)
		// property: name=disable_negative_caching, type=BOOLEAN macro=copy_to_state
		state.CacheConfig.DisableNegativeCaching = types.BoolPointerValue(ans.CacheConfig.DisableNegativeCaching)
		// property: name=max_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.MaxCacheTtl = types.Int64PointerValue(ans.CacheConfig.MaxCacheTtl)
		// property: name=min_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.MinCacheTtl = types.Int64PointerValue(ans.CacheConfig.MinCacheTtl)
		// property: name=negative_cache_ttl, type=INTEGER macro=copy_to_state
		state.CacheConfig.NegativeCacheTtl = types.Int64PointerValue(ans.CacheConfig.NegativeCacheTtl)
	}
	// property: name=description, type=STRING macro=copy_to_state
	state.Description = types.StringPointerValue(ans.Description)
	// property: name=dns_forward_config, type=REFERENCE macro=copy_to_state
	if ans.DnsForwardConfig == nil {
		state.DnsForwardConfig = nil
	} else {
		state.DnsForwardConfig = &rsModelDnsForwardConfigV2{}
		// copy_to_state: state=state.DnsForwardConfig prefix=rsModel ans=ans.DnsForwardConfig properties=4
		// property: name=dns_servers, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsForwardConfig.DnsServers == nil {
			state.DnsForwardConfig.DnsServers = nil
		} else if len(ans.DnsForwardConfig.DnsServers) == 0 {
			state.DnsForwardConfig.DnsServers = []rsModelDnsServersV2{}
		} else {
			state.DnsForwardConfig.DnsServers = make([]rsModelDnsServersV2, 0, len(ans.DnsForwardConfig.DnsServers))
			for varLoopDnsServersIndex, varLoopDnsServers := range ans.DnsForwardConfig.DnsServers {
				// add a new item
				state.DnsForwardConfig.DnsServers = append(state.DnsForwardConfig.DnsServers, rsModelDnsServersV2{})
				// copy_to_state: state=state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex] prefix=rsModel ans=varLoopDnsServers properties=7
				// property: name=address_family, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].AddressFamily = types.StringPointerValue(varLoopDnsServers.AddressFamily)
				// property: name=dnsserver_ip, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverIp = types.StringPointerValue(varLoopDnsServers.DnsserverIp)
				// property: name=dnsserver_port, type=INTEGER macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DnsserverPort = types.Int64PointerValue(varLoopDnsServers.DnsserverPort)
				// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
				varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopDnsServers.DomainNames)
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].DomainNames = varDomainNames
				resp.Diagnostics.Append(errDomainNames.Errors()...)
				// property: name=forward_dnsservicerole_id, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].ForwardDnsserviceroleId = types.StringPointerValue(varLoopDnsServers.ForwardDnsserviceroleId)
				// property: name=ip_prefix, type=STRING macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].IpPrefix = types.StringPointerValue(varLoopDnsServers.IpPrefix)
				// property: name=source_port, type=INTEGER macro=copy_to_state
				state.DnsForwardConfig.DnsServers[varLoopDnsServersIndex].SourcePort = types.Int64PointerValue(varLoopDnsServers.SourcePort)
			}
		}
		// property: name=max_source_port, type=INTEGER macro=copy_to_state
		state.DnsForwardConfig.MaxSourcePort = types.Int64PointerValue(ans.DnsForwardConfig.MaxSourcePort)
		// property: name=min_source_port, type=INTEGER macro=copy_to_state
		state.DnsForwardConfig.MinSourcePort = types.Int64PointerValue(ans.DnsForwardConfig.MinSourcePort)
		// property: name=send_to_all_dns_servers, type=BOOLEAN macro=copy_to_state
		state.DnsForwardConfig.SendToAllDnsServers = types.BoolPointerValue(ans.DnsForwardConfig.SendToAllDnsServers)
	}
	// property: name=dns_queries_metadata, type=REFERENCE macro=copy_to_state
	if ans.DnsQueriesMetadata == nil {
		state.DnsQueriesMetadata = nil
	} else {
		state.DnsQueriesMetadata = &rsModelDnsQueriesMetadata{}
		// copy_to_state: state=state.DnsQueriesMetadata prefix=rsModel ans=ans.DnsQueriesMetadata properties=3
		// property: name=add_client_mac, type=REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddClientMac == nil {
			state.DnsQueriesMetadata.AddClientMac = nil
		} else {
			state.DnsQueriesMetadata.AddClientMac = &rsModelClientMac{}
			// copy_to_state: state=state.DnsQueriesMetadata.AddClientMac prefix=rsModel ans=ans.DnsQueriesMetadata.AddClientMac properties=1
			// property: name=mac_encoding_format, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddClientMac.MacEncodingFormat = types.StringPointerValue(ans.DnsQueriesMetadata.AddClientMac.MacEncodingFormat)
		}
		// property: name=add_customer_premises_equipment, type=REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddCustomerPremisesEquipment == nil {
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment = nil
		} else {
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment = &rsModelCustomerPremisesEquipment{}
			// copy_to_state: state=state.DnsQueriesMetadata.AddCustomerPremisesEquipment prefix=rsModel ans=ans.DnsQueriesMetadata.AddCustomerPremisesEquipment properties=2
			// property: name=identifier_text, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText = types.StringPointerValue(ans.DnsQueriesMetadata.AddCustomerPremisesEquipment.IdentifierText)
			// property: name=type, type=STRING macro=copy_to_state
			state.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type = types.StringPointerValue(ans.DnsQueriesMetadata.AddCustomerPremisesEquipment.Type)
		}
		// property: name=add_subnets, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsQueriesMetadata.AddSubnets == nil {
			state.DnsQueriesMetadata.AddSubnets = nil
		} else if len(ans.DnsQueriesMetadata.AddSubnets) == 0 {
			state.DnsQueriesMetadata.AddSubnets = []rsModelSubnet{}
		} else {
			state.DnsQueriesMetadata.AddSubnets = make([]rsModelSubnet, 0, len(ans.DnsQueriesMetadata.AddSubnets))
			for varLoopAddSubnetsIndex, varLoopAddSubnets := range ans.DnsQueriesMetadata.AddSubnets {
				// add a new item
				state.DnsQueriesMetadata.AddSubnets = append(state.DnsQueriesMetadata.AddSubnets, rsModelSubnet{})
				// copy_to_state: state=state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex] prefix=rsModel ans=varLoopAddSubnets properties=4
				// property: name=ipv4_address, type=STRING macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4Address = types.StringPointerValue(varLoopAddSubnets.Ipv4Address)
				// property: name=ipv4_prefix_length, type=INTEGER macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv4PrefixLength = types.Int64PointerValue(varLoopAddSubnets.Ipv4PrefixLength)
				// property: name=ipv6_address, type=STRING macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6Address = types.StringPointerValue(varLoopAddSubnets.Ipv6Address)
				// property: name=ipv6_prefix_length, type=INTEGER macro=copy_to_state
				state.DnsQueriesMetadata.AddSubnets[varLoopAddSubnetsIndex].Ipv6PrefixLength = types.Int64PointerValue(varLoopAddSubnets.Ipv6PrefixLength)
			}
		}
	}
	// property: name=dns_rebind_config, type=REFERENCE macro=copy_to_state
	if ans.DnsRebindConfig == nil {
		state.DnsRebindConfig = nil
	} else {
		state.DnsRebindConfig = &rsModelDnsRebindConfig{}
		// copy_to_state: state=state.DnsRebindConfig prefix=rsModel ans=ans.DnsRebindConfig properties=3
		// property: name=enable_localhost_rebind, type=BOOLEAN macro=copy_to_state
		state.DnsRebindConfig.EnableLocalhostRebind = types.BoolPointerValue(ans.DnsRebindConfig.EnableLocalhostRebind)
		// property: name=rebind_domains, type=ARRAY_PRIMITIVE macro=copy_to_state
		varRebindDomains, errRebindDomains := types.ListValueFrom(ctx, types.StringType, ans.DnsRebindConfig.RebindDomains)
		state.DnsRebindConfig.RebindDomains = varRebindDomains
		resp.Diagnostics.Append(errRebindDomains.Errors()...)
		// property: name=stop_dns_rebind_privateip, type=BOOLEAN macro=copy_to_state
		state.DnsRebindConfig.StopDnsRebindPrivateip = types.BoolPointerValue(ans.DnsRebindConfig.StopDnsRebindPrivateip)
	}
	// property: name=dns_response_overrides, type=REFERENCE macro=copy_to_state
	if ans.DnsResponseOverrides == nil {
		state.DnsResponseOverrides = nil
	} else {
		state.DnsResponseOverrides = &rsModelDnsResponseOverrides{}
		// copy_to_state: state=state.DnsResponseOverrides prefix=rsModel ans=ans.DnsResponseOverrides properties=6
		// property: name=aliases, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnsResponseOverrides.Aliases == nil {
			state.DnsResponseOverrides.Aliases = nil
		} else if len(ans.DnsResponseOverrides.Aliases) == 0 {
			state.DnsResponseOverrides.Aliases = []rsModelAlias{}
		} else {
			state.DnsResponseOverrides.Aliases = make([]rsModelAlias, 0, len(ans.DnsResponseOverrides.Aliases))
			for varLoopAliasesIndex, varLoopAliases := range ans.DnsResponseOverrides.Aliases {
				// add a new item
				state.DnsResponseOverrides.Aliases = append(state.DnsResponseOverrides.Aliases, rsModelAlias{})
				// copy_to_state: state=state.DnsResponseOverrides.Aliases[varLoopAliasesIndex] prefix=rsModel ans=varLoopAliases properties=5
				// property: name=mask, type=INTEGER macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].Mask = types.Int64PointerValue(varLoopAliases.Mask)
				// property: name=original_end_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalEndIp = types.StringPointerValue(varLoopAliases.OriginalEndIp)
				// property: name=original_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalIp = types.StringPointerValue(varLoopAliases.OriginalIp)
				// property: name=original_start_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].OriginalStartIp = types.StringPointerValue(varLoopAliases.OriginalStartIp)
				// property: name=replace_ip, type=STRING macro=copy_to_state
				state.DnsResponseOverrides.Aliases[varLoopAliasesIndex].ReplaceIp = types.StringPointerValue(varLoopAliases.ReplaceIp)
			}
		}
		// property: name=bogus_nx_domains, type=ARRAY_PRIMITIVE macro=copy_to_state
		varBogusNxDomains, errBogusNxDomains := types.ListValueFrom(ctx, types.StringType, ans.DnsResponseOverrides.BogusNxDomains)
		state.DnsResponseOverrides.BogusNxDomains = varBogusNxDomains
		resp.Diagnostics.Append(errBogusNxDomains.Errors()...)
		// property: name=disable_private_ip_lookups, type=BOOLEAN macro=copy_to_state
		state.DnsResponseOverrides.DisablePrivateIpLookups = types.BoolPointerValue(ans.DnsResponseOverrides.DisablePrivateIpLookups)
		// property: name=ignore_ip_addresses, type=ARRAY_PRIMITIVE macro=copy_to_state
		varIgnoreIpAddresses, errIgnoreIpAddresses := types.ListValueFrom(ctx, types.StringType, ans.DnsResponseOverrides.IgnoreIpAddresses)
		state.DnsResponseOverrides.IgnoreIpAddresses = varIgnoreIpAddresses
		resp.Diagnostics.Append(errIgnoreIpAddresses.Errors()...)
		// property: name=local_ttl, type=INTEGER macro=copy_to_state
		state.DnsResponseOverrides.LocalTtl = types.Int64PointerValue(ans.DnsResponseOverrides.LocalTtl)
		// property: name=max_ttl, type=INTEGER macro=copy_to_state
		state.DnsResponseOverrides.MaxTtl = types.Int64PointerValue(ans.DnsResponseOverrides.MaxTtl)
	}
	// property: name=dnssec_config, type=REFERENCE macro=copy_to_state
	if ans.DnssecConfig == nil {
		state.DnssecConfig = nil
	} else {
		state.DnssecConfig = &rsModelDnsSecConfig{}
		// copy_to_state: state=state.DnssecConfig prefix=rsModel ans=ans.DnssecConfig properties=4
		// property: name=disable_dnssec_timecheck, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.DisableDnssecTimecheck = types.BoolPointerValue(ans.DnssecConfig.DisableDnssecTimecheck)
		// property: name=dns_check_unsigned, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.DnsCheckUnsigned = types.BoolPointerValue(ans.DnssecConfig.DnsCheckUnsigned)
		// property: name=enabled, type=BOOLEAN macro=copy_to_state
		state.DnssecConfig.Enabled = types.BoolPointerValue(ans.DnssecConfig.Enabled)
		// property: name=trust_anchors, type=ARRAY_REFERENCE macro=copy_to_state
		if ans.DnssecConfig.TrustAnchors == nil {
			state.DnssecConfig.TrustAnchors = nil
		} else if len(ans.DnssecConfig.TrustAnchors) == 0 {
			state.DnssecConfig.TrustAnchors = []rsModelTrustAnchor{}
		} else {
			state.DnssecConfig.TrustAnchors = make([]rsModelTrustAnchor, 0, len(ans.DnssecConfig.TrustAnchors))
			for varLoopTrustAnchorsIndex, varLoopTrustAnchors := range ans.DnssecConfig.TrustAnchors {
				// add a new item
				state.DnssecConfig.TrustAnchors = append(state.DnssecConfig.TrustAnchors, rsModelTrustAnchor{})
				// copy_to_state: state=state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex] prefix=rsModel ans=varLoopTrustAnchors properties=3
				// property: name=class, type=STRING macro=copy_to_state
				state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Class = types.StringPointerValue(varLoopTrustAnchors.Class)
				// property: name=domain, type=STRING macro=copy_to_state
				state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].Domain = types.StringPointerValue(varLoopTrustAnchors.Domain)
				// property: name=key_digest, type=REFERENCE macro=copy_to_state
				if varLoopTrustAnchors.KeyDigest == nil {
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = nil
				} else {
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest = &rsModelKeyDigest{}
					// copy_to_state: state=state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest prefix=rsModel ans=varLoopTrustAnchors.KeyDigest properties=4
					// property: name=algorithm, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Algorithm = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.Algorithm)
					// property: name=digest, type=STRING macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.Digest = types.StringPointerValue(varLoopTrustAnchors.KeyDigest.Digest)
					// property: name=digest_type, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.DigestType = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.DigestType)
					// property: name=key_tag, type=INTEGER macro=copy_to_state
					state.DnssecConfig.TrustAnchors[varLoopTrustAnchorsIndex].KeyDigest.KeyTag = types.Int64PointerValue(varLoopTrustAnchors.KeyDigest.KeyTag)
				}
			}
		}
	}
	// property: name=domains_to_addresses, type=ARRAY_REFERENCE macro=copy_to_state
	if ans.DomainsToAddresses == nil {
		state.DomainsToAddresses = nil
	} else if len(ans.DomainsToAddresses) == 0 {
		state.DomainsToAddresses = []rsModelDomainsToAddress{}
	} else {
		state.DomainsToAddresses = make([]rsModelDomainsToAddress, 0, len(ans.DomainsToAddresses))
		for varLoopDomainsToAddressesIndex, varLoopDomainsToAddresses := range ans.DomainsToAddresses {
			// add a new item
			state.DomainsToAddresses = append(state.DomainsToAddresses, rsModelDomainsToAddress{})
			// copy_to_state: state=state.DomainsToAddresses[varLoopDomainsToAddressesIndex] prefix=rsModel ans=varLoopDomainsToAddresses properties=3
			// property: name=domain_names, type=ARRAY_PRIMITIVE macro=copy_to_state
			varDomainNames, errDomainNames := types.ListValueFrom(ctx, types.StringType, varLoopDomainsToAddresses.DomainNames)
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].DomainNames = varDomainNames
			resp.Diagnostics.Append(errDomainNames.Errors()...)
			// property: name=ipv4_address, type=STRING macro=copy_to_state
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv4Address = types.StringPointerValue(varLoopDomainsToAddresses.Ipv4Address)
			// property: name=ipv6_address, type=STRING macro=copy_to_state
			state.DomainsToAddresses[varLoopDomainsToAddressesIndex].Ipv6Address = types.StringPointerValue(varLoopDomainsToAddresses.Ipv6Address)
		}
	}
	// property: name=edns_packet_max, type=INTEGER macro=copy_to_state
	state.EdnsPacketMax = types.Int64PointerValue(ans.EdnsPacketMax)
	// property: name=enable_dns_loop_detection, type=BOOLEAN macro=copy_to_state
	state.EnableDnsLoopDetection = types.BoolPointerValue(ans.EnableDnsLoopDetection)
	// property: name=enable_dnssec_proxy, type=BOOLEAN macro=copy_to_state
	state.EnableDnssecProxy = types.BoolPointerValue(ans.EnableDnssecProxy)
	// property: name=enable_strict_domain_name, type=BOOLEAN macro=copy_to_state
	state.EnableStrictDomainName = types.BoolPointerValue(ans.EnableStrictDomainName)
	// property: name=id, type=STRING macro=copy_to_state
	state.Id = types.StringPointerValue(ans.Id)
	// property: name=listen_dnsservicerole_id, type=STRING macro=copy_to_state
	state.ListenDnsserviceroleId = types.StringPointerValue(ans.ListenDnsserviceroleId)
	// property: name=listen_port, type=INTEGER macro=copy_to_state
	state.ListenPort = types.Int64PointerValue(ans.ListenPort)
	// property: name=name, type=STRING macro=copy_to_state
	state.Name = types.StringPointerValue(ans.Name)
	// property: name=tags, type=SET_PRIMITIVE macro=copy_to_state
	varTags, errTags := types.SetValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = varTags
	resp.Diagnostics.Append(errTags.Errors()...)
	return true
}

func (r *dnsServiceProfileResource) doDelete(ctx context.Context, state *rsModelDnsServiceProfileV2N1, resp *resource.DeleteResponse) bool {
	// read object id
	tfid := state.Tfid.ValueString()
	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "prismasdwan_dns_service_profile",
		"locMap":                      map[string]int{"prefix_id": 0},
	})

	// tokens must match
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 1 {
		resp.Diagnostics.AddError("error in prismasdwan_dns_service_profile ID format", "Expected 1 tokens")
		return false
	}

	// Prepare input for the API endpoint.
	delete_request := &sdwan_client.SdwanClientRequestResponse{}
	delete_request.Method = "DELETE"
	delete_request.Path = "/sdwan/v2.1/api/dnsserviceprofiles/{dnsservice_role_id}"

	// copy parameters from plan always
	params := MapStringValueOrNil(ctx, state.TfParameters)
	delete_request.PathParameters = &params
	// add last parameter as ObjectID
	(*delete_request.PathParameters)["dnsservice_role_id"] = &tokens[0]
	// add other parameters by splitting on `=`
	for _, token := range tokens[1:] {
		param := strings.Split(token, "=")
		(*delete_request.PathParameters)[param[0]] = &param[1]
	}

	// Client that will perform the request.
	svc := sdwan_client.NewClient(r.client)

	// Perform the operation.
	svc.ExecuteSdwanRequest(ctx, delete_request)
	if delete_request.ResponseErr != nil {
		if !IsObjectNotFound(*delete_request.ResponseErr) {
			resp.Diagnostics.AddError("error deleting prismasdwan_dns_service_profile", (*delete_request.ResponseErr).Error())
			return false
		}
	}
	return true
}

// Performs the Create(POST) Operation on the Resource
// TfID is pulled from plan to use in the creation request
// Path Parameters are encoded into TfID itself
func (r *dnsServiceProfileResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "executing resource create for prismasdwan_dns_service_profile")
	var plan rsModelDnsServiceProfileV2N1
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make post call
	var state rsModelDnsServiceProfileV2N1
	if r.doPost(ctx, &plan, &state, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Read(GET) Operation on the Resource
// TfID is pulled from state to use in the read request
// Path Parameters are extracted TfID itself
func (r *dnsServiceProfileResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {

	tflog.Info(ctx, "executing resource read for prismasdwan_dns_service_profile")
	var savestate, state rsModelDnsServiceProfileV2N1
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a get call
	if r.doGet(ctx, &state, &savestate, &resp.State, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Update(PUT) Operation on the Resource
// TfID is pulled from state to use in the read request
// Path Parameters are extracted TfID itself
// TfID must match in state and plan, else error is thrown
func (r *dnsServiceProfileResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {

	tflog.Info(ctx, "executing resource update for prismasdwan_dns_service_profile")
	var plan, state rsModelDnsServiceProfileV2N1
	// copy state from TF
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}
	// copy plan from TF
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a put call
	if r.doPut(ctx, &plan, &state, &resp.State, resp) {
		resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
	}
}

// Performs the Delete Operation on the Resource
// TfID is pulled from state to use in the deletion request
// Path Parameters are extracted from the TfID itself
func (r *dnsServiceProfileResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {

	tflog.Info(ctx, "executing resource delete for prismasdwan_dns_service_profile")
	var state rsModelDnsServiceProfileV2N1
	// copy state from TF
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// make a delete call
	if r.doDelete(ctx, &state, resp) {
		resp.State.RemoveResource(ctx)
	}
}

func (r *dnsServiceProfileResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

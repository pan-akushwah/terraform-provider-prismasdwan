package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"strings"

	"github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk"
	mqfebzt "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/custom/dhcpoptions"
	dEowMJz "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dhcpserver/screen/v2/n3"
	xygFTDt "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/iprange"
	xqHSEzl "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/static/mapping/v2"
	hHIIBxy "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/services/sdwan/v23/api/sites/siteid/dhcpservers"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Data source (listing).
var (
	_ datasource.DataSource              = &dhcpServerListDataSource{}
	_ datasource.DataSourceWithConfigure = &dhcpServerListDataSource{}
)

func NewDhcpServerListDataSource() datasource.DataSource {
	return &dhcpServerListDataSource{}
}

type dhcpServerListDataSource struct {
	client *sdwan.Client
}

// dhcpServerListDsModel is the model.
type dhcpServerListDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	SiteId types.String `tfsdk:"site_id"`

	// Output.
	Items      []dhcpServerListDsModel_dEowMJz_Config `tfsdk:"items"`
	TotalItems types.Int64                            `tfsdk:"total_items"`
}

type dhcpServerListDsModel_dEowMJz_Config struct {
	AddressFamily    types.String                           `tfsdk:"address_family"`
	BroadcastAddress types.String                           `tfsdk:"broadcast_address"`
	CustomOptions    []dhcpServerListDsModel_mqfebzt_Config `tfsdk:"custom_options"`
	DefaultLeaseTime types.Int64                            `tfsdk:"default_lease_time"`
	Description      types.String                           `tfsdk:"description"`
	Disabled         types.Bool                             `tfsdk:"disabled"`
	DnsServers       types.List                             `tfsdk:"dns_servers"`
	DomainName       types.String                           `tfsdk:"domain_name"`
	Etag             types.Int64                            `tfsdk:"etag"`
	Gateway          types.String                           `tfsdk:"gateway"`
	Id               types.String                           `tfsdk:"id"`
	IpRanges         []dhcpServerListDsModel_xygFTDt_Config `tfsdk:"ip_ranges"`
	MaxLeaseTime     types.Int64                            `tfsdk:"max_lease_time"`
	NetworkContextId types.String                           `tfsdk:"network_context_id"`
	StaticMappings   []dhcpServerListDsModel_xqHSEzl_Config `tfsdk:"static_mappings"`
	Subnet           types.String                           `tfsdk:"subnet"`
	Tags             types.List                             `tfsdk:"tags"`
	VrfContextId     types.String                           `tfsdk:"vrf_context_id"`
}

type dhcpServerListDsModel_mqfebzt_Config struct {
	OptionDefinition      types.String `tfsdk:"option_definition"`
	OptionValue           types.String `tfsdk:"option_value"`
	VendorClassIdentifier types.String `tfsdk:"vendor_class_identifier"`
}

type dhcpServerListDsModel_xygFTDt_Config struct {
	EndIp   types.String `tfsdk:"end_ip"`
	StartIp types.String `tfsdk:"start_ip"`
}

type dhcpServerListDsModel_xqHSEzl_Config struct {
	ClientDuid types.String `tfsdk:"client_duid"`
	IpAddress  types.String `tfsdk:"ip_address"`
	Mac        types.String `tfsdk:"mac"`
	Name       types.String `tfsdk:"name"`
}

// Metadata returns the data source type name.
func (d *dhcpServerListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dhcp_server_list"
}

// Schema defines the schema for this listing data source.
func (d *dhcpServerListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a listing of config items.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"site_id":true} outputs:map[string]bool{"items":true, "tfid":true, "total_items":true} forceNew:map[string]bool{"site_id":true}
			"items": dsschema.ListNestedAttribute{
				Description: "The Items param.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"address_family":true, "broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "etag":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true, "vrf_context_id":true} forceNew:map[string]bool(nil)
						"address_family": dsschema.StringAttribute{
							Description: "Address Family: ValidateEnum(enumClass = classOf[IPAddressFamily], DHCP_CONFIG_ADDRESS_FAMILY_INVALID, nullAllowed = false) .",
							Computed:    true,
						},
						"broadcast_address": dsschema.StringAttribute{
							Description: "Broadcast Address.",
							Computed:    true,
						},
						"custom_options": dsschema.ListNestedAttribute{
							Description: "Custom Options: Valid .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"option_definition":true, "option_value":true, "vendor_class_identifier":true} forceNew:map[string]bool(nil)
									"option_definition": dsschema.StringAttribute{
										Description: "Option Definition: NotEmpty(groups = [classOf[Definition]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_DEF_UNSUPPORTED: Custom option definition is not supported) Size(groups = [classOf[Definition]], max = 1024, error = DHCPSERVER_CONFIG_OPTION_DEF_EXCEEDS_LIMIT: Custom option definition length exceeeds maximum limit, min = 0) .",
										Computed:    true,
									},
									"option_value": dsschema.StringAttribute{
										Description: "Option Value: NotEmpty(groups = [classOf[Value]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_VAL_UNSUPPORTED: Custom option value is not supported) Size(groups = [classOf[Value]], max = 8192, error = DHCPSERVER_CONFIG_OPTION_VAL_EXCEEDS_LIMIT: Custom option value length exceeds maximum limit, min = 0) .",
										Computed:    true,
									},
									"vendor_class_identifier": dsschema.StringAttribute{
										Description: "Vendor Class Identifier.",
										Computed:    true,
									},
								},
							},
						},
						"default_lease_time": dsschema.Int64Attribute{
							Description: "Default Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
							Computed:    true,
						},
						"description": dsschema.StringAttribute{
							Description: "Description: Size(max = 256, error = DHCPSERVER_CONFIG_DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds the maximum limit., min = 0) .",
							Computed:    true,
						},
						"disabled": dsschema.BoolAttribute{
							Description: "Disabled.",
							Computed:    true,
						},
						"dns_servers": dsschema.ListAttribute{
							Description: "Dns Servers: Size(max = 3, error = DHCPSERVER_CONFIG_DNS_ENTRIES_EXCEEDS_LIMIT: Name servers count exceeds the maximum limit, min = 0) .",
							Computed:    true,
							ElementType: types.StringType,
						},
						"domain_name": dsschema.StringAttribute{
							Description: "Domain Name: Size(max = 256, error = DHCPSERVER_CONFIG_INVALID_DOMAIN_NAME: Domain name exceeds the maximum limit., min = 0) .",
							Computed:    true,
						},
						"etag": dsschema.Int64Attribute{
							Description: "Entity tag for the resource.",
							Computed:    true,
						},
						"gateway": dsschema.StringAttribute{
							Description: "Gateway.",
							Computed:    true,
						},
						"id": dsschema.StringAttribute{
							Description: "Id.",
							Computed:    true,
						},
						"ip_ranges": dsschema.ListNestedAttribute{
							Description: "Ip Ranges: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) Size(max = 2147483647, error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet., min = 1) Valid .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"end_ip":true, "start_ip":true} forceNew:map[string]bool(nil)
									"end_ip": dsschema.StringAttribute{
										Description: "End Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
										Computed:    true,
									},
									"start_ip": dsschema.StringAttribute{
										Description: "Start Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
										Computed:    true,
									},
								},
							},
						},
						"max_lease_time": dsschema.Int64Attribute{
							Description: "Max Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
							Computed:    true,
						},
						"network_context_id": dsschema.StringAttribute{
							Description: "Network Context Id: Digits(fraction = 0, integer = 50, error = INVALID_NETWORK_CTX_ID: Invalid network ctrx id.) .",
							Computed:    true,
						},
						"static_mappings": dsschema.ListNestedAttribute{
							Description: "Static Mappings: Valid .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"client_duid":true, "ip_address":true, "mac":true, "name":true} forceNew:map[string]bool(nil)
									"client_duid": dsschema.StringAttribute{
										Description: "Client Duid: Pattern(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_DUID: Invalid Client duid provided for static mapping., regexp = ([0-9a-fA-F]{1,2}:)*[0-9a-fA-F]{1,2}|([0-9a-fA-F]{1,2}:)*(:([0-9a-fA-F]{1,2}:)*)([0-9a-fA-F]{1,2})*) .",
										Computed:    true,
									},
									"ip_address": dsschema.StringAttribute{
										Description: "Ip Address: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) .",
										Computed:    true,
									},
									"mac": dsschema.StringAttribute{
										Description: "Mac: MACAddressFiveColons(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_MAC_ADDR: Invalid mac address provided for static mapping) .",
										Computed:    true,
									},
									"name": dsschema.StringAttribute{
										Description: "Name: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) Size(max = 256, error = DHCPSERVER_CONFIG_STATIC_MAPPING_NAME_EXCEEDS_LIMIT: Static Mapping name execeeds the maximum limit, min = 0) Pattern(error = DHCPSERVER_CONFIG_STATIC_MAPPING_UNSUPPORTED_NAME: Provide valid static mapping name, regexp = ^[a-zA-Z0-9]+(([a-zA-Z0-9\\\\-_])|(\\\\.?[a-zA-Z0-9\\\\-]))*\\\\.?$) .",
										Computed:    true,
									},
								},
							},
						},
						"subnet": dsschema.StringAttribute{
							Description: "Subnet: NotNull(error = DHCPSERVER_CONFIG_INVALID_SUBNET_ADDR: Invalid IPv4 subnet address.) .",
							Computed:    true,
						},
						"tags": dsschema.ListAttribute{
							Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = DHCPSERVER_CONFIG_INVALID_TAGS: Tags config is invalid- maximum 10 tags are supported, tag should not exceed maximum limit of 128 characters, it should not have duplicates., noTrim = false, regex = [^,\\\\s]+, required = false) .",
							Computed:    true,
							ElementType: types.StringType,
						},
						"vrf_context_id": dsschema.StringAttribute{
							Description: "Vrf Context Id.",
							Computed:    true,
						},
					},
				},
			},
			"site_id": dsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"total_items": dsschema.Int64Attribute{
				Description: "The TotalItems param.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *dhcpServerListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*sdwan.Client)
}

// Read performs Read for the struct.
func (d *dhcpServerListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state dhcpServerListDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source listing", map[string]any{
		"data_source_name":            "prismasdwan_dhcp_server_list",
		"terraform_provider_function": "Read",
		"site_id":                     state.SiteId.ValueString(),
	})

	// Prepare to run the command.
	svc := hHIIBxy.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := hHIIBxy.ListInput{}

	input.SiteId = StringValue(state.SiteId)

	// Perform the operation.
	ans, err := svc.List(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error getting listing", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if len(ans.Items) == 0 {
		state.Items = nil
	} else {
		state.Items = make([]dhcpServerListDsModel_dEowMJz_Config, 0, len(ans.Items))
		for _, var0 := range ans.Items {
			var1 := dhcpServerListDsModel_dEowMJz_Config{}

			var1.AddressFamily = types.StringValue(var0.AddressFamily)

			var1.BroadcastAddress = types.StringPointerValue(var0.BroadcastAddress)

			if len(var0.CustomOptions) == 0 {
				var1.CustomOptions = nil
			} else {
				var1.CustomOptions = make([]dhcpServerListDsModel_mqfebzt_Config, 0, len(var0.CustomOptions))
				for _, var2 := range var0.CustomOptions {
					var3 := dhcpServerListDsModel_mqfebzt_Config{}

					var3.OptionDefinition = types.StringValue(var2.OptionDefinition)

					var3.OptionValue = types.StringValue(var2.OptionValue)

					var3.VendorClassIdentifier = types.StringPointerValue(var2.VendorClassIdentifier)
					var1.CustomOptions = append(var1.CustomOptions, var3)
				}
			}

			var1.DefaultLeaseTime = types.Int64PointerValue(var0.DefaultLeaseTime)

			var1.Description = types.StringPointerValue(var0.Description)

			var1.Disabled = types.BoolPointerValue(var0.Disabled)

			var4, var5 := types.ListValueFrom(ctx, types.StringType, var0.DnsServers)
			var1.DnsServers = var4
			resp.Diagnostics.Append(var5.Errors()...)

			var1.DomainName = types.StringPointerValue(var0.DomainName)

			var1.Etag = types.Int64PointerValue(var0.Etag)

			var1.Gateway = types.StringPointerValue(var0.Gateway)

			var1.Id = types.StringPointerValue(var0.Id)

			if len(var0.IpRanges) == 0 {
				var1.IpRanges = nil
			} else {
				var1.IpRanges = make([]dhcpServerListDsModel_xygFTDt_Config, 0, len(var0.IpRanges))
				for _, var6 := range var0.IpRanges {
					var7 := dhcpServerListDsModel_xygFTDt_Config{}

					var7.EndIp = types.StringValue(var6.EndIp)

					var7.StartIp = types.StringValue(var6.StartIp)
					var1.IpRanges = append(var1.IpRanges, var7)
				}
			}

			var1.MaxLeaseTime = types.Int64PointerValue(var0.MaxLeaseTime)

			var1.NetworkContextId = types.StringPointerValue(var0.NetworkContextId)

			if len(var0.StaticMappings) == 0 {
				var1.StaticMappings = nil
			} else {
				var1.StaticMappings = make([]dhcpServerListDsModel_xqHSEzl_Config, 0, len(var0.StaticMappings))
				for _, var8 := range var0.StaticMappings {
					var9 := dhcpServerListDsModel_xqHSEzl_Config{}

					var9.ClientDuid = types.StringPointerValue(var8.ClientDuid)

					var9.IpAddress = types.StringValue(var8.IpAddress)

					var9.Mac = types.StringPointerValue(var8.Mac)

					var9.Name = types.StringValue(var8.Name)
					var1.StaticMappings = append(var1.StaticMappings, var9)
				}
			}

			var1.Subnet = types.StringValue(var0.Subnet)

			var10, var11 := types.ListValueFrom(ctx, types.StringType, var0.Tags)
			var1.Tags = var10
			resp.Diagnostics.Append(var11.Errors()...)

			var1.VrfContextId = types.StringPointerValue(var0.VrfContextId)
			state.Items = append(state.Items, var1)
		}
	}

	state.TotalItems = types.Int64PointerValue(ans.TotalItems)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Data source.
var (
	_ datasource.DataSource              = &dhcpServerDataSource{}
	_ datasource.DataSourceWithConfigure = &dhcpServerDataSource{}
)

func NewDhcpServerDataSource() datasource.DataSource {
	return &dhcpServerDataSource{}
}

type dhcpServerDataSource struct {
	client *sdwan.Client
}

// dhcpServerDsModel is the model.
type dhcpServerDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	DhcpServerId types.String `tfsdk:"dhcp_server_id"`
	SiteId       types.String `tfsdk:"site_id"`

	// Output.
	AddressFamily    types.String                       `tfsdk:"address_family"`
	BroadcastAddress types.String                       `tfsdk:"broadcast_address"`
	CustomOptions    []dhcpServerDsModel_mqfebzt_Config `tfsdk:"custom_options"`
	DefaultLeaseTime types.Int64                        `tfsdk:"default_lease_time"`
	Description      types.String                       `tfsdk:"description"`
	Disabled         types.Bool                         `tfsdk:"disabled"`
	DnsServers       types.List                         `tfsdk:"dns_servers"`
	DomainName       types.String                       `tfsdk:"domain_name"`
	Etag             types.Int64                        `tfsdk:"etag"`
	Gateway          types.String                       `tfsdk:"gateway"`
	Id               types.String                       `tfsdk:"id"`
	IpRanges         []dhcpServerDsModel_xygFTDt_Config `tfsdk:"ip_ranges"`
	MaxLeaseTime     types.Int64                        `tfsdk:"max_lease_time"`
	NetworkContextId types.String                       `tfsdk:"network_context_id"`
	StaticMappings   []dhcpServerDsModel_xqHSEzl_Config `tfsdk:"static_mappings"`
	Subnet           types.String                       `tfsdk:"subnet"`
	Tags             types.List                         `tfsdk:"tags"`
	VrfContextId     types.String                       `tfsdk:"vrf_context_id"`
}

type dhcpServerDsModel_mqfebzt_Config struct {
	OptionDefinition      types.String `tfsdk:"option_definition"`
	OptionValue           types.String `tfsdk:"option_value"`
	VendorClassIdentifier types.String `tfsdk:"vendor_class_identifier"`
}

type dhcpServerDsModel_xygFTDt_Config struct {
	EndIp   types.String `tfsdk:"end_ip"`
	StartIp types.String `tfsdk:"start_ip"`
}

type dhcpServerDsModel_xqHSEzl_Config struct {
	ClientDuid types.String `tfsdk:"client_duid"`
	IpAddress  types.String `tfsdk:"ip_address"`
	Mac        types.String `tfsdk:"mac"`
	Name       types.String `tfsdk:"name"`
}

// Metadata returns the data source type name.
func (d *dhcpServerDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dhcp_server"
}

// Schema defines the schema for this data source.
func (d *dhcpServerDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"dhcp_server_id":true, "site_id":true} outputs:map[string]bool{"address_family":true, "broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "etag":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true, "tfid":true, "vrf_context_id":true} forceNew:map[string]bool{"dhcp_server_id":true, "site_id":true}
			"address_family": dsschema.StringAttribute{
				Description: "Address Family: ValidateEnum(enumClass = classOf[IPAddressFamily], DHCP_CONFIG_ADDRESS_FAMILY_INVALID, nullAllowed = false) .",
				Computed:    true,
			},
			"broadcast_address": dsschema.StringAttribute{
				Description: "Broadcast Address.",
				Computed:    true,
			},
			"custom_options": dsschema.ListNestedAttribute{
				Description: "Custom Options: Valid .",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"option_definition":true, "option_value":true, "vendor_class_identifier":true} forceNew:map[string]bool(nil)
						"option_definition": dsschema.StringAttribute{
							Description: "Option Definition: NotEmpty(groups = [classOf[Definition]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_DEF_UNSUPPORTED: Custom option definition is not supported) Size(groups = [classOf[Definition]], max = 1024, error = DHCPSERVER_CONFIG_OPTION_DEF_EXCEEDS_LIMIT: Custom option definition length exceeeds maximum limit, min = 0) .",
							Computed:    true,
						},
						"option_value": dsschema.StringAttribute{
							Description: "Option Value: NotEmpty(groups = [classOf[Value]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_VAL_UNSUPPORTED: Custom option value is not supported) Size(groups = [classOf[Value]], max = 8192, error = DHCPSERVER_CONFIG_OPTION_VAL_EXCEEDS_LIMIT: Custom option value length exceeds maximum limit, min = 0) .",
							Computed:    true,
						},
						"vendor_class_identifier": dsschema.StringAttribute{
							Description: "Vendor Class Identifier.",
							Computed:    true,
						},
					},
				},
			},
			"default_lease_time": dsschema.Int64Attribute{
				Description: "Default Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
				Computed:    true,
			},
			"description": dsschema.StringAttribute{
				Description: "Description: Size(max = 256, error = DHCPSERVER_CONFIG_DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds the maximum limit., min = 0) .",
				Computed:    true,
			},
			"dhcp_server_id": dsschema.StringAttribute{
				Description: "Dhcp Server Id.",
				Required:    true,
			},
			"disabled": dsschema.BoolAttribute{
				Description: "Disabled.",
				Computed:    true,
			},
			"dns_servers": dsschema.ListAttribute{
				Description: "Dns Servers: Size(max = 3, error = DHCPSERVER_CONFIG_DNS_ENTRIES_EXCEEDS_LIMIT: Name servers count exceeds the maximum limit, min = 0) .",
				Computed:    true,
				ElementType: types.StringType,
			},
			"domain_name": dsschema.StringAttribute{
				Description: "Domain Name: Size(max = 256, error = DHCPSERVER_CONFIG_INVALID_DOMAIN_NAME: Domain name exceeds the maximum limit., min = 0) .",
				Computed:    true,
			},
			"etag": dsschema.Int64Attribute{
				Description: "Entity tag for the resource.",
				Computed:    true,
			},
			"gateway": dsschema.StringAttribute{
				Description: "Gateway.",
				Computed:    true,
			},
			"id": dsschema.StringAttribute{
				Description: "Id.",
				Computed:    true,
			},
			"ip_ranges": dsschema.ListNestedAttribute{
				Description: "Ip Ranges: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) Size(max = 2147483647, error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet., min = 1) Valid .",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"end_ip":true, "start_ip":true} forceNew:map[string]bool(nil)
						"end_ip": dsschema.StringAttribute{
							Description: "End Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
							Computed:    true,
						},
						"start_ip": dsschema.StringAttribute{
							Description: "Start Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
							Computed:    true,
						},
					},
				},
			},
			"max_lease_time": dsschema.Int64Attribute{
				Description: "Max Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
				Computed:    true,
			},
			"network_context_id": dsschema.StringAttribute{
				Description: "Network Context Id: Digits(fraction = 0, integer = 50, error = INVALID_NETWORK_CTX_ID: Invalid network ctrx id.) .",
				Computed:    true,
			},
			"site_id": dsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
			},
			"static_mappings": dsschema.ListNestedAttribute{
				Description: "Static Mappings: Valid .",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"client_duid":true, "ip_address":true, "mac":true, "name":true} forceNew:map[string]bool(nil)
						"client_duid": dsschema.StringAttribute{
							Description: "Client Duid: Pattern(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_DUID: Invalid Client duid provided for static mapping., regexp = ([0-9a-fA-F]{1,2}:)*[0-9a-fA-F]{1,2}|([0-9a-fA-F]{1,2}:)*(:([0-9a-fA-F]{1,2}:)*)([0-9a-fA-F]{1,2})*) .",
							Computed:    true,
						},
						"ip_address": dsschema.StringAttribute{
							Description: "Ip Address: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) .",
							Computed:    true,
						},
						"mac": dsschema.StringAttribute{
							Description: "Mac: MACAddressFiveColons(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_MAC_ADDR: Invalid mac address provided for static mapping) .",
							Computed:    true,
						},
						"name": dsschema.StringAttribute{
							Description: "Name: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) Size(max = 256, error = DHCPSERVER_CONFIG_STATIC_MAPPING_NAME_EXCEEDS_LIMIT: Static Mapping name execeeds the maximum limit, min = 0) Pattern(error = DHCPSERVER_CONFIG_STATIC_MAPPING_UNSUPPORTED_NAME: Provide valid static mapping name, regexp = ^[a-zA-Z0-9]+(([a-zA-Z0-9\\\\-_])|(\\\\.?[a-zA-Z0-9\\\\-]))*\\\\.?$) .",
							Computed:    true,
						},
					},
				},
			},
			"subnet": dsschema.StringAttribute{
				Description: "Subnet: NotNull(error = DHCPSERVER_CONFIG_INVALID_SUBNET_ADDR: Invalid IPv4 subnet address.) .",
				Computed:    true,
			},
			"tags": dsschema.ListAttribute{
				Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = DHCPSERVER_CONFIG_INVALID_TAGS: Tags config is invalid- maximum 10 tags are supported, tag should not exceed maximum limit of 128 characters, it should not have duplicates., noTrim = false, regex = [^,\\\\s]+, required = false) .",
				Computed:    true,
				ElementType: types.StringType,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"vrf_context_id": dsschema.StringAttribute{
				Description: "Vrf Context Id.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *dhcpServerDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*sdwan.Client)
}

// Read performs Read for the struct.
func (d *dhcpServerDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state dhcpServerDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source read", map[string]any{
		"data_source_name":            "prismasdwan_dhcp_server",
		"terraform_provider_function": "Read",
		"site_id":                     state.SiteId.ValueString(),
		"dhcp_server_id":              state.DhcpServerId.ValueString(),
	})

	// Prepare to run the command.
	svc := hHIIBxy.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := hHIIBxy.ReadInput{}

	input.SiteId = StringValue(state.SiteId)

	input.DhcpServerId = StringValue(state.DhcpServerId)

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error reading config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	idBuilder.WriteString(input.DhcpServerId)

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.AddressFamily = types.StringValue(ans.AddressFamily)

	state.BroadcastAddress = types.StringPointerValue(ans.BroadcastAddress)

	if len(ans.CustomOptions) == 0 {
		state.CustomOptions = nil
	} else {
		state.CustomOptions = make([]dhcpServerDsModel_mqfebzt_Config, 0, len(ans.CustomOptions))
		for _, var0 := range ans.CustomOptions {
			var1 := dhcpServerDsModel_mqfebzt_Config{}

			var1.OptionDefinition = types.StringValue(var0.OptionDefinition)

			var1.OptionValue = types.StringValue(var0.OptionValue)

			var1.VendorClassIdentifier = types.StringPointerValue(var0.VendorClassIdentifier)
			state.CustomOptions = append(state.CustomOptions, var1)
		}
	}

	state.DefaultLeaseTime = types.Int64PointerValue(ans.DefaultLeaseTime)

	state.Description = types.StringPointerValue(ans.Description)

	state.Disabled = types.BoolPointerValue(ans.Disabled)

	var2, var3 := types.ListValueFrom(ctx, types.StringType, ans.DnsServers)
	state.DnsServers = var2
	resp.Diagnostics.Append(var3.Errors()...)

	state.DomainName = types.StringPointerValue(ans.DomainName)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Gateway = types.StringPointerValue(ans.Gateway)

	state.Id = types.StringPointerValue(ans.Id)

	if len(ans.IpRanges) == 0 {
		state.IpRanges = nil
	} else {
		state.IpRanges = make([]dhcpServerDsModel_xygFTDt_Config, 0, len(ans.IpRanges))
		for _, var4 := range ans.IpRanges {
			var5 := dhcpServerDsModel_xygFTDt_Config{}

			var5.EndIp = types.StringValue(var4.EndIp)

			var5.StartIp = types.StringValue(var4.StartIp)
			state.IpRanges = append(state.IpRanges, var5)
		}
	}

	state.MaxLeaseTime = types.Int64PointerValue(ans.MaxLeaseTime)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	if len(ans.StaticMappings) == 0 {
		state.StaticMappings = nil
	} else {
		state.StaticMappings = make([]dhcpServerDsModel_xqHSEzl_Config, 0, len(ans.StaticMappings))
		for _, var6 := range ans.StaticMappings {
			var7 := dhcpServerDsModel_xqHSEzl_Config{}

			var7.ClientDuid = types.StringPointerValue(var6.ClientDuid)

			var7.IpAddress = types.StringValue(var6.IpAddress)

			var7.Mac = types.StringPointerValue(var6.Mac)

			var7.Name = types.StringValue(var6.Name)
			state.StaticMappings = append(state.StaticMappings, var7)
		}
	}

	state.Subnet = types.StringValue(ans.Subnet)

	var8, var9 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var8
	resp.Diagnostics.Append(var9.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Resource.
var (
	_ resource.Resource                = &dhcpServerResource{}
	_ resource.ResourceWithConfigure   = &dhcpServerResource{}
	_ resource.ResourceWithImportState = &dhcpServerResource{}
)

func NewDhcpServerResource() resource.Resource {
	return &dhcpServerResource{}
}

type dhcpServerResource struct {
	client *sdwan.Client
}

// dhcpServerRsModel is the model.
type dhcpServerRsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	AddressFamily    types.String                       `tfsdk:"address_family"`
	BroadcastAddress types.String                       `tfsdk:"broadcast_address"`
	CustomOptions    []dhcpServerRsModel_mqfebzt_Config `tfsdk:"custom_options"`
	DefaultLeaseTime types.Int64                        `tfsdk:"default_lease_time"`
	Description      types.String                       `tfsdk:"description"`
	Disabled         types.Bool                         `tfsdk:"disabled"`
	DnsServers       types.List                         `tfsdk:"dns_servers"`
	DomainName       types.String                       `tfsdk:"domain_name"`
	Etag             types.Int64                        `tfsdk:"etag"`
	Gateway          types.String                       `tfsdk:"gateway"`
	Id               types.String                       `tfsdk:"id"`
	IpRanges         []dhcpServerRsModel_xygFTDt_Config `tfsdk:"ip_ranges"`
	MaxLeaseTime     types.Int64                        `tfsdk:"max_lease_time"`
	NetworkContextId types.String                       `tfsdk:"network_context_id"`
	SiteId           types.String                       `tfsdk:"site_id"`
	StaticMappings   []dhcpServerRsModel_xqHSEzl_Config `tfsdk:"static_mappings"`
	Subnet           types.String                       `tfsdk:"subnet"`
	Tags             types.List                         `tfsdk:"tags"`
	VrfContextId     types.String                       `tfsdk:"vrf_context_id"`

	// Output.
	// omit input: address_family
	// omit input: broadcast_address
	// omit input: custom_options
	// omit input: default_lease_time
	// omit input: description
	// omit input: disabled
	// omit input: dns_servers
	// omit input: domain_name
	// omit input: etag
	// omit input: gateway
	// omit input: id
	// omit input: ip_ranges
	// omit input: max_lease_time
	// omit input: network_context_id
	// omit input: static_mappings
	// omit input: subnet
	// omit input: tags
	// omit input: vrf_context_id
}

type dhcpServerRsModel_mqfebzt_Config struct {
	OptionDefinition      types.String `tfsdk:"option_definition"`
	OptionValue           types.String `tfsdk:"option_value"`
	VendorClassIdentifier types.String `tfsdk:"vendor_class_identifier"`
}

type dhcpServerRsModel_xygFTDt_Config struct {
	EndIp   types.String `tfsdk:"end_ip"`
	StartIp types.String `tfsdk:"start_ip"`
}

type dhcpServerRsModel_xqHSEzl_Config struct {
	ClientDuid types.String `tfsdk:"client_duid"`
	IpAddress  types.String `tfsdk:"ip_address"`
	Mac        types.String `tfsdk:"mac"`
	Name       types.String `tfsdk:"name"`
}

// Metadata returns the data source type name.
func (r *dhcpServerResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_dhcp_server"
}

// Schema defines the schema for this data source.
func (r *dhcpServerResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]rsschema.Attribute{
			// inputs:map[string]bool{"address_family":true, "broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "etag":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "site_id":true, "static_mappings":true, "subnet":true, "tags":true, "vrf_context_id":true} outputs:map[string]bool{"address_family":true, "broadcast_address":true, "custom_options":true, "default_lease_time":true, "description":true, "disabled":true, "dns_servers":true, "domain_name":true, "etag":true, "gateway":true, "id":true, "ip_ranges":true, "max_lease_time":true, "network_context_id":true, "static_mappings":true, "subnet":true, "tags":true, "tfid":true, "vrf_context_id":true} forceNew:map[string]bool{"site_id":true}
			"address_family": rsschema.StringAttribute{
				Description: "Address Family: ValidateEnum(enumClass = classOf[IPAddressFamily], DHCP_CONFIG_ADDRESS_FAMILY_INVALID, nullAllowed = false) .",
				Required:    true,
			},
			"broadcast_address": rsschema.StringAttribute{
				Description: "Broadcast Address.",
				Optional:    true,
			},
			"custom_options": rsschema.ListNestedAttribute{
				Description: "Custom Options: Valid .",
				Optional:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"option_definition":true, "option_value":true, "vendor_class_identifier":true} outputs:map[string]bool{"option_definition":true, "option_value":true, "vendor_class_identifier":true} forceNew:map[string]bool(nil)
						"option_definition": rsschema.StringAttribute{
							Description: "Option Definition: NotEmpty(groups = [classOf[Definition]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_DEF_UNSUPPORTED: Custom option definition is not supported) Size(groups = [classOf[Definition]], max = 1024, error = DHCPSERVER_CONFIG_OPTION_DEF_EXCEEDS_LIMIT: Custom option definition length exceeeds maximum limit, min = 0) .",
							Required:    true,
						},
						"option_value": rsschema.StringAttribute{
							Description: "Option Value: NotEmpty(groups = [classOf[Value]], error = DHCPSERVER_CONFIG_CUSTOM_OPTIONS_VAL_UNSUPPORTED: Custom option value is not supported) Size(groups = [classOf[Value]], max = 8192, error = DHCPSERVER_CONFIG_OPTION_VAL_EXCEEDS_LIMIT: Custom option value length exceeds maximum limit, min = 0) .",
							Required:    true,
						},
						"vendor_class_identifier": rsschema.StringAttribute{
							Description: "Vendor Class Identifier.",
							Optional:    true,
						},
					},
				},
			},
			"default_lease_time": rsschema.Int64Attribute{
				Description: "Default Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_DEFAULT_LEASE_TIME: Default lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
				Optional:    true,
			},
			"description": rsschema.StringAttribute{
				Description: "Description: Size(max = 256, error = DHCPSERVER_CONFIG_DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds the maximum limit., min = 0) .",
				Optional:    true,
			},
			"disabled": rsschema.BoolAttribute{
				Description: "Disabled.",
				Optional:    true,
				Computed:    true,
			},
			"dns_servers": rsschema.ListAttribute{
				Description: "Dns Servers: Size(max = 3, error = DHCPSERVER_CONFIG_DNS_ENTRIES_EXCEEDS_LIMIT: Name servers count exceeds the maximum limit, min = 0) .",
				Optional:    true,
				ElementType: types.StringType,
			},
			"domain_name": rsschema.StringAttribute{
				Description: "Domain Name: Size(max = 256, error = DHCPSERVER_CONFIG_INVALID_DOMAIN_NAME: Domain name exceeds the maximum limit., min = 0) .",
				Optional:    true,
			},
			"etag": rsschema.Int64Attribute{
				Description: "Entity tag for the resource.",
				Optional:    true,
				Computed:    true,
			},
			"gateway": rsschema.StringAttribute{
				Description: "Gateway.",
				Optional:    true,
			},
			"id": rsschema.StringAttribute{
				Description: "Id.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"ip_ranges": rsschema.ListNestedAttribute{
				Description: "Ip Ranges: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) Size(max = 2147483647, error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet., min = 1) Valid .",
				Required:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"end_ip":true, "start_ip":true} outputs:map[string]bool{"end_ip":true, "start_ip":true} forceNew:map[string]bool(nil)
						"end_ip": rsschema.StringAttribute{
							Description: "End Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
							Required:    true,
						},
						"start_ip": rsschema.StringAttribute{
							Description: "Start Ip: NotNull(error = DHCPSERVER_CONFIG_IP_RANGE_MISSING: Provide valid IPv4/IPv6 address range for defined subnet.) .",
							Required:    true,
						},
					},
				},
			},
			"max_lease_time": rsschema.Int64Attribute{
				Description: "Max Lease Time: Min(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 300L) Max(error = DHCPSERVER_CONFIG_UNSUPPORTED_MAX_LEASE_TIME: Max lease time should be between 300 and 2^32-1 seconds respectively., value = 4294967295L) .",
				Optional:    true,
			},
			"network_context_id": rsschema.StringAttribute{
				Description: "Network Context Id: Digits(fraction = 0, integer = 50, error = INVALID_NETWORK_CTX_ID: Invalid network ctrx id.) .",
				Optional:    true,
			},
			"site_id": rsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"static_mappings": rsschema.ListNestedAttribute{
				Description: "Static Mappings: Valid .",
				Optional:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"client_duid":true, "ip_address":true, "mac":true, "name":true} outputs:map[string]bool{"client_duid":true, "ip_address":true, "mac":true, "name":true} forceNew:map[string]bool(nil)
						"client_duid": rsschema.StringAttribute{
							Description: "Client Duid: Pattern(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_DUID: Invalid Client duid provided for static mapping., regexp = ([0-9a-fA-F]{1,2}:)*[0-9a-fA-F]{1,2}|([0-9a-fA-F]{1,2}:)*(:([0-9a-fA-F]{1,2}:)*)([0-9a-fA-F]{1,2})*) .",
							Optional:    true,
						},
						"ip_address": rsschema.StringAttribute{
							Description: "Ip Address: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) .",
							Required:    true,
						},
						"mac": rsschema.StringAttribute{
							Description: "Mac: MACAddressFiveColons(error = DHCPSERVER_CONFIG_INVALID_STATIC_MAPPING_MAC_ADDR: Invalid mac address provided for static mapping) .",
							Optional:    true,
						},
						"name": rsschema.StringAttribute{
							Description: "Name: NotNull(error = DHCPSERVER_CONFIG_STATIC_MAPPING_MISSING: Provide all required attributes for static mappings.) Size(max = 256, error = DHCPSERVER_CONFIG_STATIC_MAPPING_NAME_EXCEEDS_LIMIT: Static Mapping name execeeds the maximum limit, min = 0) Pattern(error = DHCPSERVER_CONFIG_STATIC_MAPPING_UNSUPPORTED_NAME: Provide valid static mapping name, regexp = ^[a-zA-Z0-9]+(([a-zA-Z0-9\\\\-_])|(\\\\.?[a-zA-Z0-9\\\\-]))*\\\\.?$) .",
							Required:    true,
						},
					},
				},
			},
			"subnet": rsschema.StringAttribute{
				Description: "Subnet: NotNull(error = DHCPSERVER_CONFIG_INVALID_SUBNET_ADDR: Invalid IPv4 subnet address.) .",
				Required:    true,
			},
			"tags": rsschema.ListAttribute{
				Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = DHCPSERVER_CONFIG_INVALID_TAGS: Tags config is invalid- maximum 10 tags are supported, tag should not exceed maximum limit of 128 characters, it should not have duplicates., noTrim = false, regex = [^,\\\\s]+, required = false) .",
				Optional:    true,
				ElementType: types.StringType,
			},
			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"vrf_context_id": rsschema.StringAttribute{
				Description: "Vrf Context Id.",
				Optional:    true,
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (r *dhcpServerResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*sdwan.Client)
}

// Create resource.
func (r *dhcpServerResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state dhcpServerRsModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "prismasdwan_dhcp_server",
		"terraform_provider_function": "Create",
		"site_id":                     state.SiteId.ValueString(),
	})

	// Prepare to create the config.
	svc := hHIIBxy.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := hHIIBxy.CreateInput{}

	input.SiteId = StringValue(state.SiteId)
	input.Request = &dEowMJz.Config{}

	input.Request.AddressFamily = StringValue(state.AddressFamily)

	input.Request.BroadcastAddress = StringValueOrNil(state.BroadcastAddress)

	if len(state.CustomOptions) != 0 {
		input.Request.CustomOptions = make([]mqfebzt.Config, 0, len(state.CustomOptions))
		for _, var0 := range state.CustomOptions {
			var var1 mqfebzt.Config

			var1.OptionDefinition = StringValue(var0.OptionDefinition)

			var1.OptionValue = StringValue(var0.OptionValue)

			var1.VendorClassIdentifier = StringValueOrNil(var0.VendorClassIdentifier)
			input.Request.CustomOptions = append(input.Request.CustomOptions, var1)
		}
	}

	input.Request.DefaultLeaseTime = Int64ValueOrNil(state.DefaultLeaseTime)

	input.Request.Description = StringValueOrNil(state.Description)

	input.Request.Disabled = BoolValueOrNil(state.Disabled)

	input.Request.DnsServers = ListStringValueOrNil(ctx, state.DnsServers)

	input.Request.DomainName = StringValueOrNil(state.DomainName)

	input.Request.Etag = Int64ValueOrNil(state.Etag)

	input.Request.Gateway = StringValueOrNil(state.Gateway)

	if len(state.IpRanges) != 0 {
		input.Request.IpRanges = make([]xygFTDt.Config, 0, len(state.IpRanges))
		for _, var3 := range state.IpRanges {
			var var4 xygFTDt.Config

			var4.EndIp = StringValue(var3.EndIp)

			var4.StartIp = StringValue(var3.StartIp)
			input.Request.IpRanges = append(input.Request.IpRanges, var4)
		}
	}

	input.Request.MaxLeaseTime = Int64ValueOrNil(state.MaxLeaseTime)

	input.Request.NetworkContextId = StringValueOrNil(state.NetworkContextId)

	if len(state.StaticMappings) != 0 {
		input.Request.StaticMappings = make([]xqHSEzl.Config, 0, len(state.StaticMappings))
		for _, var5 := range state.StaticMappings {
			var var6 xqHSEzl.Config

			var6.ClientDuid = StringValueOrNil(var5.ClientDuid)

			var6.IpAddress = StringValue(var5.IpAddress)

			var6.Mac = StringValueOrNil(var5.Mac)

			var6.Name = StringValue(var5.Name)
			input.Request.StaticMappings = append(input.Request.StaticMappings, var6)
		}
	}

	input.Request.Subnet = StringValue(state.Subnet)

	input.Request.Tags = ListStringValueOrNil(ctx, state.Tags)

	input.Request.VrfContextId = StringValueOrNil(state.VrfContextId)

	// Perform the operation.
	ans, err := svc.Create(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error creating config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.AddressFamily = types.StringValue(ans.AddressFamily)

	state.BroadcastAddress = types.StringPointerValue(ans.BroadcastAddress)

	if len(ans.CustomOptions) == 0 {
		state.CustomOptions = nil
	} else {
		state.CustomOptions = make([]dhcpServerRsModel_mqfebzt_Config, 0, len(ans.CustomOptions))
		for _, var8 := range ans.CustomOptions {
			var9 := dhcpServerRsModel_mqfebzt_Config{}

			var9.OptionDefinition = types.StringValue(var8.OptionDefinition)

			var9.OptionValue = types.StringValue(var8.OptionValue)

			var9.VendorClassIdentifier = types.StringPointerValue(var8.VendorClassIdentifier)
			state.CustomOptions = append(state.CustomOptions, var9)
		}
	}

	state.DefaultLeaseTime = types.Int64PointerValue(ans.DefaultLeaseTime)

	state.Description = types.StringPointerValue(ans.Description)

	state.Disabled = types.BoolPointerValue(ans.Disabled)

	var10, var11 := types.ListValueFrom(ctx, types.StringType, ans.DnsServers)
	state.DnsServers = var10
	resp.Diagnostics.Append(var11.Errors()...)

	state.DomainName = types.StringPointerValue(ans.DomainName)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Gateway = types.StringPointerValue(ans.Gateway)

	state.Id = types.StringPointerValue(ans.Id)

	if len(ans.IpRanges) == 0 {
		state.IpRanges = nil
	} else {
		state.IpRanges = make([]dhcpServerRsModel_xygFTDt_Config, 0, len(ans.IpRanges))
		for _, var12 := range ans.IpRanges {
			var13 := dhcpServerRsModel_xygFTDt_Config{}

			var13.EndIp = types.StringValue(var12.EndIp)

			var13.StartIp = types.StringValue(var12.StartIp)
			state.IpRanges = append(state.IpRanges, var13)
		}
	}

	state.MaxLeaseTime = types.Int64PointerValue(ans.MaxLeaseTime)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	if len(ans.StaticMappings) == 0 {
		state.StaticMappings = nil
	} else {
		state.StaticMappings = make([]dhcpServerRsModel_xqHSEzl_Config, 0, len(ans.StaticMappings))
		for _, var14 := range ans.StaticMappings {
			var15 := dhcpServerRsModel_xqHSEzl_Config{}

			var15.ClientDuid = types.StringPointerValue(var14.ClientDuid)

			var15.IpAddress = types.StringValue(var14.IpAddress)

			var15.Mac = types.StringPointerValue(var14.Mac)

			var15.Name = types.StringValue(var14.Name)
			state.StaticMappings = append(state.StaticMappings, var15)
		}
	}

	state.Subnet = types.StringValue(ans.Subnet)

	var16, var17 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var16
	resp.Diagnostics.Append(var17.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Read performs Read for the struct.
func (r *dhcpServerResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var savestate, state dhcpServerRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := savestate.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 2 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 2 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "prismasdwan_dhcp_server",
		"locMap":                      map[string]int{"dhcp_server_id": 1, "site_id": 0},
		"tokens":                      tokens,
	})

	// Prepare to read the config.
	svc := hHIIBxy.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := hHIIBxy.ReadInput{}

	input.SiteId = tokens[0]

	input.DhcpServerId = tokens[1]

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading config", err.Error())
		}
		return
	}

	// Store the answer to state.

	if tokens[0] == "" {
		state.SiteId = types.StringNull()
	} else {
		state.SiteId = types.StringValue(tokens[0])
	}
	state.Tfid = savestate.Tfid

	state.AddressFamily = types.StringValue(ans.AddressFamily)

	state.BroadcastAddress = types.StringPointerValue(ans.BroadcastAddress)

	if len(ans.CustomOptions) == 0 {
		state.CustomOptions = nil
	} else {
		state.CustomOptions = make([]dhcpServerRsModel_mqfebzt_Config, 0, len(ans.CustomOptions))
		for _, var0 := range ans.CustomOptions {
			var1 := dhcpServerRsModel_mqfebzt_Config{}

			var1.OptionDefinition = types.StringValue(var0.OptionDefinition)

			var1.OptionValue = types.StringValue(var0.OptionValue)

			var1.VendorClassIdentifier = types.StringPointerValue(var0.VendorClassIdentifier)
			state.CustomOptions = append(state.CustomOptions, var1)
		}
	}

	state.DefaultLeaseTime = types.Int64PointerValue(ans.DefaultLeaseTime)

	state.Description = types.StringPointerValue(ans.Description)

	state.Disabled = types.BoolPointerValue(ans.Disabled)

	var2, var3 := types.ListValueFrom(ctx, types.StringType, ans.DnsServers)
	state.DnsServers = var2
	resp.Diagnostics.Append(var3.Errors()...)

	state.DomainName = types.StringPointerValue(ans.DomainName)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Gateway = types.StringPointerValue(ans.Gateway)

	state.Id = types.StringPointerValue(ans.Id)

	if len(ans.IpRanges) == 0 {
		state.IpRanges = nil
	} else {
		state.IpRanges = make([]dhcpServerRsModel_xygFTDt_Config, 0, len(ans.IpRanges))
		for _, var4 := range ans.IpRanges {
			var5 := dhcpServerRsModel_xygFTDt_Config{}

			var5.EndIp = types.StringValue(var4.EndIp)

			var5.StartIp = types.StringValue(var4.StartIp)
			state.IpRanges = append(state.IpRanges, var5)
		}
	}

	state.MaxLeaseTime = types.Int64PointerValue(ans.MaxLeaseTime)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	if len(ans.StaticMappings) == 0 {
		state.StaticMappings = nil
	} else {
		state.StaticMappings = make([]dhcpServerRsModel_xqHSEzl_Config, 0, len(ans.StaticMappings))
		for _, var6 := range ans.StaticMappings {
			var7 := dhcpServerRsModel_xqHSEzl_Config{}

			var7.ClientDuid = types.StringPointerValue(var6.ClientDuid)

			var7.IpAddress = types.StringValue(var6.IpAddress)

			var7.Mac = types.StringPointerValue(var6.Mac)

			var7.Name = types.StringValue(var6.Name)
			state.StaticMappings = append(state.StaticMappings, var7)
		}
	}

	state.Subnet = types.StringValue(ans.Subnet)

	var8, var9 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var8
	resp.Diagnostics.Append(var9.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update performs the Update for the struct.
func (r *dhcpServerResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state dhcpServerRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := state.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 2 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 2 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "prismasdwan_dhcp_server",
		"tfid":                        state.Tfid.ValueString(),
	})

	// Prepare to update the config.
	svc := hHIIBxy.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := hHIIBxy.UpdateInput{}

	if tokens[0] != "" {
		input.SiteId = tokens[0]
	}

	if tokens[1] != "" {
		input.DhcpServerId = tokens[1]
	}
	input.Request = &dEowMJz.Config{}

	input.Request.AddressFamily = ValueStringFromPlanOrState(plan.AddressFamily, state.AddressFamily)

	input.Request.BroadcastAddress = ValueStringPointerFromPlanOrState(plan.BroadcastAddress, state.BroadcastAddress)

	if len(plan.CustomOptions) != 0 || len(state.CustomOptions) != 0 {
		CustomOptionsToUse := plan.CustomOptions
		if len(plan.CustomOptions) == 0 {
			CustomOptionsToUse = state.CustomOptions
		}
		input.Request.CustomOptions = make([]mqfebzt.Config, 0, len(CustomOptionsToUse))
		for _, var0 := range plan.CustomOptions {
			var var1 mqfebzt.Config

			var1.OptionDefinition = StringValue(var0.OptionDefinition)

			var1.OptionValue = StringValue(var0.OptionValue)

			var1.VendorClassIdentifier = StringValueOrNil(var0.VendorClassIdentifier)
			input.Request.CustomOptions = append(input.Request.CustomOptions, var1)
		}
	}

	input.Request.DefaultLeaseTime = ValueInt64PointerFromPlanOrState(plan.DefaultLeaseTime, state.DefaultLeaseTime)

	input.Request.Description = ValueStringPointerFromPlanOrState(plan.Description, state.Description)

	input.Request.Disabled = ValueBoolPointerFromPlanOrState(plan.Disabled, state.Disabled)

	input.Request.DnsServers = ListStringValueOrNil(ctx, plan.DnsServers)

	input.Request.DomainName = ValueStringPointerFromPlanOrState(plan.DomainName, state.DomainName)

	input.Request.Etag = ValueInt64PointerFromPlanOrState(plan.Etag, state.Etag)

	input.Request.Gateway = ValueStringPointerFromPlanOrState(plan.Gateway, state.Gateway)

	if len(plan.IpRanges) != 0 || len(state.IpRanges) != 0 {
		IpRangesToUse := plan.IpRanges
		if len(plan.IpRanges) == 0 {
			IpRangesToUse = state.IpRanges
		}
		input.Request.IpRanges = make([]xygFTDt.Config, 0, len(IpRangesToUse))
		for _, var3 := range plan.IpRanges {
			var var4 xygFTDt.Config

			var4.EndIp = StringValue(var3.EndIp)

			var4.StartIp = StringValue(var3.StartIp)
			input.Request.IpRanges = append(input.Request.IpRanges, var4)
		}
	}

	input.Request.MaxLeaseTime = ValueInt64PointerFromPlanOrState(plan.MaxLeaseTime, state.MaxLeaseTime)

	input.Request.NetworkContextId = ValueStringPointerFromPlanOrState(plan.NetworkContextId, state.NetworkContextId)

	if len(plan.StaticMappings) != 0 || len(state.StaticMappings) != 0 {
		StaticMappingsToUse := plan.StaticMappings
		if len(plan.StaticMappings) == 0 {
			StaticMappingsToUse = state.StaticMappings
		}
		input.Request.StaticMappings = make([]xqHSEzl.Config, 0, len(StaticMappingsToUse))
		for _, var5 := range plan.StaticMappings {
			var var6 xqHSEzl.Config

			var6.ClientDuid = StringValueOrNil(var5.ClientDuid)

			var6.IpAddress = StringValue(var5.IpAddress)

			var6.Mac = StringValueOrNil(var5.Mac)

			var6.Name = StringValue(var5.Name)
			input.Request.StaticMappings = append(input.Request.StaticMappings, var6)
		}
	}

	input.Request.Subnet = ValueStringFromPlanOrState(plan.Subnet, state.Subnet)

	input.Request.Tags = ListStringValueOrNil(ctx, plan.Tags)

	input.Request.VrfContextId = ValueStringPointerFromPlanOrState(plan.VrfContextId, state.VrfContextId)

	// Perform the operation.
	ans, err := svc.Update(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error updating resource", err.Error())
		}
		return
	}

	// Store the answer to state.
	// Note: when supporting importing a resource, this will need to change to taking
	// values from the savestate.Tfid param and locMap.

	state.AddressFamily = types.StringValue(ans.AddressFamily)

	state.BroadcastAddress = types.StringPointerValue(ans.BroadcastAddress)

	if len(ans.CustomOptions) == 0 {
		state.CustomOptions = nil
	} else {
		state.CustomOptions = make([]dhcpServerRsModel_mqfebzt_Config, 0, len(ans.CustomOptions))
		for _, var8 := range ans.CustomOptions {
			var9 := dhcpServerRsModel_mqfebzt_Config{}

			var9.OptionDefinition = types.StringValue(var8.OptionDefinition)

			var9.OptionValue = types.StringValue(var8.OptionValue)

			var9.VendorClassIdentifier = types.StringPointerValue(var8.VendorClassIdentifier)
			state.CustomOptions = append(state.CustomOptions, var9)
		}
	}

	state.DefaultLeaseTime = types.Int64PointerValue(ans.DefaultLeaseTime)

	state.Description = types.StringPointerValue(ans.Description)

	state.Disabled = types.BoolPointerValue(ans.Disabled)

	var10, var11 := types.ListValueFrom(ctx, types.StringType, ans.DnsServers)
	state.DnsServers = var10
	resp.Diagnostics.Append(var11.Errors()...)

	state.DomainName = types.StringPointerValue(ans.DomainName)

	state.Etag = types.Int64PointerValue(ans.Etag)

	state.Gateway = types.StringPointerValue(ans.Gateway)

	state.Id = types.StringPointerValue(ans.Id)

	if len(ans.IpRanges) == 0 {
		state.IpRanges = nil
	} else {
		state.IpRanges = make([]dhcpServerRsModel_xygFTDt_Config, 0, len(ans.IpRanges))
		for _, var12 := range ans.IpRanges {
			var13 := dhcpServerRsModel_xygFTDt_Config{}

			var13.EndIp = types.StringValue(var12.EndIp)

			var13.StartIp = types.StringValue(var12.StartIp)
			state.IpRanges = append(state.IpRanges, var13)
		}
	}

	state.MaxLeaseTime = types.Int64PointerValue(ans.MaxLeaseTime)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	if len(ans.StaticMappings) == 0 {
		state.StaticMappings = nil
	} else {
		state.StaticMappings = make([]dhcpServerRsModel_xqHSEzl_Config, 0, len(ans.StaticMappings))
		for _, var14 := range ans.StaticMappings {
			var15 := dhcpServerRsModel_xqHSEzl_Config{}

			var15.ClientDuid = types.StringPointerValue(var14.ClientDuid)

			var15.IpAddress = types.StringValue(var14.IpAddress)

			var15.Mac = types.StringPointerValue(var14.Mac)

			var15.Name = types.StringValue(var14.Name)
			state.StaticMappings = append(state.StaticMappings, var15)
		}
	}

	state.Subnet = types.StringValue(ans.Subnet)

	var16, var17 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var16
	resp.Diagnostics.Append(var17.Errors()...)

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete performs delete for the struct.
func (r *dhcpServerResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var idType types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("tfid"), &idType)...)
	if resp.Diagnostics.HasError() {
		return
	}
	tfid := idType.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 2 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 2 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "prismasdwan_dhcp_server",
		"locMap":                      map[string]int{"dhcp_server_id": 1, "site_id": 0},
		"tokens":                      tokens,
	})

	svc := hHIIBxy.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := hHIIBxy.DeleteInput{}

	input.SiteId = tokens[0]

	input.DhcpServerId = tokens[1]

	// Perform the operation.
	if _, err := svc.Delete(ctx, input); err != nil && !IsObjectNotFound(err) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}
}

func (r *dhcpServerResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}

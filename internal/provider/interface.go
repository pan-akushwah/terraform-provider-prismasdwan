package provider

// Note:  This file is automatically generated.  Manually made changes
// will be overwritten when the provider is generated.

import (
	"context"
	"strings"

	"github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk"
	aeWshcf "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/apnconfig"
	mIAatvm "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/authentication/intf/config"
	zGfKFAQ "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/bypass/pair/v2"
	eumQbRC "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/cellular/intf/config"
	mCcgFKg "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dhcprelay"
	tOChZgD "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dhcprelay/option82"
	mTuoPRe "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/dns"
	ujXZojh "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ethernet"
	ehJLagQ "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ethernet/port"
	suSmnCD "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/greconfig"
	mKyPIKy "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ikev1/params"
	quvWIWu "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/intf/screen/v4/n18"
	xdEvbZX "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipsecauthentication/v1"
	nnsRzDg "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipsecconfig/v1"
	wsoFfyL "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv4/config"
	rKcwmLF "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv4/dhcp"
	cvAyZuw "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv4/pppoe"
	xYviIkG "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv4/rnge"
	nfiOrAO "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv4/static"
	bMGDwkY "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv6/config/v1"
	juuQHdk "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv6/dhcp"
	lIDFRUy "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/ipv6/static/v1"
	irQawLY "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/lan/network/vlan/mapping"
	zLXjrfn "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/multicast/intf/config"
	alJfwdK "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/nat/pool"
	wiUYuNU "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/passive/mode"
	pjMVEcr "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/peer/info"
	yxxGXUe "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/pppo/einterface/config"
	bBEnHsN "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/route"
	jmyEuEW "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/secondary/ipconfig"
	obJkRYB "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/service/link/v4"
	pWDbfYi "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/static/arpconfig"
	qhDZEMT "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/storm/control/config"
	jEYlBbY "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/sub/intf"
	kslrKbF "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/switch/port/config"
	aCdiNxV "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/vlan/config"
	qSUpByF "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/schemas/x509/objects"
	aSvnUVk "github.com/paloaltonetworks/terraform-provider-prismasdwan/sdk/sdwan/services/sdwan/v418/api/sites/siteid/elements/elementid/interfaces"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	dsschema "github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	rsschema "github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Data source (listing).
var (
	_ datasource.DataSource              = &interfaceListDataSource{}
	_ datasource.DataSourceWithConfigure = &interfaceListDataSource{}
)

func NewInterfaceListDataSource() datasource.DataSource {
	return &interfaceListDataSource{}
}

type interfaceListDataSource struct {
	client *sdwan.Client
}

// interfaceListDsModel is the model.
type interfaceListDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	ElementId types.String `tfsdk:"element_id"`
	SiteId    types.String `tfsdk:"site_id"`

	// Output.
	Items      []interfaceListDsModel_quvWIWu_Config `tfsdk:"items"`
	TotalItems types.Int64                           `tfsdk:"total_items"`
}

type interfaceListDsModel_quvWIWu_Config struct {
	AdminUp                    types.Bool                            `tfsdk:"admin_up"`
	AttachedLanNetworks        []interfaceListDsModel_irQawLY_Config `tfsdk:"attached_lan_networks"`
	AuthenticationConfig       *interfaceListDsModel_mIAatvm_Config  `tfsdk:"authentication_config"`
	BoundInterfaces            types.List                            `tfsdk:"bound_interfaces"`
	BypassPair                 *interfaceListDsModel_zGfKFAQ_Config  `tfsdk:"bypass_pair"`
	CellularConfig             *interfaceListDsModel_eumQbRC_Config  `tfsdk:"cellular_config"`
	Description                types.String                          `tfsdk:"description"`
	DevicemgmtPolicysetstackId types.String                          `tfsdk:"devicemgmt_policysetstack_id"`
	DhcpRelay                  *interfaceListDsModel_mCcgFKg_Config  `tfsdk:"dhcp_relay"`
	DirectedBroadcast          types.Bool                            `tfsdk:"directed_broadcast"`
	Etag                       types.Int64                           `tfsdk:"etag"`
	EthernetPort               *interfaceListDsModel_ehJLagQ_Config  `tfsdk:"ethernet_port"`
	Id                         types.String                          `tfsdk:"id"`
	InterfaceProfileId         types.String                          `tfsdk:"interface_profile_id"`
	IpfixcollectorcontextId    types.String                          `tfsdk:"ipfixcollectorcontext_id"`
	IpfixfiltercontextId       types.String                          `tfsdk:"ipfixfiltercontext_id"`
	Ipv4Config                 *interfaceListDsModel_wsoFfyL_Config  `tfsdk:"ipv4_config"`
	Ipv6Config                 *interfaceListDsModel_bMGDwkY_Config  `tfsdk:"ipv6_config"`
	LldpEnabled                types.Bool                            `tfsdk:"lldp_enabled"`
	MacAddress                 types.String                          `tfsdk:"mac_address"`
	Mtu                        types.Int64                           `tfsdk:"mtu"`
	MulticastConfig            *interfaceListDsModel_zLXjrfn_Config  `tfsdk:"multicast_config"`
	Name                       types.String                          `tfsdk:"name"`
	NatAddress                 types.String                          `tfsdk:"nat_address"`
	NatAddressV6               types.String                          `tfsdk:"nat_address_v6"`
	NatPools                   []interfaceListDsModel_alJfwdK_Config `tfsdk:"nat_pools"`
	NatPort                    types.Int64                           `tfsdk:"nat_port"`
	NatPortV6                  types.Int64                           `tfsdk:"nat_port_v6"`
	NatZoneId                  types.String                          `tfsdk:"nat_zone_id"`
	NetworkContextId           types.String                          `tfsdk:"network_context_id"`
	Parent                     types.String                          `tfsdk:"parent"`
	PeerBypasspairWanPortType  types.String                          `tfsdk:"peer_bypasspair_wan_port_type"`
	PoeEnabled                 types.Bool                            `tfsdk:"poe_enabled"`
	PowerUsageThreshold        types.Int64                           `tfsdk:"power_usage_threshold"`
	PppoeConfig                *interfaceListDsModel_yxxGXUe_Config  `tfsdk:"pppoe_config"`
	Scope                      types.String                          `tfsdk:"scope"`
	SecondaryIpConfigs         []interfaceListDsModel_jmyEuEW_Config `tfsdk:"secondary_ip_configs"`
	ServiceLinkConfig          *interfaceListDsModel_obJkRYB_Config  `tfsdk:"service_link_config"`
	SiteWanInterfaceIds        types.List                            `tfsdk:"site_wan_interface_ids"`
	StaticArpConfigs           []interfaceListDsModel_pWDbfYi_Config `tfsdk:"static_arp_configs"`
	SubInterface               *interfaceListDsModel_jEYlBbY_Config  `tfsdk:"sub_interface"`
	SwitchPortConfig           *interfaceListDsModel_kslrKbF_Config  `tfsdk:"switch_port_config"`
	Tags                       types.List                            `tfsdk:"tags"`
	Type                       types.String                          `tfsdk:"type"`
	UsedFor                    types.String                          `tfsdk:"used_for"`
	VlanConfig                 *interfaceListDsModel_aCdiNxV_Config  `tfsdk:"vlan_config"`
	VrfContextId               types.String                          `tfsdk:"vrf_context_id"`
}

type interfaceListDsModel_irQawLY_Config struct {
	LanNetworkId types.String `tfsdk:"lan_network_id"`
	VlanId       types.Int64  `tfsdk:"vlan_id"`
}

type interfaceListDsModel_mIAatvm_Config struct {
	FallbackRetryCount      types.Int64  `tfsdk:"fallback_retry_count"`
	Mode                    types.String `tfsdk:"mode"`
	ReauthenticationTimeout types.Int64  `tfsdk:"reauthentication_timeout"`
}

type interfaceListDsModel_zGfKFAQ_Config struct {
	Lan                 types.String `tfsdk:"lan"`
	LanStatePropagation types.Bool   `tfsdk:"lan_state_propagation"`
	UseRelay            types.Bool   `tfsdk:"use_relay"`
	Wan                 types.String `tfsdk:"wan"`
}

type interfaceListDsModel_eumQbRC_Config struct {
	ApnConfig           *interfaceListDsModel_aeWshcf_Config `tfsdk:"apn_config"`
	ApnprofileId        types.String                         `tfsdk:"apnprofile_id"`
	AutoApn             types.Bool                           `tfsdk:"auto_apn"`
	ParentModuleId      types.String                         `tfsdk:"parent_module_id"`
	ParentSimSlotNumber types.Int64                          `tfsdk:"parent_sim_slot_number"`
}

type interfaceListDsModel_aeWshcf_Config struct {
	Apn               types.String `tfsdk:"apn"`
	Authentication    types.String `tfsdk:"authentication"`
	ClearPassword     types.Bool   `tfsdk:"clear_password"`
	Password          types.String `tfsdk:"password"`
	PasswordEncrypted types.String `tfsdk:"password_encrypted"`
	UserName          types.String `tfsdk:"user_name"`
}

type interfaceListDsModel_mCcgFKg_Config struct {
	Enabled         types.Bool                           `tfsdk:"enabled"`
	Option82        *interfaceListDsModel_tOChZgD_Config `tfsdk:"option_82"`
	ServerIps       types.List                           `tfsdk:"server_ips"`
	SourceInterface types.String                         `tfsdk:"source_interface"`
}

type interfaceListDsModel_tOChZgD_Config struct {
	CircuitId          types.String `tfsdk:"circuit_id"`
	Enabled            types.Bool   `tfsdk:"enabled"`
	ReforwardingPolicy types.String `tfsdk:"reforwarding_policy"`
	RemoteId           types.String `tfsdk:"remote_id"`
}

type interfaceListDsModel_ehJLagQ_Config struct {
	FullDuplex types.Bool                           `tfsdk:"full_duplex"`
	PortId     *interfaceListDsModel_ujXZojh_Config `tfsdk:"port_id"`
	PortName   types.String                         `tfsdk:"port_name"`
	Speed      types.Int64                          `tfsdk:"speed"`
}

type interfaceListDsModel_ujXZojh_Config struct {
	Connector          types.String `tfsdk:"connector"`
	Device             types.String `tfsdk:"device"`
	Disabled           types.Bool   `tfsdk:"disabled"`
	DisabledReason     types.String `tfsdk:"disabled_reason"`
	ElementId          types.String `tfsdk:"element_id"`
	Id                 types.String `tfsdk:"id"`
	Inactive           types.Bool   `tfsdk:"inactive"`
	InactiveReason     types.String `tfsdk:"inactive_reason"`
	MaxMtu             types.Int64  `tfsdk:"max_mtu"`
	MaxSpeed           types.Int64  `tfsdk:"max_speed"`
	Name               types.String `tfsdk:"name"`
	OriginalMacAddress types.String `tfsdk:"original_mac_address"`
	Region             types.String `tfsdk:"region"`
	SiteId             types.String `tfsdk:"site_id"`
}

type interfaceListDsModel_wsoFfyL_Config struct {
	DhcpConfig   *interfaceListDsModel_rKcwmLF_Config  `tfsdk:"dhcp_config"`
	DnsV4Config  *interfaceListDsModel_mTuoPRe_Config  `tfsdk:"dns_v4_config"`
	PppoeConfig  *interfaceListDsModel_cvAyZuw_Config  `tfsdk:"pppoe_config"`
	Routes       []interfaceListDsModel_bBEnHsN_Config `tfsdk:"routes"`
	StaticConfig *interfaceListDsModel_nfiOrAO_Config  `tfsdk:"static_config"`
	Type         types.String                          `tfsdk:"type"`
}

type interfaceListDsModel_rKcwmLF_Config struct {
	ClientId types.String `tfsdk:"client_id"`
	Hostname types.String `tfsdk:"hostname"`
}

type interfaceListDsModel_mTuoPRe_Config struct {
	NameServers types.List `tfsdk:"name_servers"`
	Search      types.List `tfsdk:"search"`
}

type interfaceListDsModel_cvAyZuw_Config struct {
	ChapPasswd types.String `tfsdk:"chap_passwd"`
	ChapUser   types.String `tfsdk:"chap_user"`
	SetRoute   types.Bool   `tfsdk:"set_route"`
}

type interfaceListDsModel_bBEnHsN_Config struct {
	Destination types.String `tfsdk:"destination"`
	Via         types.String `tfsdk:"via"`
}

type interfaceListDsModel_nfiOrAO_Config struct {
	Address types.String `tfsdk:"address"`
}

type interfaceListDsModel_bMGDwkY_Config struct {
	DhcpConfig   *interfaceListDsModel_juuQHdk_Config  `tfsdk:"dhcp_config"`
	DnsV6Config  *interfaceListDsModel_mTuoPRe_Config  `tfsdk:"dns_v6_config"`
	Routes       []interfaceListDsModel_bBEnHsN_Config `tfsdk:"routes"`
	StaticConfig *interfaceListDsModel_lIDFRUy_Config  `tfsdk:"static_config"`
	Type         types.String                          `tfsdk:"type"`
}

type interfaceListDsModel_juuQHdk_Config struct {
	ClientId types.String `tfsdk:"client_id"`
	Hostname types.String `tfsdk:"hostname"`
}

type interfaceListDsModel_lIDFRUy_Config struct {
	Address                  types.String `tfsdk:"address"`
	EnablePrefixDistribution types.Bool   `tfsdk:"enable_prefix_distribution"`
}

type interfaceListDsModel_zLXjrfn_Config struct {
	IgmpVersion      types.String `tfsdk:"igmp_version"`
	MulticastEnabled types.Bool   `tfsdk:"multicast_enabled"`
}

type interfaceListDsModel_alJfwdK_Config struct {
	Ipv4Ranges []interfaceListDsModel_xYviIkG_Config `tfsdk:"ipv4_ranges"`
	NatPoolId  types.String                          `tfsdk:"nat_pool_id"`
}

type interfaceListDsModel_xYviIkG_Config struct {
	End   types.String `tfsdk:"end"`
	Start types.String `tfsdk:"start"`
}

type interfaceListDsModel_yxxGXUe_Config struct {
	HostUniq          types.String `tfsdk:"host_uniq"`
	IpAddressType     types.String `tfsdk:"ip_address_type"`
	Password          types.String `tfsdk:"password"`
	ReconnectionDelay types.Int64  `tfsdk:"reconnection_delay"`
	ServiceName       types.String `tfsdk:"service_name"`
	Username          types.String `tfsdk:"username"`
}

type interfaceListDsModel_jmyEuEW_Config struct {
	Ipv4Address types.String `tfsdk:"ipv4_address"`
	Scope       types.String `tfsdk:"scope"`
}

type interfaceListDsModel_obJkRYB_Config struct {
	GreConfig         *interfaceListDsModel_suSmnCD_Config `tfsdk:"gre_config"`
	IpsecConfig       *interfaceListDsModel_nnsRzDg_Config `tfsdk:"ipsec_config"`
	LastParent        types.String                         `tfsdk:"last_parent"`
	Parent            types.String                         `tfsdk:"parent"`
	PassiveMode       *interfaceListDsModel_wiUYuNU_Config `tfsdk:"passive_mode"`
	Peer              *interfaceListDsModel_pjMVEcr_Config `tfsdk:"peer"`
	ServiceEndpointId types.String                         `tfsdk:"service_endpoint_id"`
	Type              types.String                         `tfsdk:"type"`
}

type interfaceListDsModel_suSmnCD_Config struct {
	Csum               types.Bool  `tfsdk:"csum"`
	KeepaliveEnable    types.Bool  `tfsdk:"keepalive_enable"`
	KeepaliveFailCount types.Int64 `tfsdk:"keepalive_fail_count"`
	KeepaliveInterval  types.Int64 `tfsdk:"keepalive_interval"`
}

type interfaceListDsModel_nnsRzDg_Config struct {
	Authentication *interfaceListDsModel_xdEvbZX_Config `tfsdk:"authentication"`
	IpsecProfileId types.String                         `tfsdk:"ipsec_profile_id"`
}

type interfaceListDsModel_xdEvbZX_Config struct {
	Certificate                        types.String                         `tfsdk:"certificate"`
	CertificateProfileId               types.String                         `tfsdk:"certificate_profile_id"`
	Comment                            types.String                         `tfsdk:"comment"`
	Ikev1Params                        *interfaceListDsModel_mKyPIKy_Config `tfsdk:"ikev1_params"`
	LocalCaCertificate                 types.String                         `tfsdk:"local_ca_certificate"`
	LocalId                            types.String                         `tfsdk:"local_id"`
	LocalIdCustom                      types.String                         `tfsdk:"local_id_custom"`
	LocalPaCertificateId               types.String                         `tfsdk:"local_pa_certificate_id"`
	PaMasterKeyId                      types.String                         `tfsdk:"pa_master_key_id"`
	Passphrase                         types.String                         `tfsdk:"passphrase"`
	PassphraseEncrypted                types.String                         `tfsdk:"passphrase_encrypted"`
	PeerIdCheck                        types.String                         `tfsdk:"peer_id_check"`
	PermitPeerIdMismatch               types.Bool                           `tfsdk:"permit_peer_id_mismatch"`
	PrivateKey                         types.String                         `tfsdk:"private_key"`
	PrivateKeyEncrypted                types.String                         `tfsdk:"private_key_encrypted"`
	RemoteCaCertificate                types.String                         `tfsdk:"remote_ca_certificate"`
	RemoteId                           types.String                         `tfsdk:"remote_id"`
	Secret                             types.String                         `tfsdk:"secret"`
	SecretEncrypted                    types.String                         `tfsdk:"secret_encrypted"`
	SecretHash                         types.String                         `tfsdk:"secret_hash"`
	StrictValidationPeerExtendedKeyUse types.Bool                           `tfsdk:"strict_validation_peer_extended_key_use"`
	Type                               types.String                         `tfsdk:"type"`
	X509Objects                        *interfaceListDsModel_qSUpByF_Config `tfsdk:"x509_objects"`
}

type interfaceListDsModel_mKyPIKy_Config struct {
	XauthId              types.String `tfsdk:"xauth_id"`
	XauthSecret          types.String `tfsdk:"xauth_secret"`
	XauthSecretEncrypted types.String `tfsdk:"xauth_secret_encrypted"`
	XauthSecretHash      types.String `tfsdk:"xauth_secret_hash"`
	XauthType            types.String `tfsdk:"xauth_type"`
}

type interfaceListDsModel_qSUpByF_Config struct {
	CertHolder          types.Bool   `tfsdk:"cert_holder"`
	Certificate         types.String `tfsdk:"certificate"`
	IsLocalCaCertSet    types.Bool   `tfsdk:"is_local_ca_cert_set"`
	IsRemoteCaCertSet   types.Bool   `tfsdk:"is_remote_ca_cert_set"`
	KeyPair             types.Bool   `tfsdk:"key_pair"`
	LocalCaCertificate  types.String `tfsdk:"local_ca_certificate"`
	LocalCaCertsSet     types.List   `tfsdk:"local_ca_certs_set"`
	Passphrase          types.String `tfsdk:"passphrase"`
	PrivateKey          types.String `tfsdk:"private_key"`
	RemoteCaCertificate types.String `tfsdk:"remote_ca_certificate"`
	RemoteCaCertsSet    types.List   `tfsdk:"remote_ca_certs_set"`
}

type interfaceListDsModel_wiUYuNU_Config struct {
	Enable        types.Bool `tfsdk:"enable"`
	PeerIpDynamic types.Bool `tfsdk:"peer_ip_dynamic"`
}

type interfaceListDsModel_pjMVEcr_Config struct {
	Hostname    types.String `tfsdk:"hostname"`
	IpAddresses types.List   `tfsdk:"ip_addresses"`
}

type interfaceListDsModel_pWDbfYi_Config struct {
	Ipv4Address types.String `tfsdk:"ipv4_address"`
	MacAddress  types.String `tfsdk:"mac_address"`
}

type interfaceListDsModel_jEYlBbY_Config struct {
	VlanId types.Int64 `tfsdk:"vlan_id"`
}

type interfaceListDsModel_kslrKbF_Config struct {
	AccessVlanId       types.Int64                          `tfsdk:"access_vlan_id"`
	BpduGuardEnabled   types.Bool                           `tfsdk:"bpdu_guard_enabled"`
	ForwardFastEnabled types.Bool                           `tfsdk:"forward_fast_enabled"`
	NativeVlanId       types.Int64                          `tfsdk:"native_vlan_id"`
	RootGuardEnabled   types.Bool                           `tfsdk:"root_guard_enabled"`
	StormControlConfig *interfaceListDsModel_qhDZEMT_Config `tfsdk:"storm_control_config"`
	StpPortCost        types.Int64                          `tfsdk:"stp_port_cost"`
	StpPortEnabled     types.Bool                           `tfsdk:"stp_port_enabled"`
	StpPortPriority    types.Int64                          `tfsdk:"stp_port_priority"`
	TrunkVlans         types.List                           `tfsdk:"trunk_vlans"`
	VlanMode           types.String                         `tfsdk:"vlan_mode"`
	VoiceVlanId        types.Int64                          `tfsdk:"voice_vlan_id"`
}

type interfaceListDsModel_qhDZEMT_Config struct {
	BroadcastThreshold types.Int64 `tfsdk:"broadcast_threshold"`
	MulticastThreshold types.Int64 `tfsdk:"multicast_threshold"`
	UnicastThreshold   types.Int64 `tfsdk:"unicast_threshold"`
}

type interfaceListDsModel_aCdiNxV_Config struct {
	MstpInstance types.Int64 `tfsdk:"mstp_instance"`
	VlanId       types.Int64 `tfsdk:"vlan_id"`
	VoiceEnabled types.Bool  `tfsdk:"voice_enabled"`
}

// Metadata returns the data source type name.
func (d *interfaceListDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_interface_list"
}

// Schema defines the schema for this listing data source.
func (d *interfaceListDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a listing of config items.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"element_id":true, "site_id":true} outputs:map[string]bool{"items":true, "tfid":true, "total_items":true} forceNew:map[string]bool{"element_id":true, "site_id":true}
			"element_id": dsschema.StringAttribute{
				Description: "Element Id.",
				Required:    true,
			},
			"items": dsschema.ListNestedAttribute{
				Description: "The Items param.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"admin_up":true, "attached_lan_networks":true, "authentication_config":true, "bound_interfaces":true, "bypass_pair":true, "cellular_config":true, "description":true, "devicemgmt_policysetstack_id":true, "dhcp_relay":true, "directed_broadcast":true, "etag":true, "ethernet_port":true, "id":true, "interface_profile_id":true, "ipfixcollectorcontext_id":true, "ipfixfiltercontext_id":true, "ipv4_config":true, "ipv6_config":true, "lldp_enabled":true, "mac_address":true, "mtu":true, "multicast_config":true, "name":true, "nat_address":true, "nat_address_v6":true, "nat_pools":true, "nat_port":true, "nat_port_v6":true, "nat_zone_id":true, "network_context_id":true, "parent":true, "peer_bypasspair_wan_port_type":true, "poe_enabled":true, "power_usage_threshold":true, "pppoe_config":true, "scope":true, "secondary_ip_configs":true, "service_link_config":true, "site_wan_interface_ids":true, "static_arp_configs":true, "sub_interface":true, "switch_port_config":true, "tags":true, "type":true, "used_for":true, "vlan_config":true, "vrf_context_id":true} forceNew:map[string]bool(nil)
						"admin_up": dsschema.BoolAttribute{
							Description: "Admin Up.",
							Computed:    true,
						},
						"attached_lan_networks": dsschema.ListNestedAttribute{
							Description: "Attached Lan Networks: Valid .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"lan_network_id":true, "vlan_id":true} forceNew:map[string]bool(nil)
									"lan_network_id": dsschema.StringAttribute{
										Description: "Lan Network Id.",
										Computed:    true,
									},
									"vlan_id": dsschema.Int64Attribute{
										Description: "Vlan Id: Range(max = 4095L, error = INVALID_VLANID: VLAN ID should be between 0 and 4095., min = 0L) .",
										Computed:    true,
									},
								},
							},
						},
						"authentication_config": dsschema.SingleNestedAttribute{
							Description: "The AuthenticationConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"fallback_retry_count":true, "mode":true, "reauthentication_timeout":true} forceNew:map[string]bool(nil)
								"fallback_retry_count": dsschema.Int64Attribute{
									Description: "Fallback Retry Count.",
									Computed:    true,
								},
								"mode": dsschema.StringAttribute{
									Description: "Mode. String must be one of these: `\"none\"`, `\"dot1x\"`, `\"macauth\"`, `\"dot1x-to-macauth-fallback\"`.",
									Computed:    true,
								},
								"reauthentication_timeout": dsschema.Int64Attribute{
									Description: "Reauthentication Timeout.",
									Computed:    true,
								},
							},
						},
						"bound_interfaces": dsschema.ListAttribute{
							Description: "Bound Interfaces.",
							Computed:    true,
							ElementType: types.StringType,
						},
						"bypass_pair": dsschema.SingleNestedAttribute{
							Description: "The BypassPair param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"lan":true, "lan_state_propagation":true, "use_relay":true, "wan":true} forceNew:map[string]bool(nil)
								"lan": dsschema.StringAttribute{
									Description: "Lan.",
									Computed:    true,
								},
								"lan_state_propagation": dsschema.BoolAttribute{
									Description: "Lan State Propagation.",
									Computed:    true,
								},
								"use_relay": dsschema.BoolAttribute{
									Description: "Use Relay.",
									Computed:    true,
								},
								"wan": dsschema.StringAttribute{
									Description: "Wan.",
									Computed:    true,
								},
							},
						},
						"cellular_config": dsschema.SingleNestedAttribute{
							Description: "The CellularConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"apn_config":true, "apnprofile_id":true, "auto_apn":true, "parent_module_id":true, "parent_sim_slot_number":true} forceNew:map[string]bool(nil)
								"apn_config": dsschema.SingleNestedAttribute{
									Description: "The ApnConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"apn":true, "authentication":true, "clear_password":true, "password":true, "password_encrypted":true, "user_name":true} forceNew:map[string]bool(nil)
										"apn": dsschema.StringAttribute{
											Description: "Apn: Size(max = 100, error = CELLULAR_INTERFACE_CONFIG_APN_CONFIG_PROFILE_NAME_INVALID: Invalid cellular interface config. APN name is invalid. APN name allowed max length is 100. Valid characters are alphanumeric, hyphen (-), and period (.). Must begin and end with an alphanumeric character., min = 0) .",
											Computed:    true,
										},
										"authentication": dsschema.StringAttribute{
											Description: "Authentication: ValidateEnum(enumClass = classOf[APNAuthentication], message = INVALID_APN_AUTHENTICATION, nullAllowed = false) . String must be one of these: `\"none\"`, `\"pap\"`, `\"chap\"`, `\"pap_or_chap\"`.",
											Computed:    true,
										},
										"clear_password": dsschema.BoolAttribute{
											Description: "Clear Password.",
											Computed:    true,
										},
										"password": dsschema.StringAttribute{
											Description: "Password.",
											Computed:    true,
										},
										"password_encrypted": dsschema.StringAttribute{
											Description: "Password Encrypted: JsonIgnore(value = true) .",
											Computed:    true,
										},
										"user_name": dsschema.StringAttribute{
											Description: "User Name: Size(max = 100, error = CELLULAR_INTERFACE_CONFIG_APN_CONFIG_USERNAME_INVALID: Invalid cellular interface config. APN username is invalid. APN username allowed max length is 100., min = 0) .",
											Computed:    true,
										},
									},
								},
								"apnprofile_id": dsschema.StringAttribute{
									Description: "Apnprofile Id.",
									Computed:    true,
								},
								"auto_apn": dsschema.BoolAttribute{
									Description: "Auto Apn.",
									Computed:    true,
								},
								"parent_module_id": dsschema.StringAttribute{
									Description: "Parent Module Id.",
									Computed:    true,
								},
								"parent_sim_slot_number": dsschema.Int64Attribute{
									Description: "Parent Sim Slot Number.",
									Computed:    true,
								},
							},
						},
						"description": dsschema.StringAttribute{
							Description: "Description: Size(max = 256, error = DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds limit, min = 0) .",
							Computed:    true,
						},
						"devicemgmt_policysetstack_id": dsschema.StringAttribute{
							Description: "Devicemgmt Policysetstack Id: Digits(fraction = 0, integer = 30, INVALID_DEVICEMGMT_POLICYSETSTACK_ID) .",
							Computed:    true,
						},
						"dhcp_relay": dsschema.SingleNestedAttribute{
							Description: "The DhcpRelay param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} forceNew:map[string]bool(nil)
								"enabled": dsschema.BoolAttribute{
									Description: "Enabled.",
									Computed:    true,
								},
								"option_82": dsschema.SingleNestedAttribute{
									Description: "The Option82 param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} forceNew:map[string]bool(nil)
										"circuit_id": dsschema.StringAttribute{
											Description: "Circuit Id: Size(max = 255, error = DHCPRELAY_CIRCUIT_ID_EXCEEDS_LIMIT: Option 82 Circuid ID exceeds maximum length, min = 0) .",
											Computed:    true,
										},
										"enabled": dsschema.BoolAttribute{
											Description: "Enabled.",
											Computed:    true,
										},
										"reforwarding_policy": dsschema.StringAttribute{
											Description: "Reforwarding Policy: ValidateEnum(enumClass = classOf[DHCPRelayReforwardingPolicy], error = INVALID_DHCP_RELAY_REFWDING_POLICY: Option 82 invalid reforwarding policy, nullAllowed = false) . String must be one of these: `\"REPLACE\"`, `\"KEEP\"`, `\"APPEND\"`, `\"DROP\"`.",
											Computed:    true,
										},
										"remote_id": dsschema.StringAttribute{
											Description: "Remote Id: Size(max = 255, error = DHCPRELAY_REMOTE_ID_EXCEEDS_LIMIT: Option 82 Remote ID exceeds maximum length, min = 0) .",
											Computed:    true,
										},
									},
								},
								"server_ips": dsschema.ListAttribute{
									Description: "Server Ips: ListIPAddress(bcast = DENY, listMaxSize = 0, error = INTERFACE_CONFIG_INVALID_DHCP_RELAY_LIST: DHCP Servers IP specified in the list are invalid, required = true, type = IP) Size(max = 16, error = INTERFACE_CONFIG_DHCP_RELAY_LIST_EXCEEDS_LIMIT: DHCP Servers specified in the list exceeds maximum limit, min = 0) .",
									Computed:    true,
									ElementType: types.StringType,
								},
								"source_interface": dsschema.StringAttribute{
									Description: "Source Interface.",
									Computed:    true,
								},
							},
						},
						"directed_broadcast": dsschema.BoolAttribute{
							Description: "Directed Broadcast.",
							Computed:    true,
						},
						"etag": dsschema.Int64Attribute{
							Description: "Entity tag for the resource.",
							Computed:    true,
						},
						"ethernet_port": dsschema.SingleNestedAttribute{
							Description: "The EthernetPort param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"full_duplex":true, "port_id":true, "port_name":true, "speed":true} forceNew:map[string]bool(nil)
								"full_duplex": dsschema.BoolAttribute{
									Description: "Full Duplex.",
									Computed:    true,
								},
								"port_id": dsschema.SingleNestedAttribute{
									Description: "The PortId param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"connector":true, "device":true, "disabled":true, "disabled_reason":true, "element_id":true, "id":true, "inactive":true, "inactive_reason":true, "max_mtu":true, "max_speed":true, "name":true, "original_mac_address":true, "region":true, "site_id":true} forceNew:map[string]bool(nil)
										"connector": dsschema.StringAttribute{
											Description: "Connector Type.",
											Computed:    true,
										},
										"device": dsschema.StringAttribute{
											Description: "Device Name.",
											Computed:    true,
										},
										"disabled": dsschema.BoolAttribute{
											Description: "Disabled.",
											Computed:    true,
										},
										"disabled_reason": dsschema.StringAttribute{
											Description: "Disabled Reason: Size(max = 5000, DISABLED_REASON_INVALID_0001, min = 0) .",
											Computed:    true,
										},
										"element_id": dsschema.StringAttribute{
											Description: "Element Id.",
											Computed:    true,
										},
										"id": dsschema.StringAttribute{
											Description: "The Id param.",
											Computed:    true,
										},
										"inactive": dsschema.BoolAttribute{
											Description: "Inactive.",
											Computed:    true,
										},
										"inactive_reason": dsschema.StringAttribute{
											Description: "Inactive Reason: Size(max = 5000, INACTIVE_REASON_INVALID_0001, min = 0) .",
											Computed:    true,
										},
										"max_mtu": dsschema.Int64Attribute{
											Description: "Max Mtu.",
											Computed:    true,
										},
										"max_speed": dsschema.Int64Attribute{
											Description: "Max Speed.",
											Computed:    true,
										},
										"name": dsschema.StringAttribute{
											Description: "Name.",
											Computed:    true,
										},
										"original_mac_address": dsschema.StringAttribute{
											Description: "Orig Mac Addr.",
											Computed:    true,
										},
										"region": dsschema.StringAttribute{
											Description: "Region.",
											Computed:    true,
										},
										"site_id": dsschema.StringAttribute{
											Description: "Site Id: Digits(fraction = 0, integer = 50, SITEID_INVALID) NotNull .",
											Computed:    true,
										},
									},
								},
								"port_name": dsschema.StringAttribute{
									Description: "Port Name.",
									Computed:    true,
								},
								"speed": dsschema.Int64Attribute{
									Description: "Speed.",
									Computed:    true,
								},
							},
						},
						"id": dsschema.StringAttribute{
							Description: "Id.",
							Computed:    true,
						},
						"interface_profile_id": dsschema.StringAttribute{
							Description: "Interface Profile Id.",
							Computed:    true,
						},
						"ipfixcollectorcontext_id": dsschema.StringAttribute{
							Description: "Ipfixcollectorcontext Id.",
							Computed:    true,
						},
						"ipfixfiltercontext_id": dsschema.StringAttribute{
							Description: "Ipfixfiltercontext Id.",
							Computed:    true,
						},
						"ipv4_config": dsschema.SingleNestedAttribute{
							Description: "The Ipv4Config param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"dhcp_config":true, "dns_v4_config":true, "pppoe_config":true, "routes":true, "static_config":true, "type":true} forceNew:map[string]bool(nil)
								"dhcp_config": dsschema.SingleNestedAttribute{
									Description: "The DhcpConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"client_id":true, "hostname":true} forceNew:map[string]bool(nil)
										"client_id": dsschema.StringAttribute{
											Description: "Client Id.",
											Computed:    true,
										},
										"hostname": dsschema.StringAttribute{
											Description: "Hostname.",
											Computed:    true,
										},
									},
								},
								"dns_v4_config": dsschema.SingleNestedAttribute{
									Description: "The DnsV4Config param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"name_servers":true, "search":true} forceNew:map[string]bool(nil)
										"name_servers": dsschema.ListAttribute{
											Description: "Name Servers.",
											Computed:    true,
											ElementType: types.StringType,
										},
										"search": dsschema.ListAttribute{
											Description: "Search.",
											Computed:    true,
											ElementType: types.StringType,
										},
									},
								},
								"pppoe_config": dsschema.SingleNestedAttribute{
									Description: "The PppoeConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"chap_passwd":true, "chap_user":true, "set_route":true} forceNew:map[string]bool(nil)
										"chap_passwd": dsschema.StringAttribute{
											Description: "Chap Passwd.",
											Computed:    true,
										},
										"chap_user": dsschema.StringAttribute{
											Description: "Chap User.",
											Computed:    true,
										},
										"set_route": dsschema.BoolAttribute{
											Description: "Set Route.",
											Computed:    true,
										},
									},
								},
								"routes": dsschema.ListNestedAttribute{
									Description: "Routes: Valid .",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"destination":true, "via":true} forceNew:map[string]bool(nil)
											"destination": dsschema.StringAttribute{
												Description: "Destination.",
												Computed:    true,
											},
											"via": dsschema.StringAttribute{
												Description: "Via.",
												Computed:    true,
											},
										},
									},
								},
								"static_config": dsschema.SingleNestedAttribute{
									Description: "The StaticConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"address":true} forceNew:map[string]bool(nil)
										"address": dsschema.StringAttribute{
											Description: "Address.",
											Computed:    true,
										},
									},
								},
								"type": dsschema.StringAttribute{
									Description: "Type: Size(max = 12, error = INTERFACE_CONFIG_INVALID_IP_TYPE: IP Type is not valid., min = 0) .",
									Computed:    true,
								},
							},
						},
						"ipv6_config": dsschema.SingleNestedAttribute{
							Description: "The Ipv6Config param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"dhcp_config":true, "dns_v6_config":true, "routes":true, "static_config":true, "type":true} forceNew:map[string]bool(nil)
								"dhcp_config": dsschema.SingleNestedAttribute{
									Description: "The DhcpConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"client_id":true, "hostname":true} forceNew:map[string]bool(nil)
										"client_id": dsschema.StringAttribute{
											Description: "Client Id.",
											Computed:    true,
										},
										"hostname": dsschema.StringAttribute{
											Description: "Hostname.",
											Computed:    true,
										},
									},
								},
								"dns_v6_config": dsschema.SingleNestedAttribute{
									Description: "The DnsV6Config param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"name_servers":true, "search":true} forceNew:map[string]bool(nil)
										"name_servers": dsschema.ListAttribute{
											Description: "Name Servers.",
											Computed:    true,
											ElementType: types.StringType,
										},
										"search": dsschema.ListAttribute{
											Description: "Search.",
											Computed:    true,
											ElementType: types.StringType,
										},
									},
								},
								"routes": dsschema.ListNestedAttribute{
									Description: "Routes.",
									Computed:    true,
									NestedObject: dsschema.NestedAttributeObject{
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"destination":true, "via":true} forceNew:map[string]bool(nil)
											"destination": dsschema.StringAttribute{
												Description: "Destination.",
												Computed:    true,
											},
											"via": dsschema.StringAttribute{
												Description: "Via.",
												Computed:    true,
											},
										},
									},
								},
								"static_config": dsschema.SingleNestedAttribute{
									Description: "The StaticConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"address":true, "enable_prefix_distribution":true} forceNew:map[string]bool(nil)
										"address": dsschema.StringAttribute{
											Description: "Address.",
											Computed:    true,
										},
										"enable_prefix_distribution": dsschema.BoolAttribute{
											Description: "Enable Prefix Distribution.",
											Computed:    true,
										},
									},
								},
								"type": dsschema.StringAttribute{
									Description: "Type.",
									Computed:    true,
								},
							},
						},
						"lldp_enabled": dsschema.BoolAttribute{
							Description: "Lldp Enabled.",
							Computed:    true,
						},
						"mac_address": dsschema.StringAttribute{
							Description: "Mac Address: Pattern(error = INTERFACE_CONFIG_INVALID_MAC: Invalid mac address syntax., regexp = ([0-9a-f]{2}[:]){5}([0-9a-f]{2})) .",
							Computed:    true,
						},
						"mtu": dsschema.Int64Attribute{
							Description: "Mtu: Range(max = 9216L, error = INTERFACE_CONFIG_INVALID_MTU: MTU is not in the valid range., min = 0L) .",
							Computed:    true,
						},
						"multicast_config": dsschema.SingleNestedAttribute{
							Description: "The MulticastConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"igmp_version":true, "multicast_enabled":true} forceNew:map[string]bool(nil)
								"igmp_version": dsschema.StringAttribute{
									Description: "Igmp Version. String must be one of these: `\"IGMPV2\"`, `\"IGMPV3\"`.",
									Computed:    true,
								},
								"multicast_enabled": dsschema.BoolAttribute{
									Description: "Multicast Enabled.",
									Computed:    true,
								},
							},
						},
						"name": dsschema.StringAttribute{
							Description: "Name: Size(max = 128, error = NAME_EXCEEDS_LIMIT: Name of the resource exceeds limit., min = 0) .",
							Computed:    true,
						},
						"nat_address": dsschema.StringAttribute{
							Description: "Nat Address: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = INVALID_NAT_IP: NAT IP address is invalid., type = IP) .",
							Computed:    true,
						},
						"nat_address_v6": dsschema.StringAttribute{
							Description: "Nat Address V6: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = INVALID_IPV6_NAT: IPv6 NAT address is invalid., type = IPV6) .",
							Computed:    true,
						},
						"nat_pools": dsschema.ListNestedAttribute{
							Description: "Nat Pools: Valid .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"ipv4_ranges":true, "nat_pool_id":true} forceNew:map[string]bool(nil)
									"ipv4_ranges": dsschema.ListNestedAttribute{
										Description: "Ipv4 Ranges: Size(max = 4, error = INTERFACE_CONFIG_INVALID_NAT_POOL_IP_RANGE: Minimum 1 and maximum 4 nat pool IP ranges can be specified., min = 1) Valid .",
										Computed:    true,
										NestedObject: dsschema.NestedAttributeObject{
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"end":true, "start":true} forceNew:map[string]bool(nil)
												"end": dsschema.StringAttribute{
													Description: "End: NotNull(error = END_IP_MISSING: End ip is not specified in range.) IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = END_IP_INVALID_IN_RANGE: Invalid end ip specified in range., type = IP) .",
													Computed:    true,
												},
												"start": dsschema.StringAttribute{
													Description: "Start: NotNull(error = START_IP_MISSING: Start ip is not specified in range.) IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = START_IP_INVALID_IN_RANGE: Invalid start ip specified in range., type = IP) .",
													Computed:    true,
												},
											},
										},
									},
									"nat_pool_id": dsschema.StringAttribute{
										Description: "Nat Pool Id: Digits(fraction = 0, integer = 30, INVALID_NAT_POLICYPOOL_ID) .",
										Computed:    true,
									},
								},
							},
						},
						"nat_port": dsschema.Int64Attribute{
							Description: "Nat Port: Range(max = 65535L, error = INTERFACE_CONFIG_INVALID_PORT: LAN,WAN,Internet bypass ports cannot be part of logical interface groups., min = 0L) .",
							Computed:    true,
						},
						"nat_port_v6": dsschema.Int64Attribute{
							Description: "Nat Port V6: Range(max = 65535L, error = INTERFACE_CONFIG_INVALID_PORT: LAN,WAN,Internet bypass ports cannot be part of logical interface groups., min = 0L) .",
							Computed:    true,
						},
						"nat_zone_id": dsschema.StringAttribute{
							Description: "Nat Zone Id: Digits(fraction = 0, integer = 30, INVALID_NAT_POLICY_ZONE) .",
							Computed:    true,
						},
						"network_context_id": dsschema.StringAttribute{
							Description: "Network Context Id.",
							Computed:    true,
						},
						"parent": dsschema.StringAttribute{
							Description: "Parent.",
							Computed:    true,
						},
						"peer_bypasspair_wan_port_type": dsschema.StringAttribute{
							Description: "Peer Bypasspair Wan Port Type: ValidateEnum(enumClass = classOf[PortExtensionType], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"none\"`, `\"cellular\"`.",
							Computed:    true,
						},
						"poe_enabled": dsschema.BoolAttribute{
							Description: "Poe Enabled.",
							Computed:    true,
						},
						"power_usage_threshold": dsschema.Int64Attribute{
							Description: "Power Usage Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_POE_POWER_USAGE_THRESHOLD: Invalid Interface configuration. Invalid PoE alarm threshold value {}. Valid values are in the range 50-100., min = 0) .",
							Computed:    true,
						},
						"pppoe_config": dsschema.SingleNestedAttribute{
							Description: "The PppoeConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"host_uniq":true, "ip_address_type":true, "password":true, "reconnection_delay":true, "service_name":true, "username":true} forceNew:map[string]bool(nil)
								"host_uniq": dsschema.StringAttribute{
									Description: "Host Uniq.",
									Computed:    true,
								},
								"ip_address_type": dsschema.StringAttribute{
									Description: "Ip Address Type.",
									Computed:    true,
								},
								"password": dsschema.StringAttribute{
									Description: "Password.",
									Computed:    true,
								},
								"reconnection_delay": dsschema.Int64Attribute{
									Description: "Reconnection Delay.",
									Computed:    true,
								},
								"service_name": dsschema.StringAttribute{
									Description: "Service Name.",
									Computed:    true,
								},
								"username": dsschema.StringAttribute{
									Description: "Username.",
									Computed:    true,
								},
							},
						},
						"scope": dsschema.StringAttribute{
							Description: "Scope: ValidateEnum(enumClass = classOf[NetworkScope], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"GLOBAL\"`, `\"LOCAL\"`.",
							Computed:    true,
						},
						"secondary_ip_configs": dsschema.ListNestedAttribute{
							Description: "Secondary Ip Configs.",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"ipv4_address":true, "scope":true} forceNew:map[string]bool(nil)
									"ipv4_address": dsschema.StringAttribute{
										Description: "Ipv4 Address.",
										Computed:    true,
									},
									"scope": dsschema.StringAttribute{
										Description: "Scope.",
										Computed:    true,
									},
								},
							},
						},
						"service_link_config": dsschema.SingleNestedAttribute{
							Description: "The ServiceLinkConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"gre_config":true, "ipsec_config":true, "last_parent":true, "parent":true, "passive_mode":true, "peer":true, "service_endpoint_id":true, "type":true} forceNew:map[string]bool(nil)
								"gre_config": dsschema.SingleNestedAttribute{
									Description: "The GreConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"csum":true, "keepalive_enable":true, "keepalive_fail_count":true, "keepalive_interval":true} forceNew:map[string]bool(nil)
										"csum": dsschema.BoolAttribute{
											Description: "Csum.",
											Computed:    true,
										},
										"keepalive_enable": dsschema.BoolAttribute{
											Description: "Keepalive Enable.",
											Computed:    true,
										},
										"keepalive_fail_count": dsschema.Int64Attribute{
											Description: "Keepalive Fail Count: Range(max = 10L, error = INTERFACE_CONFIG_SERVICE_LINK_INVALID_GRE_KEEPALIVE_FAIL_COUNT: Keep alive fail count should be in range 1 to 10, min = 1L) .",
											Computed:    true,
										},
										"keepalive_interval": dsschema.Int64Attribute{
											Description: "Keepalive Interval: Range(max = 30L, error = INTERFACE_CONFIG_SERVICE_LINK_INVALID_GRE_KEEPALIVE_INTERVAL: Keep alive interval should be in range 3 to 30, min = 3L) .",
											Computed:    true,
										},
									},
								},
								"ipsec_config": dsschema.SingleNestedAttribute{
									Description: "The IpsecConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"authentication":true, "ipsec_profile_id":true} forceNew:map[string]bool(nil)
										"authentication": dsschema.SingleNestedAttribute{
											Description: "The Authentication param.",
											Computed:    true,
											Attributes: map[string]dsschema.Attribute{
												// inputs:map[string]bool{} outputs:map[string]bool{"certificate":true, "certificate_profile_id":true, "comment":true, "ikev1_params":true, "local_ca_certificate":true, "local_id":true, "local_id_custom":true, "local_pa_certificate_id":true, "pa_master_key_id":true, "passphrase":true, "passphrase_encrypted":true, "peer_id_check":true, "permit_peer_id_mismatch":true, "private_key":true, "private_key_encrypted":true, "remote_ca_certificate":true, "remote_id":true, "secret":true, "secret_encrypted":true, "secret_hash":true, "strict_validation_peer_extended_key_use":true, "type":true, "x509Objects":true} forceNew:map[string]bool(nil)
												"certificate": dsschema.StringAttribute{
													Description: "Certificate.",
													Computed:    true,
												},
												"certificate_profile_id": dsschema.StringAttribute{
													Description: "Certificate Profile Id.",
													Computed:    true,
												},
												"comment": dsschema.StringAttribute{
													Description: "Comment.",
													Computed:    true,
												},
												"ikev1_params": dsschema.SingleNestedAttribute{
													Description: "The Ikev1Params param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"xauth_id":true, "xauth_secret":true, "xauth_secret_encrypted":true, "xauth_secret_hash":true, "xauth_type":true} forceNew:map[string]bool(nil)
														"xauth_id": dsschema.StringAttribute{
															Description: "Xauth Id.",
															Computed:    true,
														},
														"xauth_secret": dsschema.StringAttribute{
															Description: "Xauth Secret: Length(max = 128, error = IPSECCONFIG_INVALID_XAUTH_SECRET_LEN: Invalid extended authentication secret length.Should be between 4-128., min = 4) .",
															Computed:    true,
														},
														"xauth_secret_encrypted": dsschema.StringAttribute{
															Description: "Xauth Secret Encrypted: JsonIgnore(value = true) .",
															Computed:    true,
														},
														"xauth_secret_hash": dsschema.StringAttribute{
															Description: "Xauth Secret Hash: JsonIgnore(value = true) .",
															Computed:    true,
														},
														"xauth_type": dsschema.StringAttribute{
															Description: "Xauth Type: ValidateEnum(enumClass = classOf[IKEXAuthType], error = IPSECCONFIG_INVALID_XAUTH_TYPE: Invalid extended authentication type specified.Valid type are secret or none., nullAllowed = false) . String must be one of these: `\"NONE\"`, `\"SECRET\"`.",
															Computed:    true,
														},
													},
												},
												"local_ca_certificate": dsschema.StringAttribute{
													Description: "Local Ca Certificate.",
													Computed:    true,
												},
												"local_id": dsschema.StringAttribute{
													Description: "Local Id: ValidateEnum(enumClass = classOf[IPSECLocalIdType], error = IPSECCONFIG_INVALID_LOCAL_ID_TYPE: Invalid local id type.Should be either hostname, dn, local_ip or custom, nullAllowed = false) . String must be one of these: `\"LOCAL_IP\"`, `\"DN\"`, `\"HOSTNAME\"`, `\"CUSTOM\"`, `\"NONE\"`.",
													Computed:    true,
												},
												"local_id_custom": dsschema.StringAttribute{
													Description: "Local Id Custom: Length(max = 255, error = IPSECCONFIG_INVALID_LOCAL_ID_LEN: Invalid local id len.Should be between 2-255., min = 2) .",
													Computed:    true,
												},
												"local_pa_certificate_id": dsschema.StringAttribute{
													Description: "Local Pa Certificate Id.",
													Computed:    true,
												},
												"pa_master_key_id": dsschema.StringAttribute{
													Description: "Pa Master Key Id.",
													Computed:    true,
												},
												"passphrase": dsschema.StringAttribute{
													Description: "Passphrase.",
													Computed:    true,
												},
												"passphrase_encrypted": dsschema.StringAttribute{
													Description: "Passphrase Encrypted: JsonIgnore(value = true) .",
													Computed:    true,
												},
												"peer_id_check": dsschema.StringAttribute{
													Description: "Peer Id Check. String must be one of these: `\"EXACT\"`, `\"WILDCARD\"`.",
													Computed:    true,
												},
												"permit_peer_id_mismatch": dsschema.BoolAttribute{
													Description: "Permit Peer Id Mismatch.",
													Computed:    true,
												},
												"private_key": dsschema.StringAttribute{
													Description: "Private Key.",
													Computed:    true,
												},
												"private_key_encrypted": dsschema.StringAttribute{
													Description: "Private Key Encrypted: JsonIgnore(value = true) .",
													Computed:    true,
												},
												"remote_ca_certificate": dsschema.StringAttribute{
													Description: "Remote Ca Certificate.",
													Computed:    true,
												},
												"remote_id": dsschema.StringAttribute{
													Description: "Remote Id: Length(max = 255, error = IPSECCONFIG_INVALID_REMOTE_ID_LEN: Invalid remote id len.Should be between 2-255., min = 2) .",
													Computed:    true,
												},
												"secret": dsschema.StringAttribute{
													Description: "Secret.",
													Computed:    true,
												},
												"secret_encrypted": dsschema.StringAttribute{
													Description: "Secret Encrypted: JsonIgnore(value = true) .",
													Computed:    true,
												},
												"secret_hash": dsschema.StringAttribute{
													Description: "Secret Hash: JsonIgnore(value = true) .",
													Computed:    true,
												},
												"strict_validation_peer_extended_key_use": dsschema.BoolAttribute{
													Description: "Strict Validation Peer Extended Key Use.",
													Computed:    true,
												},
												"type": dsschema.StringAttribute{
													Description: "Type: ValidateEnum(enumClass = classOf[IPSECAuthenticationType], error = IPSECCONFIG_INVALID_AUTHENTICATION_TYPE: Invalid authentication type specified.Valid type are x509, psk or none., nullAllowed = false) . String must be one of these: `\"NONE\"`, `\"PSK\"`, `\"X509\"`.",
													Computed:    true,
												},
												"x509_objects": dsschema.SingleNestedAttribute{
													Description: "The X509Objects param.",
													Computed:    true,
													Attributes: map[string]dsschema.Attribute{
														// inputs:map[string]bool{} outputs:map[string]bool{"certHolder":true, "certificate":true, "is_local_ca_cert_set":true, "is_remote_ca_cert_set":true, "keyPair":true, "local_ca_certificate":true, "local_ca_certs_set":true, "passphrase":true, "private_key":true, "remote_ca_certificate":true, "remote_ca_certs_set":true} forceNew:map[string]bool(nil)
														"cert_holder": dsschema.BoolAttribute{
															Description: "The CertHolder param. Default: `false`.",
															Computed:    true,
														},
														"certificate": dsschema.StringAttribute{
															Description: "Certificate.",
															Computed:    true,
														},
														"is_local_ca_cert_set": dsschema.BoolAttribute{
															Description: "Is Local Ca Cert Set.",
															Computed:    true,
														},
														"is_remote_ca_cert_set": dsschema.BoolAttribute{
															Description: "Is Remote Ca Cert Set.",
															Computed:    true,
														},
														"key_pair": dsschema.BoolAttribute{
															Description: "The KeyPair param. Default: `false`.",
															Computed:    true,
														},
														"local_ca_certificate": dsschema.StringAttribute{
															Description: "Local Ca Certificate.",
															Computed:    true,
														},
														"local_ca_certs_set": dsschema.ListAttribute{
															Description: "Local Ca Certs Set.",
															Computed:    true,
															ElementType: types.BoolType,
														},
														"passphrase": dsschema.StringAttribute{
															Description: "Passphrase.",
															Computed:    true,
														},
														"private_key": dsschema.StringAttribute{
															Description: "Private Key.",
															Computed:    true,
														},
														"remote_ca_certificate": dsschema.StringAttribute{
															Description: "Remote Ca Certificate.",
															Computed:    true,
														},
														"remote_ca_certs_set": dsschema.ListAttribute{
															Description: "Remote Ca Certs Set.",
															Computed:    true,
															ElementType: types.BoolType,
														},
													},
												},
											},
										},
										"ipsec_profile_id": dsschema.StringAttribute{
											Description: "Ipsec Profile Id: Required(IPSEC_PROFILE_ID_MISSING) .",
											Computed:    true,
										},
									},
								},
								"last_parent": dsschema.StringAttribute{
									Description: "Last Parent: JsonIgnore(value = true) .",
									Computed:    true,
								},
								"parent": dsschema.StringAttribute{
									Description: "Parent: JsonIgnore(value = true) .",
									Computed:    true,
								},
								"passive_mode": dsschema.SingleNestedAttribute{
									Description: "The PassiveMode param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"enable":true, "peer_ip_dynamic":true} forceNew:map[string]bool(nil)
										"enable": dsschema.BoolAttribute{
											Description: "Enable.",
											Computed:    true,
										},
										"peer_ip_dynamic": dsschema.BoolAttribute{
											Description: "Peer Ip Dynamic.",
											Computed:    true,
										},
									},
								},
								"peer": dsschema.SingleNestedAttribute{
									Description: "The Peer param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"hostname":true, "ip_addresses":true} forceNew:map[string]bool(nil)
										"hostname": dsschema.StringAttribute{
											Description: "Hostname: Size(max = 256, INVALID_PEER_HOSTNAME, min = 0) .",
											Computed:    true,
										},
										"ip_addresses": dsschema.ListAttribute{
											Description: "Ip Addresses.",
											Computed:    true,
											ElementType: types.StringType,
										},
									},
								},
								"service_endpoint_id": dsschema.StringAttribute{
									Description: "Service Endpoint Id.",
									Computed:    true,
								},
								"type": dsschema.StringAttribute{
									Description: "Type: ValidateEnum(enumClass = classOf[ServiceLinkType], INVALID_SERVICE_LINK_TYPE, nullAllowed = false) . String must be one of these: `\"IPSEC\"`, `\"GRE\"`, `\"GENEVE\"`.",
									Computed:    true,
								},
							},
						},
						"site_wan_interface_ids": dsschema.ListAttribute{
							Description: "Site Wan Interface Ids.",
							Computed:    true,
							ElementType: types.StringType,
						},
						"static_arp_configs": dsschema.ListNestedAttribute{
							Description: "Static Arp Configs: Size(max = 32, error = INTERFACE_CONFIG_STATIC_ARP_EXCEEDS_LIMIT: Invalid interface configuration. Static ARP entries exceed the supported limit of 16, min = 0) .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"ipv4_address":true, "mac_address":true} forceNew:map[string]bool(nil)
									"ipv4_address": dsschema.StringAttribute{
										Description: "Ipv4 Address: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, INVALID_IP, type = IP) .",
										Computed:    true,
									},
									"mac_address": dsschema.StringAttribute{
										Description: "Mac Address: MACAddress(error = INTERFACE_CONFIG_INVALID_MAC: Invalid mac address syntax.) .",
										Computed:    true,
									},
								},
							},
						},
						"sub_interface": dsschema.SingleNestedAttribute{
							Description: "The SubInterface param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"vlan_id":true} forceNew:map[string]bool(nil)
								"vlan_id": dsschema.Int64Attribute{
									Description: "Vlan Id.",
									Computed:    true,
								},
							},
						},
						"switch_port_config": dsschema.SingleNestedAttribute{
							Description: "The SwitchPortConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"access_vlan_id":true, "bpdu_guard_enabled":true, "forward_fast_enabled":true, "native_vlan_id":true, "root_guard_enabled":true, "storm_control_config":true, "stp_port_cost":true, "stp_port_enabled":true, "stp_port_priority":true, "trunk_vlans":true, "vlan_mode":true, "voice_vlan_id":true} forceNew:map[string]bool(nil)
								"access_vlan_id": dsschema.Int64Attribute{
									Description: "Access Vlan Id.",
									Computed:    true,
								},
								"bpdu_guard_enabled": dsschema.BoolAttribute{
									Description: "Bpdu Guard Enabled.",
									Computed:    true,
								},
								"forward_fast_enabled": dsschema.BoolAttribute{
									Description: "Forward Fast Enabled.",
									Computed:    true,
								},
								"native_vlan_id": dsschema.Int64Attribute{
									Description: "Native Vlan Id.",
									Computed:    true,
								},
								"root_guard_enabled": dsschema.BoolAttribute{
									Description: "Root Guard Enabled.",
									Computed:    true,
								},
								"storm_control_config": dsschema.SingleNestedAttribute{
									Description: "The StormControlConfig param.",
									Computed:    true,
									Attributes: map[string]dsschema.Attribute{
										// inputs:map[string]bool{} outputs:map[string]bool{"broadcast_threshold":true, "multicast_threshold":true, "unicast_threshold":true} forceNew:map[string]bool(nil)
										"broadcast_threshold": dsschema.Int64Attribute{
											Description: "Broadcast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_BROADCAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control broadcast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
											Computed:    true,
										},
										"multicast_threshold": dsschema.Int64Attribute{
											Description: "Multicast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_MULTICAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control multicast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
											Computed:    true,
										},
										"unicast_threshold": dsschema.Int64Attribute{
											Description: "Unicast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_UNICAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control unicast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
											Computed:    true,
										},
									},
								},
								"stp_port_cost": dsschema.Int64Attribute{
									Description: "Stp Port Cost: Range(max = 65535L, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_STP_COST: Invalid interface configuration. Switch port interface config is invalid. Invalid STP cost. Valid values are 1-65535., min = 1L) .",
									Computed:    true,
								},
								"stp_port_enabled": dsschema.BoolAttribute{
									Description: "Stp Port Enabled.",
									Computed:    true,
								},
								"stp_port_priority": dsschema.Int64Attribute{
									Description: "Stp Port Priority: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_STP_PRIORITY: Invalid interface configuration. Switch port interface config is invalid. Invalid stp priority. Valid values are 0-240 and must be a multiple of 16., min = 0) .",
									Computed:    true,
								},
								"trunk_vlans": dsschema.ListAttribute{
									Description: "Trunk Vlans: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 0, listMaxSize = 32, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_TRUNK_VLANS: Invalid interface configuration. Switch port config is invalid.  VLAN mode is trunk. Max trunk VLANs allowed is 32 and no duplicates are allowed., noTrim = false, regex = , required = false) .",
									Computed:    true,
									ElementType: types.StringType,
								},
								"vlan_mode": dsschema.StringAttribute{
									Description: "Vlan Mode: ValidateEnum(enumClass = classOf[VlanMode], error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_VLAN_MODE: Invalid interface configuration. Switch port interface config is invalid. Invalid vlan mode. Valid values are access and trunk., nullAllowed = false) . String must be one of these: `\"access\"`, `\"trunk\"`.",
									Computed:    true,
								},
								"voice_vlan_id": dsschema.Int64Attribute{
									Description: "Voice Vlan Id.",
									Computed:    true,
								},
							},
						},
						"tags": dsschema.ListAttribute{
							Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = INVALID_TAG: Maximum 10 Unique tags of length 1024 each are allowed, noTrim = false, regex = [^,\\\\s]+, required = false) .",
							Computed:    true,
							ElementType: types.StringType,
						},
						"type": dsschema.StringAttribute{
							Description: "Type: ValidateEnum(enumClass = classOf[InterfaceType], error = INVALID_PORT_TYPE: Port type is not valid., nullAllowed = false) .",
							Computed:    true,
						},
						"used_for": dsschema.StringAttribute{
							Description: "Used For: ValidateEnum(enumClass = classOf[UsedFor], error = INTERFACE_CONFIG_INVALID_USEDFOR_VALUE: Invalid used for value specified.The allowed values are public,private_wan,lan,none, nullAllowed = false) .",
							Computed:    true,
						},
						"vlan_config": dsschema.SingleNestedAttribute{
							Description: "The VlanConfig param.",
							Computed:    true,
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"mstp_instance":true, "vlan_id":true, "voice_enabled":true} forceNew:map[string]bool(nil)
								"mstp_instance": dsschema.Int64Attribute{
									Description: "Mstp Instance.",
									Computed:    true,
								},
								"vlan_id": dsschema.Int64Attribute{
									Description: "Vlan Id.",
									Computed:    true,
								},
								"voice_enabled": dsschema.BoolAttribute{
									Description: "Voice Enabled.",
									Computed:    true,
								},
							},
						},
						"vrf_context_id": dsschema.StringAttribute{
							Description: "Vrf Context Id.",
							Computed:    true,
						},
					},
				},
			},
			"site_id": dsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"total_items": dsschema.Int64Attribute{
				Description: "The TotalItems param.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *interfaceListDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*sdwan.Client)
}

// Read performs Read for the struct.
func (d *interfaceListDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state interfaceListDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source listing", map[string]any{
		"data_source_name":            "prismasdwan_interface_list",
		"terraform_provider_function": "Read",
		"site_id":                     state.SiteId.ValueString(),
		"element_id":                  state.ElementId.ValueString(),
	})

	// Prepare to run the command.
	svc := aSvnUVk.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := aSvnUVk.ListInput{}

	input.SiteId = StringValue(state.SiteId)

	input.ElementId = StringValue(state.ElementId)

	// Perform the operation.
	ans, err := svc.List(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error getting listing", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	idBuilder.WriteString(input.ElementId)

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	if len(ans.Items) == 0 {
		state.Items = nil
	} else {
		state.Items = make([]interfaceListDsModel_quvWIWu_Config, 0, len(ans.Items))
		for _, var0 := range ans.Items {
			var1 := interfaceListDsModel_quvWIWu_Config{}

			var1.AdminUp = types.BoolPointerValue(var0.AdminUp)

			if len(var0.AttachedLanNetworks) == 0 {
				var1.AttachedLanNetworks = nil
			} else {
				var1.AttachedLanNetworks = make([]interfaceListDsModel_irQawLY_Config, 0, len(var0.AttachedLanNetworks))
				for _, var2 := range var0.AttachedLanNetworks {
					var3 := interfaceListDsModel_irQawLY_Config{}

					var3.LanNetworkId = types.StringPointerValue(var2.LanNetworkId)

					var3.VlanId = types.Int64PointerValue(var2.VlanId)
					var1.AttachedLanNetworks = append(var1.AttachedLanNetworks, var3)
				}
			}

			if var0.AuthenticationConfig == nil {
				var1.AuthenticationConfig = nil
			} else {
				var1.AuthenticationConfig = &interfaceListDsModel_mIAatvm_Config{}

				var1.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(var0.AuthenticationConfig.FallbackRetryCount)

				var1.AuthenticationConfig.Mode = types.StringPointerValue(var0.AuthenticationConfig.Mode)

				var1.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(var0.AuthenticationConfig.ReauthenticationTimeout)
			}

			var4, var5 := types.ListValueFrom(ctx, types.StringType, var0.BoundInterfaces)
			var1.BoundInterfaces = var4
			resp.Diagnostics.Append(var5.Errors()...)

			if var0.BypassPair == nil {
				var1.BypassPair = nil
			} else {
				var1.BypassPair = &interfaceListDsModel_zGfKFAQ_Config{}

				var1.BypassPair.Lan = types.StringPointerValue(var0.BypassPair.Lan)

				var1.BypassPair.LanStatePropagation = types.BoolPointerValue(var0.BypassPair.LanStatePropagation)

				var1.BypassPair.UseRelay = types.BoolPointerValue(var0.BypassPair.UseRelay)

				var1.BypassPair.Wan = types.StringPointerValue(var0.BypassPair.Wan)
			}

			if var0.CellularConfig == nil {
				var1.CellularConfig = nil
			} else {
				var1.CellularConfig = &interfaceListDsModel_eumQbRC_Config{}

				if var0.CellularConfig.ApnConfig == nil {
					var1.CellularConfig.ApnConfig = nil
				} else {
					var1.CellularConfig.ApnConfig = &interfaceListDsModel_aeWshcf_Config{}

					var1.CellularConfig.ApnConfig.Apn = types.StringPointerValue(var0.CellularConfig.ApnConfig.Apn)

					var1.CellularConfig.ApnConfig.Authentication = types.StringValue(var0.CellularConfig.ApnConfig.Authentication)

					var1.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(var0.CellularConfig.ApnConfig.ClearPassword)

					var1.CellularConfig.ApnConfig.Password = types.StringPointerValue(var0.CellularConfig.ApnConfig.Password)

					var1.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(var0.CellularConfig.ApnConfig.PasswordEncrypted)

					var1.CellularConfig.ApnConfig.UserName = types.StringPointerValue(var0.CellularConfig.ApnConfig.UserName)
				}

				var1.CellularConfig.ApnprofileId = types.StringPointerValue(var0.CellularConfig.ApnprofileId)

				var1.CellularConfig.AutoApn = types.BoolPointerValue(var0.CellularConfig.AutoApn)

				var1.CellularConfig.ParentModuleId = types.StringPointerValue(var0.CellularConfig.ParentModuleId)

				var1.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(var0.CellularConfig.ParentSimSlotNumber)
			}

			var1.Description = types.StringPointerValue(var0.Description)

			var1.DevicemgmtPolicysetstackId = types.StringPointerValue(var0.DevicemgmtPolicysetstackId)

			if var0.DhcpRelay == nil {
				var1.DhcpRelay = nil
			} else {
				var1.DhcpRelay = &interfaceListDsModel_mCcgFKg_Config{}

				var1.DhcpRelay.Enabled = types.BoolPointerValue(var0.DhcpRelay.Enabled)

				if var0.DhcpRelay.Option82 == nil {
					var1.DhcpRelay.Option82 = nil
				} else {
					var1.DhcpRelay.Option82 = &interfaceListDsModel_tOChZgD_Config{}

					var1.DhcpRelay.Option82.CircuitId = types.StringPointerValue(var0.DhcpRelay.Option82.CircuitId)

					var1.DhcpRelay.Option82.Enabled = types.BoolPointerValue(var0.DhcpRelay.Option82.Enabled)

					var1.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(var0.DhcpRelay.Option82.ReforwardingPolicy)

					var1.DhcpRelay.Option82.RemoteId = types.StringPointerValue(var0.DhcpRelay.Option82.RemoteId)
				}

				var6, var7 := types.ListValueFrom(ctx, types.StringType, var0.DhcpRelay.ServerIps)
				var1.DhcpRelay.ServerIps = var6
				resp.Diagnostics.Append(var7.Errors()...)

				var1.DhcpRelay.SourceInterface = types.StringPointerValue(var0.DhcpRelay.SourceInterface)
			}

			var1.DirectedBroadcast = types.BoolPointerValue(var0.DirectedBroadcast)

			var1.Etag = types.Int64PointerValue(var0.Etag)

			if var0.EthernetPort == nil {
				var1.EthernetPort = nil
			} else {
				var1.EthernetPort = &interfaceListDsModel_ehJLagQ_Config{}

				var1.EthernetPort.FullDuplex = types.BoolPointerValue(var0.EthernetPort.FullDuplex)

				if var0.EthernetPort.PortId == nil {
					var1.EthernetPort.PortId = nil
				} else {
					var1.EthernetPort.PortId = &interfaceListDsModel_ujXZojh_Config{}

					var1.EthernetPort.PortId.Connector = types.StringPointerValue(var0.EthernetPort.PortId.Connector)

					var1.EthernetPort.PortId.Device = types.StringPointerValue(var0.EthernetPort.PortId.Device)

					var1.EthernetPort.PortId.Disabled = types.BoolPointerValue(var0.EthernetPort.PortId.Disabled)

					var1.EthernetPort.PortId.DisabledReason = types.StringPointerValue(var0.EthernetPort.PortId.DisabledReason)

					var1.EthernetPort.PortId.ElementId = types.StringPointerValue(var0.EthernetPort.PortId.ElementId)

					var1.EthernetPort.PortId.Id = types.StringPointerValue(var0.EthernetPort.PortId.Id)

					var1.EthernetPort.PortId.Inactive = types.BoolPointerValue(var0.EthernetPort.PortId.Inactive)

					var1.EthernetPort.PortId.InactiveReason = types.StringPointerValue(var0.EthernetPort.PortId.InactiveReason)

					var1.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(var0.EthernetPort.PortId.MaxMtu)

					var1.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(var0.EthernetPort.PortId.MaxSpeed)

					var1.EthernetPort.PortId.Name = types.StringPointerValue(var0.EthernetPort.PortId.Name)

					var1.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(var0.EthernetPort.PortId.OriginalMacAddress)

					var1.EthernetPort.PortId.Region = types.StringPointerValue(var0.EthernetPort.PortId.Region)

					var1.EthernetPort.PortId.SiteId = types.StringValue(var0.EthernetPort.PortId.SiteId)
				}

				var1.EthernetPort.PortName = types.StringPointerValue(var0.EthernetPort.PortName)

				var1.EthernetPort.Speed = types.Int64PointerValue(var0.EthernetPort.Speed)
			}

			var1.Id = types.StringPointerValue(var0.Id)

			var1.InterfaceProfileId = types.StringPointerValue(var0.InterfaceProfileId)

			var1.IpfixcollectorcontextId = types.StringPointerValue(var0.IpfixcollectorcontextId)

			var1.IpfixfiltercontextId = types.StringPointerValue(var0.IpfixfiltercontextId)

			if var0.Ipv4Config == nil {
				var1.Ipv4Config = nil
			} else {
				var1.Ipv4Config = &interfaceListDsModel_wsoFfyL_Config{}

				if var0.Ipv4Config.DhcpConfig == nil {
					var1.Ipv4Config.DhcpConfig = nil
				} else {
					var1.Ipv4Config.DhcpConfig = &interfaceListDsModel_rKcwmLF_Config{}

					var1.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(var0.Ipv4Config.DhcpConfig.ClientId)

					var1.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(var0.Ipv4Config.DhcpConfig.Hostname)
				}

				if var0.Ipv4Config.DnsV4Config == nil {
					var1.Ipv4Config.DnsV4Config = nil
				} else {
					var1.Ipv4Config.DnsV4Config = &interfaceListDsModel_mTuoPRe_Config{}

					var8, var9 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.DnsV4Config.NameServers)
					var1.Ipv4Config.DnsV4Config.NameServers = var8
					resp.Diagnostics.Append(var9.Errors()...)

					var10, var11 := types.ListValueFrom(ctx, types.StringType, var0.Ipv4Config.DnsV4Config.Search)
					var1.Ipv4Config.DnsV4Config.Search = var10
					resp.Diagnostics.Append(var11.Errors()...)
				}

				if var0.Ipv4Config.PppoeConfig == nil {
					var1.Ipv4Config.PppoeConfig = nil
				} else {
					var1.Ipv4Config.PppoeConfig = &interfaceListDsModel_cvAyZuw_Config{}

					var1.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(var0.Ipv4Config.PppoeConfig.ChapPasswd)

					var1.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(var0.Ipv4Config.PppoeConfig.ChapUser)

					var1.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(var0.Ipv4Config.PppoeConfig.SetRoute)
				}

				if len(var0.Ipv4Config.Routes) == 0 {
					var1.Ipv4Config.Routes = nil
				} else {
					var1.Ipv4Config.Routes = make([]interfaceListDsModel_bBEnHsN_Config, 0, len(var0.Ipv4Config.Routes))
					for _, var12 := range var0.Ipv4Config.Routes {
						var13 := interfaceListDsModel_bBEnHsN_Config{}

						var13.Destination = types.StringPointerValue(var12.Destination)

						var13.Via = types.StringPointerValue(var12.Via)
						var1.Ipv4Config.Routes = append(var1.Ipv4Config.Routes, var13)
					}
				}

				if var0.Ipv4Config.StaticConfig == nil {
					var1.Ipv4Config.StaticConfig = nil
				} else {
					var1.Ipv4Config.StaticConfig = &interfaceListDsModel_nfiOrAO_Config{}

					var1.Ipv4Config.StaticConfig.Address = types.StringPointerValue(var0.Ipv4Config.StaticConfig.Address)
				}

				var1.Ipv4Config.Type = types.StringPointerValue(var0.Ipv4Config.Type)
			}

			if var0.Ipv6Config == nil {
				var1.Ipv6Config = nil
			} else {
				var1.Ipv6Config = &interfaceListDsModel_bMGDwkY_Config{}

				if var0.Ipv6Config.DhcpConfig == nil {
					var1.Ipv6Config.DhcpConfig = nil
				} else {
					var1.Ipv6Config.DhcpConfig = &interfaceListDsModel_juuQHdk_Config{}

					var1.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(var0.Ipv6Config.DhcpConfig.ClientId)

					var1.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(var0.Ipv6Config.DhcpConfig.Hostname)
				}

				if var0.Ipv6Config.DnsV6Config == nil {
					var1.Ipv6Config.DnsV6Config = nil
				} else {
					var1.Ipv6Config.DnsV6Config = &interfaceListDsModel_mTuoPRe_Config{}

					var14, var15 := types.ListValueFrom(ctx, types.StringType, var0.Ipv6Config.DnsV6Config.NameServers)
					var1.Ipv6Config.DnsV6Config.NameServers = var14
					resp.Diagnostics.Append(var15.Errors()...)

					var16, var17 := types.ListValueFrom(ctx, types.StringType, var0.Ipv6Config.DnsV6Config.Search)
					var1.Ipv6Config.DnsV6Config.Search = var16
					resp.Diagnostics.Append(var17.Errors()...)
				}

				if len(var0.Ipv6Config.Routes) == 0 {
					var1.Ipv6Config.Routes = nil
				} else {
					var1.Ipv6Config.Routes = make([]interfaceListDsModel_bBEnHsN_Config, 0, len(var0.Ipv6Config.Routes))
					for _, var18 := range var0.Ipv6Config.Routes {
						var19 := interfaceListDsModel_bBEnHsN_Config{}

						var19.Destination = types.StringPointerValue(var18.Destination)

						var19.Via = types.StringPointerValue(var18.Via)
						var1.Ipv6Config.Routes = append(var1.Ipv6Config.Routes, var19)
					}
				}

				if var0.Ipv6Config.StaticConfig == nil {
					var1.Ipv6Config.StaticConfig = nil
				} else {
					var1.Ipv6Config.StaticConfig = &interfaceListDsModel_lIDFRUy_Config{}

					var1.Ipv6Config.StaticConfig.Address = types.StringPointerValue(var0.Ipv6Config.StaticConfig.Address)

					var1.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(var0.Ipv6Config.StaticConfig.EnablePrefixDistribution)
				}

				var1.Ipv6Config.Type = types.StringPointerValue(var0.Ipv6Config.Type)
			}

			var1.LldpEnabled = types.BoolPointerValue(var0.LldpEnabled)

			var1.MacAddress = types.StringPointerValue(var0.MacAddress)

			var1.Mtu = types.Int64PointerValue(var0.Mtu)

			if var0.MulticastConfig == nil {
				var1.MulticastConfig = nil
			} else {
				var1.MulticastConfig = &interfaceListDsModel_zLXjrfn_Config{}

				var1.MulticastConfig.IgmpVersion = types.StringPointerValue(var0.MulticastConfig.IgmpVersion)

				var1.MulticastConfig.MulticastEnabled = types.BoolPointerValue(var0.MulticastConfig.MulticastEnabled)
			}

			var1.Name = types.StringPointerValue(var0.Name)

			var1.NatAddress = types.StringPointerValue(var0.NatAddress)

			var1.NatAddressV6 = types.StringPointerValue(var0.NatAddressV6)

			if len(var0.NatPools) == 0 {
				var1.NatPools = nil
			} else {
				var1.NatPools = make([]interfaceListDsModel_alJfwdK_Config, 0, len(var0.NatPools))
				for _, var20 := range var0.NatPools {
					var21 := interfaceListDsModel_alJfwdK_Config{}

					if len(var20.Ipv4Ranges) == 0 {
						var21.Ipv4Ranges = nil
					} else {
						var21.Ipv4Ranges = make([]interfaceListDsModel_xYviIkG_Config, 0, len(var20.Ipv4Ranges))
						for _, var22 := range var20.Ipv4Ranges {
							var23 := interfaceListDsModel_xYviIkG_Config{}

							var23.End = types.StringValue(var22.End)

							var23.Start = types.StringValue(var22.Start)
							var21.Ipv4Ranges = append(var21.Ipv4Ranges, var23)
						}
					}

					var21.NatPoolId = types.StringPointerValue(var20.NatPoolId)
					var1.NatPools = append(var1.NatPools, var21)
				}
			}

			var1.NatPort = types.Int64PointerValue(var0.NatPort)

			var1.NatPortV6 = types.Int64PointerValue(var0.NatPortV6)

			var1.NatZoneId = types.StringPointerValue(var0.NatZoneId)

			var1.NetworkContextId = types.StringPointerValue(var0.NetworkContextId)

			var1.Parent = types.StringPointerValue(var0.Parent)

			var1.PeerBypasspairWanPortType = types.StringValue(var0.PeerBypasspairWanPortType)

			var1.PoeEnabled = types.BoolPointerValue(var0.PoeEnabled)

			var1.PowerUsageThreshold = types.Int64PointerValue(var0.PowerUsageThreshold)

			if var0.PppoeConfig == nil {
				var1.PppoeConfig = nil
			} else {
				var1.PppoeConfig = &interfaceListDsModel_yxxGXUe_Config{}

				var1.PppoeConfig.HostUniq = types.StringPointerValue(var0.PppoeConfig.HostUniq)

				var1.PppoeConfig.IpAddressType = types.StringPointerValue(var0.PppoeConfig.IpAddressType)

				var1.PppoeConfig.Password = types.StringPointerValue(var0.PppoeConfig.Password)

				var1.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(var0.PppoeConfig.ReconnectionDelay)

				var1.PppoeConfig.ServiceName = types.StringPointerValue(var0.PppoeConfig.ServiceName)

				var1.PppoeConfig.Username = types.StringPointerValue(var0.PppoeConfig.Username)
			}

			var1.Scope = types.StringValue(var0.Scope)

			if len(var0.SecondaryIpConfigs) == 0 {
				var1.SecondaryIpConfigs = nil
			} else {
				var1.SecondaryIpConfigs = make([]interfaceListDsModel_jmyEuEW_Config, 0, len(var0.SecondaryIpConfigs))
				for _, var24 := range var0.SecondaryIpConfigs {
					var25 := interfaceListDsModel_jmyEuEW_Config{}

					var25.Ipv4Address = types.StringPointerValue(var24.Ipv4Address)

					var25.Scope = types.StringPointerValue(var24.Scope)
					var1.SecondaryIpConfigs = append(var1.SecondaryIpConfigs, var25)
				}
			}

			if var0.ServiceLinkConfig == nil {
				var1.ServiceLinkConfig = nil
			} else {
				var1.ServiceLinkConfig = &interfaceListDsModel_obJkRYB_Config{}

				if var0.ServiceLinkConfig.GreConfig == nil {
					var1.ServiceLinkConfig.GreConfig = nil
				} else {
					var1.ServiceLinkConfig.GreConfig = &interfaceListDsModel_suSmnCD_Config{}

					var1.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(var0.ServiceLinkConfig.GreConfig.Csum)

					var1.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(var0.ServiceLinkConfig.GreConfig.KeepaliveEnable)

					var1.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(var0.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

					var1.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(var0.ServiceLinkConfig.GreConfig.KeepaliveInterval)
				}

				if var0.ServiceLinkConfig.IpsecConfig == nil {
					var1.ServiceLinkConfig.IpsecConfig = nil
				} else {
					var1.ServiceLinkConfig.IpsecConfig = &interfaceListDsModel_nnsRzDg_Config{}

					if var0.ServiceLinkConfig.IpsecConfig.Authentication == nil {
						var1.ServiceLinkConfig.IpsecConfig.Authentication = nil
					} else {
						var1.ServiceLinkConfig.IpsecConfig.Authentication = &interfaceListDsModel_xdEvbZX_Config{}

						var1.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

						if var0.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
						} else {
							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &interfaceListDsModel_mKyPIKy_Config{}

							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
						}

						var1.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

						var1.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.Type)

						if var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects == nil {
							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = nil
						} else {
							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &interfaceListDsModel_qSUpByF_Config{}

							if var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil {
								var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(true)
							} else {
								var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolPointerValue(nil)
							}
							//var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = types.BoolPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = types.BoolPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

							if var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil {
								var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(true)
							} else {
								var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolPointerValue(nil)
							}
							//var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

							var26, var27 := types.ListValueFrom(ctx, types.BoolType, var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet)
							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet = var26
							resp.Diagnostics.Append(var27.Errors()...)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = types.StringPointerValue(var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

							var28, var29 := types.ListValueFrom(ctx, types.BoolType, var0.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet)
							var1.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet = var28
							resp.Diagnostics.Append(var29.Errors()...)
						}
					}

					var1.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringValue(var0.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
				}

				var1.ServiceLinkConfig.LastParent = types.StringPointerValue(var0.ServiceLinkConfig.LastParent)

				var1.ServiceLinkConfig.Parent = types.StringPointerValue(var0.ServiceLinkConfig.Parent)

				if var0.ServiceLinkConfig.PassiveMode == nil {
					var1.ServiceLinkConfig.PassiveMode = nil
				} else {
					var1.ServiceLinkConfig.PassiveMode = &interfaceListDsModel_wiUYuNU_Config{}

					var1.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(var0.ServiceLinkConfig.PassiveMode.Enable)

					var1.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(var0.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
				}

				if var0.ServiceLinkConfig.Peer == nil {
					var1.ServiceLinkConfig.Peer = nil
				} else {
					var1.ServiceLinkConfig.Peer = &interfaceListDsModel_pjMVEcr_Config{}

					var1.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(var0.ServiceLinkConfig.Peer.Hostname)

					var30, var31 := types.ListValueFrom(ctx, types.StringType, var0.ServiceLinkConfig.Peer.IpAddresses)
					var1.ServiceLinkConfig.Peer.IpAddresses = var30
					resp.Diagnostics.Append(var31.Errors()...)
				}

				var1.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(var0.ServiceLinkConfig.ServiceEndpointId)

				var1.ServiceLinkConfig.Type = types.StringValue(var0.ServiceLinkConfig.Type)
			}

			var32, var33 := types.ListValueFrom(ctx, types.StringType, var0.SiteWanInterfaceIds)
			var1.SiteWanInterfaceIds = var32
			resp.Diagnostics.Append(var33.Errors()...)

			if len(var0.StaticArpConfigs) == 0 {
				var1.StaticArpConfigs = nil
			} else {
				var1.StaticArpConfigs = make([]interfaceListDsModel_pWDbfYi_Config, 0, len(var0.StaticArpConfigs))
				for _, var34 := range var0.StaticArpConfigs {
					var35 := interfaceListDsModel_pWDbfYi_Config{}

					var35.Ipv4Address = types.StringPointerValue(var34.Ipv4Address)

					var35.MacAddress = types.StringPointerValue(var34.MacAddress)
					var1.StaticArpConfigs = append(var1.StaticArpConfigs, var35)
				}
			}

			if var0.SubInterface == nil {
				var1.SubInterface = nil
			} else {
				var1.SubInterface = &interfaceListDsModel_jEYlBbY_Config{}

				var1.SubInterface.VlanId = types.Int64PointerValue(var0.SubInterface.VlanId)
			}

			if var0.SwitchPortConfig == nil {
				var1.SwitchPortConfig = nil
			} else {
				var1.SwitchPortConfig = &interfaceListDsModel_kslrKbF_Config{}

				var1.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(var0.SwitchPortConfig.AccessVlanId)

				var1.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(var0.SwitchPortConfig.BpduGuardEnabled)

				var1.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(var0.SwitchPortConfig.ForwardFastEnabled)

				var1.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(var0.SwitchPortConfig.NativeVlanId)

				var1.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(var0.SwitchPortConfig.RootGuardEnabled)

				if var0.SwitchPortConfig.StormControlConfig == nil {
					var1.SwitchPortConfig.StormControlConfig = nil
				} else {
					var1.SwitchPortConfig.StormControlConfig = &interfaceListDsModel_qhDZEMT_Config{}

					var1.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(var0.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

					var1.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(var0.SwitchPortConfig.StormControlConfig.MulticastThreshold)

					var1.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(var0.SwitchPortConfig.StormControlConfig.UnicastThreshold)
				}

				var1.SwitchPortConfig.StpPortCost = types.Int64PointerValue(var0.SwitchPortConfig.StpPortCost)

				var1.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(var0.SwitchPortConfig.StpPortEnabled)

				var1.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(var0.SwitchPortConfig.StpPortPriority)

				var36, var37 := types.ListValueFrom(ctx, types.StringType, var0.SwitchPortConfig.TrunkVlans)
				var1.SwitchPortConfig.TrunkVlans = var36
				resp.Diagnostics.Append(var37.Errors()...)

				var1.SwitchPortConfig.VlanMode = types.StringValue(var0.SwitchPortConfig.VlanMode)

				var1.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(var0.SwitchPortConfig.VoiceVlanId)
			}

			var38, var39 := types.ListValueFrom(ctx, types.StringType, var0.Tags)
			var1.Tags = var38
			resp.Diagnostics.Append(var39.Errors()...)

			var1.Type = types.StringValue(var0.Type)

			var1.UsedFor = types.StringValue(var0.UsedFor)

			if var0.VlanConfig == nil {
				var1.VlanConfig = nil
			} else {
				var1.VlanConfig = &interfaceListDsModel_aCdiNxV_Config{}

				var1.VlanConfig.MstpInstance = types.Int64PointerValue(var0.VlanConfig.MstpInstance)

				var1.VlanConfig.VlanId = types.Int64PointerValue(var0.VlanConfig.VlanId)

				var1.VlanConfig.VoiceEnabled = types.BoolPointerValue(var0.VlanConfig.VoiceEnabled)
			}

			var1.VrfContextId = types.StringPointerValue(var0.VrfContextId)
			state.Items = append(state.Items, var1)
		}
	}

	state.TotalItems = types.Int64PointerValue(ans.TotalItems)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Data source.
var (
	_ datasource.DataSource              = &interfaceDataSource{}
	_ datasource.DataSourceWithConfigure = &interfaceDataSource{}
)

func NewInterfaceDataSource() datasource.DataSource {
	return &interfaceDataSource{}
}

type interfaceDataSource struct {
	client *sdwan.Client
}

// interfaceDsModel is the model.
type interfaceDsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	ElementId   types.String `tfsdk:"element_id"`
	InterfaceId types.String `tfsdk:"interface_id"`
	SiteId      types.String `tfsdk:"site_id"`

	// Output.
	AdminUp                    types.Bool                        `tfsdk:"admin_up"`
	AttachedLanNetworks        []interfaceDsModel_irQawLY_Config `tfsdk:"attached_lan_networks"`
	AuthenticationConfig       *interfaceDsModel_mIAatvm_Config  `tfsdk:"authentication_config"`
	BoundInterfaces            types.List                        `tfsdk:"bound_interfaces"`
	BypassPair                 *interfaceDsModel_zGfKFAQ_Config  `tfsdk:"bypass_pair"`
	CellularConfig             *interfaceDsModel_eumQbRC_Config  `tfsdk:"cellular_config"`
	Description                types.String                      `tfsdk:"description"`
	DevicemgmtPolicysetstackId types.String                      `tfsdk:"devicemgmt_policysetstack_id"`
	DhcpRelay                  *interfaceDsModel_mCcgFKg_Config  `tfsdk:"dhcp_relay"`
	DirectedBroadcast          types.Bool                        `tfsdk:"directed_broadcast"`
	Etag                       types.Int64                       `tfsdk:"etag"`
	EthernetPort               *interfaceDsModel_ehJLagQ_Config  `tfsdk:"ethernet_port"`
	Id                         types.String                      `tfsdk:"id"`
	InterfaceProfileId         types.String                      `tfsdk:"interface_profile_id"`
	IpfixcollectorcontextId    types.String                      `tfsdk:"ipfixcollectorcontext_id"`
	IpfixfiltercontextId       types.String                      `tfsdk:"ipfixfiltercontext_id"`
	Ipv4Config                 *interfaceDsModel_wsoFfyL_Config  `tfsdk:"ipv4_config"`
	Ipv6Config                 *interfaceDsModel_bMGDwkY_Config  `tfsdk:"ipv6_config"`
	LldpEnabled                types.Bool                        `tfsdk:"lldp_enabled"`
	MacAddress                 types.String                      `tfsdk:"mac_address"`
	Mtu                        types.Int64                       `tfsdk:"mtu"`
	MulticastConfig            *interfaceDsModel_zLXjrfn_Config  `tfsdk:"multicast_config"`
	Name                       types.String                      `tfsdk:"name"`
	NatAddress                 types.String                      `tfsdk:"nat_address"`
	NatAddressV6               types.String                      `tfsdk:"nat_address_v6"`
	NatPools                   []interfaceDsModel_alJfwdK_Config `tfsdk:"nat_pools"`
	NatPort                    types.Int64                       `tfsdk:"nat_port"`
	NatPortV6                  types.Int64                       `tfsdk:"nat_port_v6"`
	NatZoneId                  types.String                      `tfsdk:"nat_zone_id"`
	NetworkContextId           types.String                      `tfsdk:"network_context_id"`
	Parent                     types.String                      `tfsdk:"parent"`
	PeerBypasspairWanPortType  types.String                      `tfsdk:"peer_bypasspair_wan_port_type"`
	PoeEnabled                 types.Bool                        `tfsdk:"poe_enabled"`
	PowerUsageThreshold        types.Int64                       `tfsdk:"power_usage_threshold"`
	PppoeConfig                *interfaceDsModel_yxxGXUe_Config  `tfsdk:"pppoe_config"`
	Scope                      types.String                      `tfsdk:"scope"`
	SecondaryIpConfigs         []interfaceDsModel_jmyEuEW_Config `tfsdk:"secondary_ip_configs"`
	ServiceLinkConfig          *interfaceDsModel_obJkRYB_Config  `tfsdk:"service_link_config"`
	SiteWanInterfaceIds        types.List                        `tfsdk:"site_wan_interface_ids"`
	StaticArpConfigs           []interfaceDsModel_pWDbfYi_Config `tfsdk:"static_arp_configs"`
	SubInterface               *interfaceDsModel_jEYlBbY_Config  `tfsdk:"sub_interface"`
	SwitchPortConfig           *interfaceDsModel_kslrKbF_Config  `tfsdk:"switch_port_config"`
	Tags                       types.List                        `tfsdk:"tags"`
	Type                       types.String                      `tfsdk:"type"`
	UsedFor                    types.String                      `tfsdk:"used_for"`
	VlanConfig                 *interfaceDsModel_aCdiNxV_Config  `tfsdk:"vlan_config"`
	VrfContextId               types.String                      `tfsdk:"vrf_context_id"`
}

type interfaceDsModel_irQawLY_Config struct {
	LanNetworkId types.String `tfsdk:"lan_network_id"`
	VlanId       types.Int64  `tfsdk:"vlan_id"`
}

type interfaceDsModel_mIAatvm_Config struct {
	FallbackRetryCount      types.Int64  `tfsdk:"fallback_retry_count"`
	Mode                    types.String `tfsdk:"mode"`
	ReauthenticationTimeout types.Int64  `tfsdk:"reauthentication_timeout"`
}

type interfaceDsModel_zGfKFAQ_Config struct {
	Lan                 types.String `tfsdk:"lan"`
	LanStatePropagation types.Bool   `tfsdk:"lan_state_propagation"`
	UseRelay            types.Bool   `tfsdk:"use_relay"`
	Wan                 types.String `tfsdk:"wan"`
}

type interfaceDsModel_eumQbRC_Config struct {
	ApnConfig           *interfaceDsModel_aeWshcf_Config `tfsdk:"apn_config"`
	ApnprofileId        types.String                     `tfsdk:"apnprofile_id"`
	AutoApn             types.Bool                       `tfsdk:"auto_apn"`
	ParentModuleId      types.String                     `tfsdk:"parent_module_id"`
	ParentSimSlotNumber types.Int64                      `tfsdk:"parent_sim_slot_number"`
}

type interfaceDsModel_aeWshcf_Config struct {
	Apn               types.String `tfsdk:"apn"`
	Authentication    types.String `tfsdk:"authentication"`
	ClearPassword     types.Bool   `tfsdk:"clear_password"`
	Password          types.String `tfsdk:"password"`
	PasswordEncrypted types.String `tfsdk:"password_encrypted"`
	UserName          types.String `tfsdk:"user_name"`
}

type interfaceDsModel_mCcgFKg_Config struct {
	Enabled         types.Bool                       `tfsdk:"enabled"`
	Option82        *interfaceDsModel_tOChZgD_Config `tfsdk:"option_82"`
	ServerIps       types.List                       `tfsdk:"server_ips"`
	SourceInterface types.String                     `tfsdk:"source_interface"`
}

type interfaceDsModel_tOChZgD_Config struct {
	CircuitId          types.String `tfsdk:"circuit_id"`
	Enabled            types.Bool   `tfsdk:"enabled"`
	ReforwardingPolicy types.String `tfsdk:"reforwarding_policy"`
	RemoteId           types.String `tfsdk:"remote_id"`
}

type interfaceDsModel_ehJLagQ_Config struct {
	FullDuplex types.Bool                       `tfsdk:"full_duplex"`
	PortId     *interfaceDsModel_ujXZojh_Config `tfsdk:"port_id"`
	PortName   types.String                     `tfsdk:"port_name"`
	Speed      types.Int64                      `tfsdk:"speed"`
}

type interfaceDsModel_ujXZojh_Config struct {
	Connector          types.String `tfsdk:"connector"`
	Device             types.String `tfsdk:"device"`
	Disabled           types.Bool   `tfsdk:"disabled"`
	DisabledReason     types.String `tfsdk:"disabled_reason"`
	ElementId          types.String `tfsdk:"element_id"`
	Id                 types.String `tfsdk:"id"`
	Inactive           types.Bool   `tfsdk:"inactive"`
	InactiveReason     types.String `tfsdk:"inactive_reason"`
	MaxMtu             types.Int64  `tfsdk:"max_mtu"`
	MaxSpeed           types.Int64  `tfsdk:"max_speed"`
	Name               types.String `tfsdk:"name"`
	OriginalMacAddress types.String `tfsdk:"original_mac_address"`
	Region             types.String `tfsdk:"region"`
	SiteId             types.String `tfsdk:"site_id"`
}

type interfaceDsModel_wsoFfyL_Config struct {
	DhcpConfig   *interfaceDsModel_rKcwmLF_Config  `tfsdk:"dhcp_config"`
	DnsV4Config  *interfaceDsModel_mTuoPRe_Config  `tfsdk:"dns_v4_config"`
	PppoeConfig  *interfaceDsModel_cvAyZuw_Config  `tfsdk:"pppoe_config"`
	Routes       []interfaceDsModel_bBEnHsN_Config `tfsdk:"routes"`
	StaticConfig *interfaceDsModel_nfiOrAO_Config  `tfsdk:"static_config"`
	Type         types.String                      `tfsdk:"type"`
}

type interfaceDsModel_rKcwmLF_Config struct {
	ClientId types.String `tfsdk:"client_id"`
	Hostname types.String `tfsdk:"hostname"`
}

type interfaceDsModel_mTuoPRe_Config struct {
	NameServers types.List `tfsdk:"name_servers"`
	Search      types.List `tfsdk:"search"`
}

type interfaceDsModel_cvAyZuw_Config struct {
	ChapPasswd types.String `tfsdk:"chap_passwd"`
	ChapUser   types.String `tfsdk:"chap_user"`
	SetRoute   types.Bool   `tfsdk:"set_route"`
}

type interfaceDsModel_bBEnHsN_Config struct {
	Destination types.String `tfsdk:"destination"`
	Via         types.String `tfsdk:"via"`
}

type interfaceDsModel_nfiOrAO_Config struct {
	Address types.String `tfsdk:"address"`
}

type interfaceDsModel_bMGDwkY_Config struct {
	DhcpConfig   *interfaceDsModel_juuQHdk_Config  `tfsdk:"dhcp_config"`
	DnsV6Config  *interfaceDsModel_mTuoPRe_Config  `tfsdk:"dns_v6_config"`
	Routes       []interfaceDsModel_bBEnHsN_Config `tfsdk:"routes"`
	StaticConfig *interfaceDsModel_lIDFRUy_Config  `tfsdk:"static_config"`
	Type         types.String                      `tfsdk:"type"`
}

type interfaceDsModel_juuQHdk_Config struct {
	ClientId types.String `tfsdk:"client_id"`
	Hostname types.String `tfsdk:"hostname"`
}

type interfaceDsModel_lIDFRUy_Config struct {
	Address                  types.String `tfsdk:"address"`
	EnablePrefixDistribution types.Bool   `tfsdk:"enable_prefix_distribution"`
}

type interfaceDsModel_zLXjrfn_Config struct {
	IgmpVersion      types.String `tfsdk:"igmp_version"`
	MulticastEnabled types.Bool   `tfsdk:"multicast_enabled"`
}

type interfaceDsModel_alJfwdK_Config struct {
	Ipv4Ranges []interfaceDsModel_xYviIkG_Config `tfsdk:"ipv4_ranges"`
	NatPoolId  types.String                      `tfsdk:"nat_pool_id"`
}

type interfaceDsModel_xYviIkG_Config struct {
	End   types.String `tfsdk:"end"`
	Start types.String `tfsdk:"start"`
}

type interfaceDsModel_yxxGXUe_Config struct {
	HostUniq          types.String `tfsdk:"host_uniq"`
	IpAddressType     types.String `tfsdk:"ip_address_type"`
	Password          types.String `tfsdk:"password"`
	ReconnectionDelay types.Int64  `tfsdk:"reconnection_delay"`
	ServiceName       types.String `tfsdk:"service_name"`
	Username          types.String `tfsdk:"username"`
}

type interfaceDsModel_jmyEuEW_Config struct {
	Ipv4Address types.String `tfsdk:"ipv4_address"`
	Scope       types.String `tfsdk:"scope"`
}

type interfaceDsModel_obJkRYB_Config struct {
	GreConfig         *interfaceDsModel_suSmnCD_Config `tfsdk:"gre_config"`
	IpsecConfig       *interfaceDsModel_nnsRzDg_Config `tfsdk:"ipsec_config"`
	LastParent        types.String                     `tfsdk:"last_parent"`
	Parent            types.String                     `tfsdk:"parent"`
	PassiveMode       *interfaceDsModel_wiUYuNU_Config `tfsdk:"passive_mode"`
	Peer              *interfaceDsModel_pjMVEcr_Config `tfsdk:"peer"`
	ServiceEndpointId types.String                     `tfsdk:"service_endpoint_id"`
	Type              types.String                     `tfsdk:"type"`
}

type interfaceDsModel_suSmnCD_Config struct {
	Csum               types.Bool  `tfsdk:"csum"`
	KeepaliveEnable    types.Bool  `tfsdk:"keepalive_enable"`
	KeepaliveFailCount types.Int64 `tfsdk:"keepalive_fail_count"`
	KeepaliveInterval  types.Int64 `tfsdk:"keepalive_interval"`
}

type interfaceDsModel_nnsRzDg_Config struct {
	Authentication *interfaceDsModel_xdEvbZX_Config `tfsdk:"authentication"`
	IpsecProfileId types.String                     `tfsdk:"ipsec_profile_id"`
}

type interfaceDsModel_xdEvbZX_Config struct {
	Certificate                        types.String                     `tfsdk:"certificate"`
	CertificateProfileId               types.String                     `tfsdk:"certificate_profile_id"`
	Comment                            types.String                     `tfsdk:"comment"`
	Ikev1Params                        *interfaceDsModel_mKyPIKy_Config `tfsdk:"ikev1_params"`
	LocalCaCertificate                 types.String                     `tfsdk:"local_ca_certificate"`
	LocalId                            types.String                     `tfsdk:"local_id"`
	LocalIdCustom                      types.String                     `tfsdk:"local_id_custom"`
	LocalPaCertificateId               types.String                     `tfsdk:"local_pa_certificate_id"`
	PaMasterKeyId                      types.String                     `tfsdk:"pa_master_key_id"`
	Passphrase                         types.String                     `tfsdk:"passphrase"`
	PassphraseEncrypted                types.String                     `tfsdk:"passphrase_encrypted"`
	PeerIdCheck                        types.String                     `tfsdk:"peer_id_check"`
	PermitPeerIdMismatch               types.Bool                       `tfsdk:"permit_peer_id_mismatch"`
	PrivateKey                         types.String                     `tfsdk:"private_key"`
	PrivateKeyEncrypted                types.String                     `tfsdk:"private_key_encrypted"`
	RemoteCaCertificate                types.String                     `tfsdk:"remote_ca_certificate"`
	RemoteId                           types.String                     `tfsdk:"remote_id"`
	Secret                             types.String                     `tfsdk:"secret"`
	SecretEncrypted                    types.String                     `tfsdk:"secret_encrypted"`
	SecretHash                         types.String                     `tfsdk:"secret_hash"`
	StrictValidationPeerExtendedKeyUse types.Bool                       `tfsdk:"strict_validation_peer_extended_key_use"`
	Type                               types.String                     `tfsdk:"type"`
	X509Objects                        *interfaceDsModel_qSUpByF_Config `tfsdk:"x509_objects"`
}

type interfaceDsModel_mKyPIKy_Config struct {
	XauthId              types.String `tfsdk:"xauth_id"`
	XauthSecret          types.String `tfsdk:"xauth_secret"`
	XauthSecretEncrypted types.String `tfsdk:"xauth_secret_encrypted"`
	XauthSecretHash      types.String `tfsdk:"xauth_secret_hash"`
	XauthType            types.String `tfsdk:"xauth_type"`
}

type interfaceDsModel_qSUpByF_Config struct {
	CertHolder          types.Bool   `tfsdk:"cert_holder"`
	Certificate         types.String `tfsdk:"certificate"`
	IsLocalCaCertSet    types.Bool   `tfsdk:"is_local_ca_cert_set"`
	IsRemoteCaCertSet   types.Bool   `tfsdk:"is_remote_ca_cert_set"`
	KeyPair             types.Bool   `tfsdk:"key_pair"`
	LocalCaCertificate  types.String `tfsdk:"local_ca_certificate"`
	LocalCaCertsSet     types.List   `tfsdk:"local_ca_certs_set"`
	Passphrase          types.String `tfsdk:"passphrase"`
	PrivateKey          types.String `tfsdk:"private_key"`
	RemoteCaCertificate types.String `tfsdk:"remote_ca_certificate"`
	RemoteCaCertsSet    types.List   `tfsdk:"remote_ca_certs_set"`
}

type interfaceDsModel_wiUYuNU_Config struct {
	Enable        types.Bool `tfsdk:"enable"`
	PeerIpDynamic types.Bool `tfsdk:"peer_ip_dynamic"`
}

type interfaceDsModel_pjMVEcr_Config struct {
	Hostname    types.String `tfsdk:"hostname"`
	IpAddresses types.List   `tfsdk:"ip_addresses"`
}

type interfaceDsModel_pWDbfYi_Config struct {
	Ipv4Address types.String `tfsdk:"ipv4_address"`
	MacAddress  types.String `tfsdk:"mac_address"`
}

type interfaceDsModel_jEYlBbY_Config struct {
	VlanId types.Int64 `tfsdk:"vlan_id"`
}

type interfaceDsModel_kslrKbF_Config struct {
	AccessVlanId       types.Int64                      `tfsdk:"access_vlan_id"`
	BpduGuardEnabled   types.Bool                       `tfsdk:"bpdu_guard_enabled"`
	ForwardFastEnabled types.Bool                       `tfsdk:"forward_fast_enabled"`
	NativeVlanId       types.Int64                      `tfsdk:"native_vlan_id"`
	RootGuardEnabled   types.Bool                       `tfsdk:"root_guard_enabled"`
	StormControlConfig *interfaceDsModel_qhDZEMT_Config `tfsdk:"storm_control_config"`
	StpPortCost        types.Int64                      `tfsdk:"stp_port_cost"`
	StpPortEnabled     types.Bool                       `tfsdk:"stp_port_enabled"`
	StpPortPriority    types.Int64                      `tfsdk:"stp_port_priority"`
	TrunkVlans         types.List                       `tfsdk:"trunk_vlans"`
	VlanMode           types.String                     `tfsdk:"vlan_mode"`
	VoiceVlanId        types.Int64                      `tfsdk:"voice_vlan_id"`
}

type interfaceDsModel_qhDZEMT_Config struct {
	BroadcastThreshold types.Int64 `tfsdk:"broadcast_threshold"`
	MulticastThreshold types.Int64 `tfsdk:"multicast_threshold"`
	UnicastThreshold   types.Int64 `tfsdk:"unicast_threshold"`
}

type interfaceDsModel_aCdiNxV_Config struct {
	MstpInstance types.Int64 `tfsdk:"mstp_instance"`
	VlanId       types.Int64 `tfsdk:"vlan_id"`
	VoiceEnabled types.Bool  `tfsdk:"voice_enabled"`
}

// Metadata returns the data source type name.
func (d *interfaceDataSource) Metadata(_ context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_interface"
}

// Schema defines the schema for this data source.
func (d *interfaceDataSource) Schema(_ context.Context, _ datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = dsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]dsschema.Attribute{
			// inputs:map[string]bool{"element_id":true, "interface_id":true, "site_id":true} outputs:map[string]bool{"admin_up":true, "attached_lan_networks":true, "authentication_config":true, "bound_interfaces":true, "bypass_pair":true, "cellular_config":true, "description":true, "devicemgmt_policysetstack_id":true, "dhcp_relay":true, "directed_broadcast":true, "etag":true, "ethernet_port":true, "id":true, "interface_profile_id":true, "ipfixcollectorcontext_id":true, "ipfixfiltercontext_id":true, "ipv4_config":true, "ipv6_config":true, "lldp_enabled":true, "mac_address":true, "mtu":true, "multicast_config":true, "name":true, "nat_address":true, "nat_address_v6":true, "nat_pools":true, "nat_port":true, "nat_port_v6":true, "nat_zone_id":true, "network_context_id":true, "parent":true, "peer_bypasspair_wan_port_type":true, "poe_enabled":true, "power_usage_threshold":true, "pppoe_config":true, "scope":true, "secondary_ip_configs":true, "service_link_config":true, "site_wan_interface_ids":true, "static_arp_configs":true, "sub_interface":true, "switch_port_config":true, "tags":true, "tfid":true, "type":true, "used_for":true, "vlan_config":true, "vrf_context_id":true} forceNew:map[string]bool{"element_id":true, "interface_id":true, "site_id":true}
			"admin_up": dsschema.BoolAttribute{
				Description: "Admin Up.",
				Computed:    true,
			},
			"attached_lan_networks": dsschema.ListNestedAttribute{
				Description: "Attached Lan Networks: Valid .",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"lan_network_id":true, "vlan_id":true} forceNew:map[string]bool(nil)
						"lan_network_id": dsschema.StringAttribute{
							Description: "Lan Network Id.",
							Computed:    true,
						},
						"vlan_id": dsschema.Int64Attribute{
							Description: "Vlan Id: Range(max = 4095L, error = INVALID_VLANID: VLAN ID should be between 0 and 4095., min = 0L) .",
							Computed:    true,
						},
					},
				},
			},
			"authentication_config": dsschema.SingleNestedAttribute{
				Description: "The AuthenticationConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"fallback_retry_count":true, "mode":true, "reauthentication_timeout":true} forceNew:map[string]bool(nil)
					"fallback_retry_count": dsschema.Int64Attribute{
						Description: "Fallback Retry Count.",
						Computed:    true,
					},
					"mode": dsschema.StringAttribute{
						Description: "Mode. String must be one of these: `\"none\"`, `\"dot1x\"`, `\"macauth\"`, `\"dot1x-to-macauth-fallback\"`.",
						Computed:    true,
					},
					"reauthentication_timeout": dsschema.Int64Attribute{
						Description: "Reauthentication Timeout.",
						Computed:    true,
					},
				},
			},
			"bound_interfaces": dsschema.ListAttribute{
				Description: "Bound Interfaces.",
				Computed:    true,
				ElementType: types.StringType,
			},
			"bypass_pair": dsschema.SingleNestedAttribute{
				Description: "The BypassPair param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"lan":true, "lan_state_propagation":true, "use_relay":true, "wan":true} forceNew:map[string]bool(nil)
					"lan": dsschema.StringAttribute{
						Description: "Lan.",
						Computed:    true,
					},
					"lan_state_propagation": dsschema.BoolAttribute{
						Description: "Lan State Propagation.",
						Computed:    true,
					},
					"use_relay": dsschema.BoolAttribute{
						Description: "Use Relay.",
						Computed:    true,
					},
					"wan": dsschema.StringAttribute{
						Description: "Wan.",
						Computed:    true,
					},
				},
			},
			"cellular_config": dsschema.SingleNestedAttribute{
				Description: "The CellularConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"apn_config":true, "apnprofile_id":true, "auto_apn":true, "parent_module_id":true, "parent_sim_slot_number":true} forceNew:map[string]bool(nil)
					"apn_config": dsschema.SingleNestedAttribute{
						Description: "The ApnConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"apn":true, "authentication":true, "clear_password":true, "password":true, "password_encrypted":true, "user_name":true} forceNew:map[string]bool(nil)
							"apn": dsschema.StringAttribute{
								Description: "Apn: Size(max = 100, error = CELLULAR_INTERFACE_CONFIG_APN_CONFIG_PROFILE_NAME_INVALID: Invalid cellular interface config. APN name is invalid. APN name allowed max length is 100. Valid characters are alphanumeric, hyphen (-), and period (.). Must begin and end with an alphanumeric character., min = 0) .",
								Computed:    true,
							},
							"authentication": dsschema.StringAttribute{
								Description: "Authentication: ValidateEnum(enumClass = classOf[APNAuthentication], message = INVALID_APN_AUTHENTICATION, nullAllowed = false) . String must be one of these: `\"none\"`, `\"pap\"`, `\"chap\"`, `\"pap_or_chap\"`.",
								Computed:    true,
							},
							"clear_password": dsschema.BoolAttribute{
								Description: "Clear Password.",
								Computed:    true,
							},
							"password": dsschema.StringAttribute{
								Description: "Password.",
								Computed:    true,
							},
							"password_encrypted": dsschema.StringAttribute{
								Description: "Password Encrypted: JsonIgnore(value = true) .",
								Computed:    true,
							},
							"user_name": dsschema.StringAttribute{
								Description: "User Name: Size(max = 100, error = CELLULAR_INTERFACE_CONFIG_APN_CONFIG_USERNAME_INVALID: Invalid cellular interface config. APN username is invalid. APN username allowed max length is 100., min = 0) .",
								Computed:    true,
							},
						},
					},
					"apnprofile_id": dsschema.StringAttribute{
						Description: "Apnprofile Id.",
						Computed:    true,
					},
					"auto_apn": dsschema.BoolAttribute{
						Description: "Auto Apn.",
						Computed:    true,
					},
					"parent_module_id": dsschema.StringAttribute{
						Description: "Parent Module Id.",
						Computed:    true,
					},
					"parent_sim_slot_number": dsschema.Int64Attribute{
						Description: "Parent Sim Slot Number.",
						Computed:    true,
					},
				},
			},
			"description": dsschema.StringAttribute{
				Description: "Description: Size(max = 256, error = DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds limit, min = 0) .",
				Computed:    true,
			},
			"devicemgmt_policysetstack_id": dsschema.StringAttribute{
				Description: "Devicemgmt Policysetstack Id: Digits(fraction = 0, integer = 30, INVALID_DEVICEMGMT_POLICYSETSTACK_ID) .",
				Computed:    true,
			},
			"dhcp_relay": dsschema.SingleNestedAttribute{
				Description: "The DhcpRelay param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} forceNew:map[string]bool(nil)
					"enabled": dsschema.BoolAttribute{
						Description: "Enabled.",
						Computed:    true,
					},
					"option_82": dsschema.SingleNestedAttribute{
						Description: "The Option82 param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} forceNew:map[string]bool(nil)
							"circuit_id": dsschema.StringAttribute{
								Description: "Circuit Id: Size(max = 255, error = DHCPRELAY_CIRCUIT_ID_EXCEEDS_LIMIT: Option 82 Circuid ID exceeds maximum length, min = 0) .",
								Computed:    true,
							},
							"enabled": dsschema.BoolAttribute{
								Description: "Enabled.",
								Computed:    true,
							},
							"reforwarding_policy": dsschema.StringAttribute{
								Description: "Reforwarding Policy: ValidateEnum(enumClass = classOf[DHCPRelayReforwardingPolicy], error = INVALID_DHCP_RELAY_REFWDING_POLICY: Option 82 invalid reforwarding policy, nullAllowed = false) . String must be one of these: `\"REPLACE\"`, `\"KEEP\"`, `\"APPEND\"`, `\"DROP\"`.",
								Computed:    true,
							},
							"remote_id": dsschema.StringAttribute{
								Description: "Remote Id: Size(max = 255, error = DHCPRELAY_REMOTE_ID_EXCEEDS_LIMIT: Option 82 Remote ID exceeds maximum length, min = 0) .",
								Computed:    true,
							},
						},
					},
					"server_ips": dsschema.ListAttribute{
						Description: "Server Ips: ListIPAddress(bcast = DENY, listMaxSize = 0, error = INTERFACE_CONFIG_INVALID_DHCP_RELAY_LIST: DHCP Servers IP specified in the list are invalid, required = true, type = IP) Size(max = 16, error = INTERFACE_CONFIG_DHCP_RELAY_LIST_EXCEEDS_LIMIT: DHCP Servers specified in the list exceeds maximum limit, min = 0) .",
						Computed:    true,
						ElementType: types.StringType,
					},
					"source_interface": dsschema.StringAttribute{
						Description: "Source Interface.",
						Computed:    true,
					},
				},
			},
			"directed_broadcast": dsschema.BoolAttribute{
				Description: "Directed Broadcast.",
				Computed:    true,
			},
			"element_id": dsschema.StringAttribute{
				Description: "Element Id.",
				Required:    true,
			},
			"etag": dsschema.Int64Attribute{
				Description: "Entity tag for the resource.",
				Computed:    true,
			},
			"ethernet_port": dsschema.SingleNestedAttribute{
				Description: "The EthernetPort param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"full_duplex":true, "port_id":true, "port_name":true, "speed":true} forceNew:map[string]bool(nil)
					"full_duplex": dsschema.BoolAttribute{
						Description: "Full Duplex.",
						Computed:    true,
					},
					"port_id": dsschema.SingleNestedAttribute{
						Description: "The PortId param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"connector":true, "device":true, "disabled":true, "disabled_reason":true, "element_id":true, "id":true, "inactive":true, "inactive_reason":true, "max_mtu":true, "max_speed":true, "name":true, "original_mac_address":true, "region":true, "site_id":true} forceNew:map[string]bool(nil)
							"connector": dsschema.StringAttribute{
								Description: "Connector Type.",
								Computed:    true,
							},
							"device": dsschema.StringAttribute{
								Description: "Device Name.",
								Computed:    true,
							},
							"disabled": dsschema.BoolAttribute{
								Description: "Disabled.",
								Computed:    true,
							},
							"disabled_reason": dsschema.StringAttribute{
								Description: "Disabled Reason: Size(max = 5000, DISABLED_REASON_INVALID_0001, min = 0) .",
								Computed:    true,
							},
							"element_id": dsschema.StringAttribute{
								Description: "Element Id.",
								Computed:    true,
							},
							"id": dsschema.StringAttribute{
								Description: "The Id param.",
								Computed:    true,
							},
							"inactive": dsschema.BoolAttribute{
								Description: "Inactive.",
								Computed:    true,
							},
							"inactive_reason": dsschema.StringAttribute{
								Description: "Inactive Reason: Size(max = 5000, INACTIVE_REASON_INVALID_0001, min = 0) .",
								Computed:    true,
							},
							"max_mtu": dsschema.Int64Attribute{
								Description: "Max Mtu.",
								Computed:    true,
							},
							"max_speed": dsschema.Int64Attribute{
								Description: "Max Speed.",
								Computed:    true,
							},
							"name": dsschema.StringAttribute{
								Description: "Name.",
								Computed:    true,
							},
							"original_mac_address": dsschema.StringAttribute{
								Description: "Orig Mac Addr.",
								Computed:    true,
							},
							"region": dsschema.StringAttribute{
								Description: "Region.",
								Computed:    true,
							},
							"site_id": dsschema.StringAttribute{
								Description: "Site Id: Digits(fraction = 0, integer = 50, SITEID_INVALID) NotNull .",
								Computed:    true,
							},
						},
					},
					"port_name": dsschema.StringAttribute{
						Description: "Port Name.",
						Computed:    true,
					},
					"speed": dsschema.Int64Attribute{
						Description: "Speed.",
						Computed:    true,
					},
				},
			},
			"id": dsschema.StringAttribute{
				Description: "Id.",
				Computed:    true,
			},
			"interface_id": dsschema.StringAttribute{
				Description: "Interface Id.",
				Required:    true,
			},
			"interface_profile_id": dsschema.StringAttribute{
				Description: "Interface Profile Id.",
				Computed:    true,
			},
			"ipfixcollectorcontext_id": dsschema.StringAttribute{
				Description: "Ipfixcollectorcontext Id.",
				Computed:    true,
			},
			"ipfixfiltercontext_id": dsschema.StringAttribute{
				Description: "Ipfixfiltercontext Id.",
				Computed:    true,
			},
			"ipv4_config": dsschema.SingleNestedAttribute{
				Description: "The Ipv4Config param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"dhcp_config":true, "dns_v4_config":true, "pppoe_config":true, "routes":true, "static_config":true, "type":true} forceNew:map[string]bool(nil)
					"dhcp_config": dsschema.SingleNestedAttribute{
						Description: "The DhcpConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"client_id":true, "hostname":true} forceNew:map[string]bool(nil)
							"client_id": dsschema.StringAttribute{
								Description: "Client Id.",
								Computed:    true,
							},
							"hostname": dsschema.StringAttribute{
								Description: "Hostname.",
								Computed:    true,
							},
						},
					},
					"dns_v4_config": dsschema.SingleNestedAttribute{
						Description: "The DnsV4Config param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"name_servers":true, "search":true} forceNew:map[string]bool(nil)
							"name_servers": dsschema.ListAttribute{
								Description: "Name Servers.",
								Computed:    true,
								ElementType: types.StringType,
							},
							"search": dsschema.ListAttribute{
								Description: "Search.",
								Computed:    true,
								ElementType: types.StringType,
							},
						},
					},
					"pppoe_config": dsschema.SingleNestedAttribute{
						Description: "The PppoeConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"chap_passwd":true, "chap_user":true, "set_route":true} forceNew:map[string]bool(nil)
							"chap_passwd": dsschema.StringAttribute{
								Description: "Chap Passwd.",
								Computed:    true,
							},
							"chap_user": dsschema.StringAttribute{
								Description: "Chap User.",
								Computed:    true,
							},
							"set_route": dsschema.BoolAttribute{
								Description: "Set Route.",
								Computed:    true,
							},
						},
					},
					"routes": dsschema.ListNestedAttribute{
						Description: "Routes: Valid .",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"destination":true, "via":true} forceNew:map[string]bool(nil)
								"destination": dsschema.StringAttribute{
									Description: "Destination.",
									Computed:    true,
								},
								"via": dsschema.StringAttribute{
									Description: "Via.",
									Computed:    true,
								},
							},
						},
					},
					"static_config": dsschema.SingleNestedAttribute{
						Description: "The StaticConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"address":true} forceNew:map[string]bool(nil)
							"address": dsschema.StringAttribute{
								Description: "Address.",
								Computed:    true,
							},
						},
					},
					"type": dsschema.StringAttribute{
						Description: "Type: Size(max = 12, error = INTERFACE_CONFIG_INVALID_IP_TYPE: IP Type is not valid., min = 0) .",
						Computed:    true,
					},
				},
			},
			"ipv6_config": dsschema.SingleNestedAttribute{
				Description: "The Ipv6Config param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"dhcp_config":true, "dns_v6_config":true, "routes":true, "static_config":true, "type":true} forceNew:map[string]bool(nil)
					"dhcp_config": dsschema.SingleNestedAttribute{
						Description: "The DhcpConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"client_id":true, "hostname":true} forceNew:map[string]bool(nil)
							"client_id": dsschema.StringAttribute{
								Description: "Client Id.",
								Computed:    true,
							},
							"hostname": dsschema.StringAttribute{
								Description: "Hostname.",
								Computed:    true,
							},
						},
					},
					"dns_v6_config": dsschema.SingleNestedAttribute{
						Description: "The DnsV6Config param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"name_servers":true, "search":true} forceNew:map[string]bool(nil)
							"name_servers": dsschema.ListAttribute{
								Description: "Name Servers.",
								Computed:    true,
								ElementType: types.StringType,
							},
							"search": dsschema.ListAttribute{
								Description: "Search.",
								Computed:    true,
								ElementType: types.StringType,
							},
						},
					},
					"routes": dsschema.ListNestedAttribute{
						Description: "Routes.",
						Computed:    true,
						NestedObject: dsschema.NestedAttributeObject{
							Attributes: map[string]dsschema.Attribute{
								// inputs:map[string]bool{} outputs:map[string]bool{"destination":true, "via":true} forceNew:map[string]bool(nil)
								"destination": dsschema.StringAttribute{
									Description: "Destination.",
									Computed:    true,
								},
								"via": dsschema.StringAttribute{
									Description: "Via.",
									Computed:    true,
								},
							},
						},
					},
					"static_config": dsschema.SingleNestedAttribute{
						Description: "The StaticConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"address":true, "enable_prefix_distribution":true} forceNew:map[string]bool(nil)
							"address": dsschema.StringAttribute{
								Description: "Address.",
								Computed:    true,
							},
							"enable_prefix_distribution": dsschema.BoolAttribute{
								Description: "Enable Prefix Distribution.",
								Computed:    true,
							},
						},
					},
					"type": dsschema.StringAttribute{
						Description: "Type.",
						Computed:    true,
					},
				},
			},
			"lldp_enabled": dsschema.BoolAttribute{
				Description: "Lldp Enabled.",
				Computed:    true,
			},
			"mac_address": dsschema.StringAttribute{
				Description: "Mac Address: Pattern(error = INTERFACE_CONFIG_INVALID_MAC: Invalid mac address syntax., regexp = ([0-9a-f]{2}[:]){5}([0-9a-f]{2})) .",
				Computed:    true,
			},
			"mtu": dsschema.Int64Attribute{
				Description: "Mtu: Range(max = 9216L, error = INTERFACE_CONFIG_INVALID_MTU: MTU is not in the valid range., min = 0L) .",
				Computed:    true,
			},
			"multicast_config": dsschema.SingleNestedAttribute{
				Description: "The MulticastConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"igmp_version":true, "multicast_enabled":true} forceNew:map[string]bool(nil)
					"igmp_version": dsschema.StringAttribute{
						Description: "Igmp Version. String must be one of these: `\"IGMPV2\"`, `\"IGMPV3\"`.",
						Computed:    true,
					},
					"multicast_enabled": dsschema.BoolAttribute{
						Description: "Multicast Enabled.",
						Computed:    true,
					},
				},
			},
			"name": dsschema.StringAttribute{
				Description: "Name: Size(max = 128, error = NAME_EXCEEDS_LIMIT: Name of the resource exceeds limit., min = 0) .",
				Computed:    true,
			},
			"nat_address": dsschema.StringAttribute{
				Description: "Nat Address: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = INVALID_NAT_IP: NAT IP address is invalid., type = IP) .",
				Computed:    true,
			},
			"nat_address_v6": dsschema.StringAttribute{
				Description: "Nat Address V6: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = INVALID_IPV6_NAT: IPv6 NAT address is invalid., type = IPV6) .",
				Computed:    true,
			},
			"nat_pools": dsschema.ListNestedAttribute{
				Description: "Nat Pools: Valid .",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"ipv4_ranges":true, "nat_pool_id":true} forceNew:map[string]bool(nil)
						"ipv4_ranges": dsschema.ListNestedAttribute{
							Description: "Ipv4 Ranges: Size(max = 4, error = INTERFACE_CONFIG_INVALID_NAT_POOL_IP_RANGE: Minimum 1 and maximum 4 nat pool IP ranges can be specified., min = 1) Valid .",
							Computed:    true,
							NestedObject: dsschema.NestedAttributeObject{
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"end":true, "start":true} forceNew:map[string]bool(nil)
									"end": dsschema.StringAttribute{
										Description: "End: NotNull(error = END_IP_MISSING: End ip is not specified in range.) IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = END_IP_INVALID_IN_RANGE: Invalid end ip specified in range., type = IP) .",
										Computed:    true,
									},
									"start": dsschema.StringAttribute{
										Description: "Start: NotNull(error = START_IP_MISSING: Start ip is not specified in range.) IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = START_IP_INVALID_IN_RANGE: Invalid start ip specified in range., type = IP) .",
										Computed:    true,
									},
								},
							},
						},
						"nat_pool_id": dsschema.StringAttribute{
							Description: "Nat Pool Id: Digits(fraction = 0, integer = 30, INVALID_NAT_POLICYPOOL_ID) .",
							Computed:    true,
						},
					},
				},
			},
			"nat_port": dsschema.Int64Attribute{
				Description: "Nat Port: Range(max = 65535L, error = INTERFACE_CONFIG_INVALID_PORT: LAN,WAN,Internet bypass ports cannot be part of logical interface groups., min = 0L) .",
				Computed:    true,
			},
			"nat_port_v6": dsschema.Int64Attribute{
				Description: "Nat Port V6: Range(max = 65535L, error = INTERFACE_CONFIG_INVALID_PORT: LAN,WAN,Internet bypass ports cannot be part of logical interface groups., min = 0L) .",
				Computed:    true,
			},
			"nat_zone_id": dsschema.StringAttribute{
				Description: "Nat Zone Id: Digits(fraction = 0, integer = 30, INVALID_NAT_POLICY_ZONE) .",
				Computed:    true,
			},
			"network_context_id": dsschema.StringAttribute{
				Description: "Network Context Id.",
				Computed:    true,
			},
			"parent": dsschema.StringAttribute{
				Description: "Parent.",
				Computed:    true,
			},
			"peer_bypasspair_wan_port_type": dsschema.StringAttribute{
				Description: "Peer Bypasspair Wan Port Type: ValidateEnum(enumClass = classOf[PortExtensionType], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"none\"`, `\"cellular\"`.",
				Computed:    true,
			},
			"poe_enabled": dsschema.BoolAttribute{
				Description: "Poe Enabled.",
				Computed:    true,
			},
			"power_usage_threshold": dsschema.Int64Attribute{
				Description: "Power Usage Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_POE_POWER_USAGE_THRESHOLD: Invalid Interface configuration. Invalid PoE alarm threshold value {}. Valid values are in the range 50-100., min = 0) .",
				Computed:    true,
			},
			"pppoe_config": dsschema.SingleNestedAttribute{
				Description: "The PppoeConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"host_uniq":true, "ip_address_type":true, "password":true, "reconnection_delay":true, "service_name":true, "username":true} forceNew:map[string]bool(nil)
					"host_uniq": dsschema.StringAttribute{
						Description: "Host Uniq.",
						Computed:    true,
					},
					"ip_address_type": dsschema.StringAttribute{
						Description: "Ip Address Type.",
						Computed:    true,
					},
					"password": dsschema.StringAttribute{
						Description: "Password.",
						Computed:    true,
					},
					"reconnection_delay": dsschema.Int64Attribute{
						Description: "Reconnection Delay.",
						Computed:    true,
					},
					"service_name": dsschema.StringAttribute{
						Description: "Service Name.",
						Computed:    true,
					},
					"username": dsschema.StringAttribute{
						Description: "Username.",
						Computed:    true,
					},
				},
			},
			"scope": dsschema.StringAttribute{
				Description: "Scope: ValidateEnum(enumClass = classOf[NetworkScope], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"GLOBAL\"`, `\"LOCAL\"`.",
				Computed:    true,
			},
			"secondary_ip_configs": dsschema.ListNestedAttribute{
				Description: "Secondary Ip Configs.",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"ipv4_address":true, "scope":true} forceNew:map[string]bool(nil)
						"ipv4_address": dsschema.StringAttribute{
							Description: "Ipv4 Address.",
							Computed:    true,
						},
						"scope": dsschema.StringAttribute{
							Description: "Scope.",
							Computed:    true,
						},
					},
				},
			},
			"service_link_config": dsschema.SingleNestedAttribute{
				Description: "The ServiceLinkConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"gre_config":true, "ipsec_config":true, "last_parent":true, "parent":true, "passive_mode":true, "peer":true, "service_endpoint_id":true, "type":true} forceNew:map[string]bool(nil)
					"gre_config": dsschema.SingleNestedAttribute{
						Description: "The GreConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"csum":true, "keepalive_enable":true, "keepalive_fail_count":true, "keepalive_interval":true} forceNew:map[string]bool(nil)
							"csum": dsschema.BoolAttribute{
								Description: "Csum.",
								Computed:    true,
							},
							"keepalive_enable": dsschema.BoolAttribute{
								Description: "Keepalive Enable.",
								Computed:    true,
							},
							"keepalive_fail_count": dsschema.Int64Attribute{
								Description: "Keepalive Fail Count: Range(max = 10L, error = INTERFACE_CONFIG_SERVICE_LINK_INVALID_GRE_KEEPALIVE_FAIL_COUNT: Keep alive fail count should be in range 1 to 10, min = 1L) .",
								Computed:    true,
							},
							"keepalive_interval": dsschema.Int64Attribute{
								Description: "Keepalive Interval: Range(max = 30L, error = INTERFACE_CONFIG_SERVICE_LINK_INVALID_GRE_KEEPALIVE_INTERVAL: Keep alive interval should be in range 3 to 30, min = 3L) .",
								Computed:    true,
							},
						},
					},
					"ipsec_config": dsschema.SingleNestedAttribute{
						Description: "The IpsecConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"authentication":true, "ipsec_profile_id":true} forceNew:map[string]bool(nil)
							"authentication": dsschema.SingleNestedAttribute{
								Description: "The Authentication param.",
								Computed:    true,
								Attributes: map[string]dsschema.Attribute{
									// inputs:map[string]bool{} outputs:map[string]bool{"certificate":true, "certificate_profile_id":true, "comment":true, "ikev1_params":true, "local_ca_certificate":true, "local_id":true, "local_id_custom":true, "local_pa_certificate_id":true, "pa_master_key_id":true, "passphrase":true, "passphrase_encrypted":true, "peer_id_check":true, "permit_peer_id_mismatch":true, "private_key":true, "private_key_encrypted":true, "remote_ca_certificate":true, "remote_id":true, "secret":true, "secret_encrypted":true, "secret_hash":true, "strict_validation_peer_extended_key_use":true, "type":true, "x509Objects":true} forceNew:map[string]bool(nil)
									"certificate": dsschema.StringAttribute{
										Description: "Certificate.",
										Computed:    true,
									},
									"certificate_profile_id": dsschema.StringAttribute{
										Description: "Certificate Profile Id.",
										Computed:    true,
									},
									"comment": dsschema.StringAttribute{
										Description: "Comment.",
										Computed:    true,
									},
									"ikev1_params": dsschema.SingleNestedAttribute{
										Description: "The Ikev1Params param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"xauth_id":true, "xauth_secret":true, "xauth_secret_encrypted":true, "xauth_secret_hash":true, "xauth_type":true} forceNew:map[string]bool(nil)
											"xauth_id": dsschema.StringAttribute{
												Description: "Xauth Id.",
												Computed:    true,
											},
											"xauth_secret": dsschema.StringAttribute{
												Description: "Xauth Secret: Length(max = 128, error = IPSECCONFIG_INVALID_XAUTH_SECRET_LEN: Invalid extended authentication secret length.Should be between 4-128., min = 4) .",
												Computed:    true,
											},
											"xauth_secret_encrypted": dsschema.StringAttribute{
												Description: "Xauth Secret Encrypted: JsonIgnore(value = true) .",
												Computed:    true,
											},
											"xauth_secret_hash": dsschema.StringAttribute{
												Description: "Xauth Secret Hash: JsonIgnore(value = true) .",
												Computed:    true,
											},
											"xauth_type": dsschema.StringAttribute{
												Description: "Xauth Type: ValidateEnum(enumClass = classOf[IKEXAuthType], error = IPSECCONFIG_INVALID_XAUTH_TYPE: Invalid extended authentication type specified.Valid type are secret or none., nullAllowed = false) . String must be one of these: `\"NONE\"`, `\"SECRET\"`.",
												Computed:    true,
											},
										},
									},
									"local_ca_certificate": dsschema.StringAttribute{
										Description: "Local Ca Certificate.",
										Computed:    true,
									},
									"local_id": dsschema.StringAttribute{
										Description: "Local Id: ValidateEnum(enumClass = classOf[IPSECLocalIdType], error = IPSECCONFIG_INVALID_LOCAL_ID_TYPE: Invalid local id type.Should be either hostname, dn, local_ip or custom, nullAllowed = false) . String must be one of these: `\"LOCAL_IP\"`, `\"DN\"`, `\"HOSTNAME\"`, `\"CUSTOM\"`, `\"NONE\"`.",
										Computed:    true,
									},
									"local_id_custom": dsschema.StringAttribute{
										Description: "Local Id Custom: Length(max = 255, error = IPSECCONFIG_INVALID_LOCAL_ID_LEN: Invalid local id len.Should be between 2-255., min = 2) .",
										Computed:    true,
									},
									"local_pa_certificate_id": dsschema.StringAttribute{
										Description: "Local Pa Certificate Id.",
										Computed:    true,
									},
									"pa_master_key_id": dsschema.StringAttribute{
										Description: "Pa Master Key Id.",
										Computed:    true,
									},
									"passphrase": dsschema.StringAttribute{
										Description: "Passphrase.",
										Computed:    true,
									},
									"passphrase_encrypted": dsschema.StringAttribute{
										Description: "Passphrase Encrypted: JsonIgnore(value = true) .",
										Computed:    true,
									},
									"peer_id_check": dsschema.StringAttribute{
										Description: "Peer Id Check. String must be one of these: `\"EXACT\"`, `\"WILDCARD\"`.",
										Computed:    true,
									},
									"permit_peer_id_mismatch": dsschema.BoolAttribute{
										Description: "Permit Peer Id Mismatch.",
										Computed:    true,
									},
									"private_key": dsschema.StringAttribute{
										Description: "Private Key.",
										Computed:    true,
									},
									"private_key_encrypted": dsschema.StringAttribute{
										Description: "Private Key Encrypted: JsonIgnore(value = true) .",
										Computed:    true,
									},
									"remote_ca_certificate": dsschema.StringAttribute{
										Description: "Remote Ca Certificate.",
										Computed:    true,
									},
									"remote_id": dsschema.StringAttribute{
										Description: "Remote Id: Length(max = 255, error = IPSECCONFIG_INVALID_REMOTE_ID_LEN: Invalid remote id len.Should be between 2-255., min = 2) .",
										Computed:    true,
									},
									"secret": dsschema.StringAttribute{
										Description: "Secret.",
										Computed:    true,
									},
									"secret_encrypted": dsschema.StringAttribute{
										Description: "Secret Encrypted: JsonIgnore(value = true) .",
										Computed:    true,
									},
									"secret_hash": dsschema.StringAttribute{
										Description: "Secret Hash: JsonIgnore(value = true) .",
										Computed:    true,
									},
									"strict_validation_peer_extended_key_use": dsschema.BoolAttribute{
										Description: "Strict Validation Peer Extended Key Use.",
										Computed:    true,
									},
									"type": dsschema.StringAttribute{
										Description: "Type: ValidateEnum(enumClass = classOf[IPSECAuthenticationType], error = IPSECCONFIG_INVALID_AUTHENTICATION_TYPE: Invalid authentication type specified.Valid type are x509, psk or none., nullAllowed = false) . String must be one of these: `\"NONE\"`, `\"PSK\"`, `\"X509\"`.",
										Computed:    true,
									},
									"x509_objects": dsschema.SingleNestedAttribute{
										Description: "The X509Objects param.",
										Computed:    true,
										Attributes: map[string]dsschema.Attribute{
											// inputs:map[string]bool{} outputs:map[string]bool{"certHolder":true, "certificate":true, "is_local_ca_cert_set":true, "is_remote_ca_cert_set":true, "keyPair":true, "local_ca_certificate":true, "local_ca_certs_set":true, "passphrase":true, "private_key":true, "remote_ca_certificate":true, "remote_ca_certs_set":true} forceNew:map[string]bool(nil)
											"cert_holder": dsschema.BoolAttribute{
												Description: "The CertHolder param. Default: `false`.",
												Computed:    true,
											},
											"certificate": dsschema.StringAttribute{
												Description: "Certificate.",
												Computed:    true,
											},
											"is_local_ca_cert_set": dsschema.BoolAttribute{
												Description: "Is Local Ca Cert Set.",
												Computed:    true,
											},
											"is_remote_ca_cert_set": dsschema.BoolAttribute{
												Description: "Is Remote Ca Cert Set.",
												Computed:    true,
											},
											"key_pair": dsschema.BoolAttribute{
												Description: "The KeyPair param. Default: `false`.",
												Computed:    true,
											},
											"local_ca_certificate": dsschema.StringAttribute{
												Description: "Local Ca Certificate.",
												Computed:    true,
											},
											"local_ca_certs_set": dsschema.ListAttribute{
												Description: "Local Ca Certs Set.",
												Computed:    true,
												ElementType: types.BoolType,
											},
											"passphrase": dsschema.StringAttribute{
												Description: "Passphrase.",
												Computed:    true,
											},
											"private_key": dsschema.StringAttribute{
												Description: "Private Key.",
												Computed:    true,
											},
											"remote_ca_certificate": dsschema.StringAttribute{
												Description: "Remote Ca Certificate.",
												Computed:    true,
											},
											"remote_ca_certs_set": dsschema.ListAttribute{
												Description: "Remote Ca Certs Set.",
												Computed:    true,
												ElementType: types.BoolType,
											},
										},
									},
								},
							},
							"ipsec_profile_id": dsschema.StringAttribute{
								Description: "Ipsec Profile Id: Required(IPSEC_PROFILE_ID_MISSING) .",
								Computed:    true,
							},
						},
					},
					"last_parent": dsschema.StringAttribute{
						Description: "Last Parent: JsonIgnore(value = true) .",
						Computed:    true,
					},
					"parent": dsschema.StringAttribute{
						Description: "Parent: JsonIgnore(value = true) .",
						Computed:    true,
					},
					"passive_mode": dsschema.SingleNestedAttribute{
						Description: "The PassiveMode param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"enable":true, "peer_ip_dynamic":true} forceNew:map[string]bool(nil)
							"enable": dsschema.BoolAttribute{
								Description: "Enable.",
								Computed:    true,
							},
							"peer_ip_dynamic": dsschema.BoolAttribute{
								Description: "Peer Ip Dynamic.",
								Computed:    true,
							},
						},
					},
					"peer": dsschema.SingleNestedAttribute{
						Description: "The Peer param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"hostname":true, "ip_addresses":true} forceNew:map[string]bool(nil)
							"hostname": dsschema.StringAttribute{
								Description: "Hostname: Size(max = 256, INVALID_PEER_HOSTNAME, min = 0) .",
								Computed:    true,
							},
							"ip_addresses": dsschema.ListAttribute{
								Description: "Ip Addresses.",
								Computed:    true,
								ElementType: types.StringType,
							},
						},
					},
					"service_endpoint_id": dsschema.StringAttribute{
						Description: "Service Endpoint Id.",
						Computed:    true,
					},
					"type": dsschema.StringAttribute{
						Description: "Type: ValidateEnum(enumClass = classOf[ServiceLinkType], INVALID_SERVICE_LINK_TYPE, nullAllowed = false) . String must be one of these: `\"IPSEC\"`, `\"GRE\"`, `\"GENEVE\"`.",
						Computed:    true,
					},
				},
			},
			"site_id": dsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
			},
			"site_wan_interface_ids": dsschema.ListAttribute{
				Description: "Site Wan Interface Ids.",
				Computed:    true,
				ElementType: types.StringType,
			},
			"static_arp_configs": dsschema.ListNestedAttribute{
				Description: "Static Arp Configs: Size(max = 32, error = INTERFACE_CONFIG_STATIC_ARP_EXCEEDS_LIMIT: Invalid interface configuration. Static ARP entries exceed the supported limit of 16, min = 0) .",
				Computed:    true,
				NestedObject: dsschema.NestedAttributeObject{
					Attributes: map[string]dsschema.Attribute{
						// inputs:map[string]bool{} outputs:map[string]bool{"ipv4_address":true, "mac_address":true} forceNew:map[string]bool(nil)
						"ipv4_address": dsschema.StringAttribute{
							Description: "Ipv4 Address: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, INVALID_IP, type = IP) .",
							Computed:    true,
						},
						"mac_address": dsschema.StringAttribute{
							Description: "Mac Address: MACAddress(error = INTERFACE_CONFIG_INVALID_MAC: Invalid mac address syntax.) .",
							Computed:    true,
						},
					},
				},
			},
			"sub_interface": dsschema.SingleNestedAttribute{
				Description: "The SubInterface param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"vlan_id":true} forceNew:map[string]bool(nil)
					"vlan_id": dsschema.Int64Attribute{
						Description: "Vlan Id.",
						Computed:    true,
					},
				},
			},
			"switch_port_config": dsschema.SingleNestedAttribute{
				Description: "The SwitchPortConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"access_vlan_id":true, "bpdu_guard_enabled":true, "forward_fast_enabled":true, "native_vlan_id":true, "root_guard_enabled":true, "storm_control_config":true, "stp_port_cost":true, "stp_port_enabled":true, "stp_port_priority":true, "trunk_vlans":true, "vlan_mode":true, "voice_vlan_id":true} forceNew:map[string]bool(nil)
					"access_vlan_id": dsschema.Int64Attribute{
						Description: "Access Vlan Id.",
						Computed:    true,
					},
					"bpdu_guard_enabled": dsschema.BoolAttribute{
						Description: "Bpdu Guard Enabled.",
						Computed:    true,
					},
					"forward_fast_enabled": dsschema.BoolAttribute{
						Description: "Forward Fast Enabled.",
						Computed:    true,
					},
					"native_vlan_id": dsschema.Int64Attribute{
						Description: "Native Vlan Id.",
						Computed:    true,
					},
					"root_guard_enabled": dsschema.BoolAttribute{
						Description: "Root Guard Enabled.",
						Computed:    true,
					},
					"storm_control_config": dsschema.SingleNestedAttribute{
						Description: "The StormControlConfig param.",
						Computed:    true,
						Attributes: map[string]dsschema.Attribute{
							// inputs:map[string]bool{} outputs:map[string]bool{"broadcast_threshold":true, "multicast_threshold":true, "unicast_threshold":true} forceNew:map[string]bool(nil)
							"broadcast_threshold": dsschema.Int64Attribute{
								Description: "Broadcast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_BROADCAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control broadcast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
								Computed:    true,
							},
							"multicast_threshold": dsschema.Int64Attribute{
								Description: "Multicast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_MULTICAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control multicast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
								Computed:    true,
							},
							"unicast_threshold": dsschema.Int64Attribute{
								Description: "Unicast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_UNICAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control unicast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
								Computed:    true,
							},
						},
					},
					"stp_port_cost": dsschema.Int64Attribute{
						Description: "Stp Port Cost: Range(max = 65535L, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_STP_COST: Invalid interface configuration. Switch port interface config is invalid. Invalid STP cost. Valid values are 1-65535., min = 1L) .",
						Computed:    true,
					},
					"stp_port_enabled": dsschema.BoolAttribute{
						Description: "Stp Port Enabled.",
						Computed:    true,
					},
					"stp_port_priority": dsschema.Int64Attribute{
						Description: "Stp Port Priority: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_STP_PRIORITY: Invalid interface configuration. Switch port interface config is invalid. Invalid stp priority. Valid values are 0-240 and must be a multiple of 16., min = 0) .",
						Computed:    true,
					},
					"trunk_vlans": dsschema.ListAttribute{
						Description: "Trunk Vlans: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 0, listMaxSize = 32, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_TRUNK_VLANS: Invalid interface configuration. Switch port config is invalid.  VLAN mode is trunk. Max trunk VLANs allowed is 32 and no duplicates are allowed., noTrim = false, regex = , required = false) .",
						Computed:    true,
						ElementType: types.StringType,
					},
					"vlan_mode": dsschema.StringAttribute{
						Description: "Vlan Mode: ValidateEnum(enumClass = classOf[VlanMode], error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_VLAN_MODE: Invalid interface configuration. Switch port interface config is invalid. Invalid vlan mode. Valid values are access and trunk., nullAllowed = false) . String must be one of these: `\"access\"`, `\"trunk\"`.",
						Computed:    true,
					},
					"voice_vlan_id": dsschema.Int64Attribute{
						Description: "Voice Vlan Id.",
						Computed:    true,
					},
				},
			},
			"tags": dsschema.ListAttribute{
				Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = INVALID_TAG: Maximum 10 Unique tags of length 1024 each are allowed, noTrim = false, regex = [^,\\\\s]+, required = false) .",
				Computed:    true,
				ElementType: types.StringType,
			},
			"tfid": dsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
			},
			"type": dsschema.StringAttribute{
				Description: "Type: ValidateEnum(enumClass = classOf[InterfaceType], error = INVALID_PORT_TYPE: Port type is not valid., nullAllowed = false) .",
				Computed:    true,
			},
			"used_for": dsschema.StringAttribute{
				Description: "Used For: ValidateEnum(enumClass = classOf[UsedFor], error = INTERFACE_CONFIG_INVALID_USEDFOR_VALUE: Invalid used for value specified.The allowed values are public,private_wan,lan,none, nullAllowed = false) .",
				Computed:    true,
			},
			"vlan_config": dsschema.SingleNestedAttribute{
				Description: "The VlanConfig param.",
				Computed:    true,
				Attributes: map[string]dsschema.Attribute{
					// inputs:map[string]bool{} outputs:map[string]bool{"mstp_instance":true, "vlan_id":true, "voice_enabled":true} forceNew:map[string]bool(nil)
					"mstp_instance": dsschema.Int64Attribute{
						Description: "Mstp Instance.",
						Computed:    true,
					},
					"vlan_id": dsschema.Int64Attribute{
						Description: "Vlan Id.",
						Computed:    true,
					},
					"voice_enabled": dsschema.BoolAttribute{
						Description: "Voice Enabled.",
						Computed:    true,
					},
				},
			},
			"vrf_context_id": dsschema.StringAttribute{
				Description: "Vrf Context Id.",
				Computed:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (d *interfaceDataSource) Configure(_ context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	d.client = req.ProviderData.(*sdwan.Client)
}

// Read performs Read for the struct.
func (d *interfaceDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var state interfaceDsModel
	resp.Diagnostics.Append(req.Config.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing data source read", map[string]any{
		"data_source_name":            "prismasdwan_interface",
		"terraform_provider_function": "Read",
		"site_id":                     state.SiteId.ValueString(),
		"element_id":                  state.ElementId.ValueString(),
		"interface_id":                state.InterfaceId.ValueString(),
	})

	// Prepare to run the command.
	svc := aSvnUVk.NewClient(d.client)

	// Prepare input for the API endpoint.
	input := aSvnUVk.ReadInput{}

	input.SiteId = StringValue(state.SiteId)

	input.ElementId = StringValue(state.ElementId)

	input.InterfaceId = StringValue(state.InterfaceId)

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error reading config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	idBuilder.WriteString(input.ElementId)

	idBuilder.WriteString(IdSeparator)
	idBuilder.WriteString(input.InterfaceId)

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.AdminUp = types.BoolPointerValue(ans.AdminUp)

	if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = nil
	} else {
		state.AttachedLanNetworks = make([]interfaceDsModel_irQawLY_Config, 0, len(ans.AttachedLanNetworks))
		for _, var0 := range ans.AttachedLanNetworks {
			var1 := interfaceDsModel_irQawLY_Config{}

			var1.LanNetworkId = types.StringPointerValue(var0.LanNetworkId)

			var1.VlanId = types.Int64PointerValue(var0.VlanId)
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, var1)
		}
	}

	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &interfaceDsModel_mIAatvm_Config{}

		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)

		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)

		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}

	var2, var3 := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = var2
	resp.Diagnostics.Append(var3.Errors()...)

	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &interfaceDsModel_zGfKFAQ_Config{}

		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)

		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)

		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)

		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}

	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &interfaceDsModel_eumQbRC_Config{}

		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &interfaceDsModel_aeWshcf_Config{}

			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)

			state.CellularConfig.ApnConfig.Authentication = types.StringValue(ans.CellularConfig.ApnConfig.Authentication)

			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)

			state.CellularConfig.ApnConfig.Password = types.StringPointerValue(ans.CellularConfig.ApnConfig.Password)

			state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(ans.CellularConfig.ApnConfig.PasswordEncrypted)

			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}

		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)

		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)

		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)

		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}

	state.Description = types.StringPointerValue(ans.Description)

	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)

	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &interfaceDsModel_mCcgFKg_Config{}

		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)

		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &interfaceDsModel_tOChZgD_Config{}

			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)

			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)

			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.DhcpRelay.Option82.ReforwardingPolicy)

			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}

		var4, var5 := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = var4
		resp.Diagnostics.Append(var5.Errors()...)

		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}

	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)

	state.Etag = types.Int64PointerValue(ans.Etag)

	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &interfaceDsModel_ehJLagQ_Config{}

		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)

		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &interfaceDsModel_ujXZojh_Config{}

			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)

			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)

			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)

			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)

			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)

			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)

			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)

			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)

			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)

			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)

			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)

			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)

			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)

			state.EthernetPort.PortId.SiteId = types.StringValue(ans.EthernetPort.PortId.SiteId)
		}

		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)

		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}

	state.Id = types.StringPointerValue(ans.Id)

	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)

	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)

	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &interfaceDsModel_wsoFfyL_Config{}

		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &interfaceDsModel_rKcwmLF_Config{}

			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)

			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}

		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &interfaceDsModel_mTuoPRe_Config{}

			var6, var7 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = var6
			resp.Diagnostics.Append(var7.Errors()...)

			var8, var9 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = var8
			resp.Diagnostics.Append(var9.Errors()...)
		}

		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &interfaceDsModel_cvAyZuw_Config{}

			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)

			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)

			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}

		if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = nil
		} else {
			state.Ipv4Config.Routes = make([]interfaceDsModel_bBEnHsN_Config, 0, len(ans.Ipv4Config.Routes))
			for _, var10 := range ans.Ipv4Config.Routes {
				var11 := interfaceDsModel_bBEnHsN_Config{}

				var11.Destination = types.StringPointerValue(var10.Destination)

				var11.Via = types.StringPointerValue(var10.Via)
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, var11)
			}
		}

		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &interfaceDsModel_nfiOrAO_Config{}

			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}

		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &interfaceDsModel_bMGDwkY_Config{}

		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &interfaceDsModel_juuQHdk_Config{}

			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)

			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}

		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &interfaceDsModel_mTuoPRe_Config{}

			var12, var13 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = var12
			resp.Diagnostics.Append(var13.Errors()...)

			var14, var15 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = var14
			resp.Diagnostics.Append(var15.Errors()...)
		}

		if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = nil
		} else {
			state.Ipv6Config.Routes = make([]interfaceDsModel_bBEnHsN_Config, 0, len(ans.Ipv6Config.Routes))
			for _, var16 := range ans.Ipv6Config.Routes {
				var17 := interfaceDsModel_bBEnHsN_Config{}

				var17.Destination = types.StringPointerValue(var16.Destination)

				var17.Via = types.StringPointerValue(var16.Via)
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, var17)
			}
		}

		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &interfaceDsModel_lIDFRUy_Config{}

			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)

			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}

		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}

	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)

	state.MacAddress = types.StringPointerValue(ans.MacAddress)

	state.Mtu = types.Int64PointerValue(ans.Mtu)

	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &interfaceDsModel_zLXjrfn_Config{}

		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)

		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}

	state.Name = types.StringPointerValue(ans.Name)

	state.NatAddress = types.StringPointerValue(ans.NatAddress)

	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)

	if len(ans.NatPools) == 0 {
		state.NatPools = nil
	} else {
		state.NatPools = make([]interfaceDsModel_alJfwdK_Config, 0, len(ans.NatPools))
		for _, var18 := range ans.NatPools {
			var19 := interfaceDsModel_alJfwdK_Config{}

			if len(var18.Ipv4Ranges) == 0 {
				var19.Ipv4Ranges = nil
			} else {
				var19.Ipv4Ranges = make([]interfaceDsModel_xYviIkG_Config, 0, len(var18.Ipv4Ranges))
				for _, var20 := range var18.Ipv4Ranges {
					var21 := interfaceDsModel_xYviIkG_Config{}

					var21.End = types.StringValue(var20.End)

					var21.Start = types.StringValue(var20.Start)
					var19.Ipv4Ranges = append(var19.Ipv4Ranges, var21)
				}
			}

			var19.NatPoolId = types.StringPointerValue(var18.NatPoolId)
			state.NatPools = append(state.NatPools, var19)
		}
	}

	state.NatPort = types.Int64PointerValue(ans.NatPort)

	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)

	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Parent = types.StringPointerValue(ans.Parent)

	state.PeerBypasspairWanPortType = types.StringValue(ans.PeerBypasspairWanPortType)

	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)

	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)

	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &interfaceDsModel_yxxGXUe_Config{}

		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)

		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)

		state.PppoeConfig.Password = types.StringPointerValue(ans.PppoeConfig.Password)

		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)

		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)

		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}

	state.Scope = types.StringValue(ans.Scope)

	if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = nil
	} else {
		state.SecondaryIpConfigs = make([]interfaceDsModel_jmyEuEW_Config, 0, len(ans.SecondaryIpConfigs))
		for _, var22 := range ans.SecondaryIpConfigs {
			var23 := interfaceDsModel_jmyEuEW_Config{}

			var23.Ipv4Address = types.StringPointerValue(var22.Ipv4Address)

			var23.Scope = types.StringPointerValue(var22.Scope)
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, var23)
		}
	}

	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &interfaceDsModel_obJkRYB_Config{}

		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &interfaceDsModel_suSmnCD_Config{}

			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)

			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)

			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}

		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &interfaceDsModel_nnsRzDg_Config{}

			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &interfaceDsModel_xdEvbZX_Config{}

				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &interfaceDsModel_mKyPIKy_Config{}

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &interfaceDsModel_qSUpByF_Config{}

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

					var24, var25 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet = var24
					resp.Diagnostics.Append(var25.Errors()...)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

					var26, var27 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet = var26
					resp.Diagnostics.Append(var27.Errors()...)
				}
			}

			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}

		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)

		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)

		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &interfaceDsModel_wiUYuNU_Config{}

			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)

			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}

		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &interfaceDsModel_pjMVEcr_Config{}

			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)

			var28, var29 := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = var28
			resp.Diagnostics.Append(var29.Errors()...)
		}

		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)

		state.ServiceLinkConfig.Type = types.StringValue(ans.ServiceLinkConfig.Type)
	}

	var30, var31 := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = var30
	resp.Diagnostics.Append(var31.Errors()...)

	if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = nil
	} else {
		state.StaticArpConfigs = make([]interfaceDsModel_pWDbfYi_Config, 0, len(ans.StaticArpConfigs))
		for _, var32 := range ans.StaticArpConfigs {
			var33 := interfaceDsModel_pWDbfYi_Config{}

			var33.Ipv4Address = types.StringPointerValue(var32.Ipv4Address)

			var33.MacAddress = types.StringPointerValue(var32.MacAddress)
			state.StaticArpConfigs = append(state.StaticArpConfigs, var33)
		}
	}

	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &interfaceDsModel_jEYlBbY_Config{}

		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}

	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &interfaceDsModel_kslrKbF_Config{}

		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)

		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)

		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)

		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)

		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)

		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &interfaceDsModel_qhDZEMT_Config{}

			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)

			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}

		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)

		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)

		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)

		var34, var35 := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = var34
		resp.Diagnostics.Append(var35.Errors()...)

		state.SwitchPortConfig.VlanMode = types.StringValue(ans.SwitchPortConfig.VlanMode)

		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}

	var36, var37 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var36
	resp.Diagnostics.Append(var37.Errors()...)

	state.Type = types.StringValue(ans.Type)

	state.UsedFor = types.StringValue(ans.UsedFor)

	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &interfaceDsModel_aCdiNxV_Config{}

		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)

		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)

		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Resource.
var (
	_ resource.Resource                = &interfaceResource{}
	_ resource.ResourceWithConfigure   = &interfaceResource{}
	_ resource.ResourceWithImportState = &interfaceResource{}
)

func NewInterfaceResource() resource.Resource {
	return &interfaceResource{}
}

type interfaceResource struct {
	client *sdwan.Client
}

// interfaceRsModel is the model.
type interfaceRsModel struct {
	Tfid types.String `tfsdk:"tfid"`

	// Input.
	AdminUp                    types.Bool                        `tfsdk:"admin_up"`
	AttachedLanNetworks        []interfaceRsModel_irQawLY_Config `tfsdk:"attached_lan_networks"`
	AuthenticationConfig       *interfaceRsModel_mIAatvm_Config  `tfsdk:"authentication_config"`
	BoundInterfaces            types.List                        `tfsdk:"bound_interfaces"`
	BypassPair                 *interfaceRsModel_zGfKFAQ_Config  `tfsdk:"bypass_pair"`
	CellularConfig             *interfaceRsModel_eumQbRC_Config  `tfsdk:"cellular_config"`
	Description                types.String                      `tfsdk:"description"`
	DevicemgmtPolicysetstackId types.String                      `tfsdk:"devicemgmt_policysetstack_id"`
	DhcpRelay                  *interfaceRsModel_mCcgFKg_Config  `tfsdk:"dhcp_relay"`
	DirectedBroadcast          types.Bool                        `tfsdk:"directed_broadcast"`
	ElementId                  types.String                      `tfsdk:"element_id"`
	Etag                       types.Int64                       `tfsdk:"etag"`
	EthernetPort               *interfaceRsModel_ehJLagQ_Config  `tfsdk:"ethernet_port"`
	Id                         types.String                      `tfsdk:"id"`
	InterfaceProfileId         types.String                      `tfsdk:"interface_profile_id"`
	IpfixcollectorcontextId    types.String                      `tfsdk:"ipfixcollectorcontext_id"`
	IpfixfiltercontextId       types.String                      `tfsdk:"ipfixfiltercontext_id"`
	Ipv4Config                 *interfaceRsModel_wsoFfyL_Config  `tfsdk:"ipv4_config"`
	Ipv6Config                 *interfaceRsModel_bMGDwkY_Config  `tfsdk:"ipv6_config"`
	LldpEnabled                types.Bool                        `tfsdk:"lldp_enabled"`
	MacAddress                 types.String                      `tfsdk:"mac_address"`
	Mtu                        types.Int64                       `tfsdk:"mtu"`
	MulticastConfig            *interfaceRsModel_zLXjrfn_Config  `tfsdk:"multicast_config"`
	Name                       types.String                      `tfsdk:"name"`
	NatAddress                 types.String                      `tfsdk:"nat_address"`
	NatAddressV6               types.String                      `tfsdk:"nat_address_v6"`
	NatPools                   []interfaceRsModel_alJfwdK_Config `tfsdk:"nat_pools"`
	NatPort                    types.Int64                       `tfsdk:"nat_port"`
	NatPortV6                  types.Int64                       `tfsdk:"nat_port_v6"`
	NatZoneId                  types.String                      `tfsdk:"nat_zone_id"`
	NetworkContextId           types.String                      `tfsdk:"network_context_id"`
	Parent                     types.String                      `tfsdk:"parent"`
	PeerBypasspairWanPortType  types.String                      `tfsdk:"peer_bypasspair_wan_port_type"`
	PoeEnabled                 types.Bool                        `tfsdk:"poe_enabled"`
	PowerUsageThreshold        types.Int64                       `tfsdk:"power_usage_threshold"`
	PppoeConfig                *interfaceRsModel_yxxGXUe_Config  `tfsdk:"pppoe_config"`
	Scope                      types.String                      `tfsdk:"scope"`
	SecondaryIpConfigs         []interfaceRsModel_jmyEuEW_Config `tfsdk:"secondary_ip_configs"`
	ServiceLinkConfig          *interfaceRsModel_obJkRYB_Config  `tfsdk:"service_link_config"`
	SiteId                     types.String                      `tfsdk:"site_id"`
	SiteWanInterfaceIds        types.List                        `tfsdk:"site_wan_interface_ids"`
	StaticArpConfigs           []interfaceRsModel_pWDbfYi_Config `tfsdk:"static_arp_configs"`
	SubInterface               *interfaceRsModel_jEYlBbY_Config  `tfsdk:"sub_interface"`
	SwitchPortConfig           *interfaceRsModel_kslrKbF_Config  `tfsdk:"switch_port_config"`
	Tags                       types.List                        `tfsdk:"tags"`
	Type                       types.String                      `tfsdk:"type"`
	UsedFor                    types.String                      `tfsdk:"used_for"`
	VlanConfig                 *interfaceRsModel_aCdiNxV_Config  `tfsdk:"vlan_config"`
	VrfContextId               types.String                      `tfsdk:"vrf_context_id"`

	// Output.
	// omit input: admin_up
	// omit input: attached_lan_networks
	// omit input: authentication_config
	// omit input: bound_interfaces
	// omit input: bypass_pair
	// omit input: cellular_config
	// omit input: description
	// omit input: devicemgmt_policysetstack_id
	// omit input: dhcp_relay
	// omit input: directed_broadcast
	// omit input: etag
	// omit input: ethernet_port
	// omit input: id
	// omit input: interface_profile_id
	// omit input: ipfixcollectorcontext_id
	// omit input: ipfixfiltercontext_id
	// omit input: ipv4_config
	// omit input: ipv6_config
	// omit input: lldp_enabled
	// omit input: mac_address
	// omit input: mtu
	// omit input: multicast_config
	// omit input: name
	// omit input: nat_address
	// omit input: nat_address_v6
	// omit input: nat_pools
	// omit input: nat_port
	// omit input: nat_port_v6
	// omit input: nat_zone_id
	// omit input: network_context_id
	// omit input: parent
	// omit input: peer_bypasspair_wan_port_type
	// omit input: poe_enabled
	// omit input: power_usage_threshold
	// omit input: pppoe_config
	// omit input: scope
	// omit input: secondary_ip_configs
	// omit input: service_link_config
	// omit input: site_wan_interface_ids
	// omit input: static_arp_configs
	// omit input: sub_interface
	// omit input: switch_port_config
	// omit input: tags
	// omit input: type
	// omit input: used_for
	// omit input: vlan_config
	// omit input: vrf_context_id
}

type interfaceRsModel_irQawLY_Config struct {
	LanNetworkId types.String `tfsdk:"lan_network_id"`
	VlanId       types.Int64  `tfsdk:"vlan_id"`
}

type interfaceRsModel_mIAatvm_Config struct {
	FallbackRetryCount      types.Int64  `tfsdk:"fallback_retry_count"`
	Mode                    types.String `tfsdk:"mode"`
	ReauthenticationTimeout types.Int64  `tfsdk:"reauthentication_timeout"`
}

type interfaceRsModel_zGfKFAQ_Config struct {
	Lan                 types.String `tfsdk:"lan"`
	LanStatePropagation types.Bool   `tfsdk:"lan_state_propagation"`
	UseRelay            types.Bool   `tfsdk:"use_relay"`
	Wan                 types.String `tfsdk:"wan"`
}

type interfaceRsModel_eumQbRC_Config struct {
	ApnConfig           *interfaceRsModel_aeWshcf_Config `tfsdk:"apn_config"`
	ApnprofileId        types.String                     `tfsdk:"apnprofile_id"`
	AutoApn             types.Bool                       `tfsdk:"auto_apn"`
	ParentModuleId      types.String                     `tfsdk:"parent_module_id"`
	ParentSimSlotNumber types.Int64                      `tfsdk:"parent_sim_slot_number"`
}

type interfaceRsModel_aeWshcf_Config struct {
	Apn               types.String `tfsdk:"apn"`
	Authentication    types.String `tfsdk:"authentication"`
	ClearPassword     types.Bool   `tfsdk:"clear_password"`
	Password          types.String `tfsdk:"password"`
	PasswordEncrypted types.String `tfsdk:"password_encrypted"`
	UserName          types.String `tfsdk:"user_name"`
}

type interfaceRsModel_mCcgFKg_Config struct {
	Enabled         types.Bool                       `tfsdk:"enabled"`
	Option82        *interfaceRsModel_tOChZgD_Config `tfsdk:"option_82"`
	ServerIps       types.List                       `tfsdk:"server_ips"`
	SourceInterface types.String                     `tfsdk:"source_interface"`
}

type interfaceRsModel_tOChZgD_Config struct {
	CircuitId          types.String `tfsdk:"circuit_id"`
	Enabled            types.Bool   `tfsdk:"enabled"`
	ReforwardingPolicy types.String `tfsdk:"reforwarding_policy"`
	RemoteId           types.String `tfsdk:"remote_id"`
}

type interfaceRsModel_ehJLagQ_Config struct {
	FullDuplex types.Bool                       `tfsdk:"full_duplex"`
	PortId     *interfaceRsModel_ujXZojh_Config `tfsdk:"port_id"`
	PortName   types.String                     `tfsdk:"port_name"`
	Speed      types.Int64                      `tfsdk:"speed"`
}

type interfaceRsModel_ujXZojh_Config struct {
	Connector          types.String `tfsdk:"connector"`
	Device             types.String `tfsdk:"device"`
	Disabled           types.Bool   `tfsdk:"disabled"`
	DisabledReason     types.String `tfsdk:"disabled_reason"`
	ElementId          types.String `tfsdk:"element_id"`
	Id                 types.String `tfsdk:"id"`
	Inactive           types.Bool   `tfsdk:"inactive"`
	InactiveReason     types.String `tfsdk:"inactive_reason"`
	MaxMtu             types.Int64  `tfsdk:"max_mtu"`
	MaxSpeed           types.Int64  `tfsdk:"max_speed"`
	Name               types.String `tfsdk:"name"`
	OriginalMacAddress types.String `tfsdk:"original_mac_address"`
	Region             types.String `tfsdk:"region"`
	SiteId             types.String `tfsdk:"site_id"`
}

type interfaceRsModel_wsoFfyL_Config struct {
	DhcpConfig   *interfaceRsModel_rKcwmLF_Config  `tfsdk:"dhcp_config"`
	DnsV4Config  *interfaceRsModel_mTuoPRe_Config  `tfsdk:"dns_v4_config"`
	PppoeConfig  *interfaceRsModel_cvAyZuw_Config  `tfsdk:"pppoe_config"`
	Routes       []interfaceRsModel_bBEnHsN_Config `tfsdk:"routes"`
	StaticConfig *interfaceRsModel_nfiOrAO_Config  `tfsdk:"static_config"`
	Type         types.String                      `tfsdk:"type"`
}

type interfaceRsModel_rKcwmLF_Config struct {
	ClientId types.String `tfsdk:"client_id"`
	Hostname types.String `tfsdk:"hostname"`
}

type interfaceRsModel_mTuoPRe_Config struct {
	NameServers types.List `tfsdk:"name_servers"`
	Search      types.List `tfsdk:"search"`
}

type interfaceRsModel_cvAyZuw_Config struct {
	ChapPasswd types.String `tfsdk:"chap_passwd"`
	ChapUser   types.String `tfsdk:"chap_user"`
	SetRoute   types.Bool   `tfsdk:"set_route"`
}

type interfaceRsModel_bBEnHsN_Config struct {
	Destination types.String `tfsdk:"destination"`
	Via         types.String `tfsdk:"via"`
}

type interfaceRsModel_nfiOrAO_Config struct {
	Address types.String `tfsdk:"address"`
}

type interfaceRsModel_bMGDwkY_Config struct {
	DhcpConfig   *interfaceRsModel_juuQHdk_Config  `tfsdk:"dhcp_config"`
	DnsV6Config  *interfaceRsModel_mTuoPRe_Config  `tfsdk:"dns_v6_config"`
	Routes       []interfaceRsModel_bBEnHsN_Config `tfsdk:"routes"`
	StaticConfig *interfaceRsModel_lIDFRUy_Config  `tfsdk:"static_config"`
	Type         types.String                      `tfsdk:"type"`
}

type interfaceRsModel_juuQHdk_Config struct {
	ClientId types.String `tfsdk:"client_id"`
	Hostname types.String `tfsdk:"hostname"`
}

type interfaceRsModel_lIDFRUy_Config struct {
	Address                  types.String `tfsdk:"address"`
	EnablePrefixDistribution types.Bool   `tfsdk:"enable_prefix_distribution"`
}

type interfaceRsModel_zLXjrfn_Config struct {
	IgmpVersion      types.String `tfsdk:"igmp_version"`
	MulticastEnabled types.Bool   `tfsdk:"multicast_enabled"`
}

type interfaceRsModel_alJfwdK_Config struct {
	Ipv4Ranges []interfaceRsModel_xYviIkG_Config `tfsdk:"ipv4_ranges"`
	NatPoolId  types.String                      `tfsdk:"nat_pool_id"`
}

type interfaceRsModel_xYviIkG_Config struct {
	End   types.String `tfsdk:"end"`
	Start types.String `tfsdk:"start"`
}

type interfaceRsModel_yxxGXUe_Config struct {
	HostUniq          types.String `tfsdk:"host_uniq"`
	IpAddressType     types.String `tfsdk:"ip_address_type"`
	Password          types.String `tfsdk:"password"`
	ReconnectionDelay types.Int64  `tfsdk:"reconnection_delay"`
	ServiceName       types.String `tfsdk:"service_name"`
	Username          types.String `tfsdk:"username"`
}

type interfaceRsModel_jmyEuEW_Config struct {
	Ipv4Address types.String `tfsdk:"ipv4_address"`
	Scope       types.String `tfsdk:"scope"`
}

type interfaceRsModel_obJkRYB_Config struct {
	GreConfig         *interfaceRsModel_suSmnCD_Config `tfsdk:"gre_config"`
	IpsecConfig       *interfaceRsModel_nnsRzDg_Config `tfsdk:"ipsec_config"`
	LastParent        types.String                     `tfsdk:"last_parent"`
	Parent            types.String                     `tfsdk:"parent"`
	PassiveMode       *interfaceRsModel_wiUYuNU_Config `tfsdk:"passive_mode"`
	Peer              *interfaceRsModel_pjMVEcr_Config `tfsdk:"peer"`
	ServiceEndpointId types.String                     `tfsdk:"service_endpoint_id"`
	Type              types.String                     `tfsdk:"type"`
}

type interfaceRsModel_suSmnCD_Config struct {
	Csum               types.Bool  `tfsdk:"csum"`
	KeepaliveEnable    types.Bool  `tfsdk:"keepalive_enable"`
	KeepaliveFailCount types.Int64 `tfsdk:"keepalive_fail_count"`
	KeepaliveInterval  types.Int64 `tfsdk:"keepalive_interval"`
}

type interfaceRsModel_nnsRzDg_Config struct {
	Authentication *interfaceRsModel_xdEvbZX_Config `tfsdk:"authentication"`
	IpsecProfileId types.String                     `tfsdk:"ipsec_profile_id"`
}

type interfaceRsModel_xdEvbZX_Config struct {
	Certificate                        types.String                     `tfsdk:"certificate"`
	CertificateProfileId               types.String                     `tfsdk:"certificate_profile_id"`
	Comment                            types.String                     `tfsdk:"comment"`
	Ikev1Params                        *interfaceRsModel_mKyPIKy_Config `tfsdk:"ikev1_params"`
	LocalCaCertificate                 types.String                     `tfsdk:"local_ca_certificate"`
	LocalId                            types.String                     `tfsdk:"local_id"`
	LocalIdCustom                      types.String                     `tfsdk:"local_id_custom"`
	LocalPaCertificateId               types.String                     `tfsdk:"local_pa_certificate_id"`
	PaMasterKeyId                      types.String                     `tfsdk:"pa_master_key_id"`
	Passphrase                         types.String                     `tfsdk:"passphrase"`
	PassphraseEncrypted                types.String                     `tfsdk:"passphrase_encrypted"`
	PeerIdCheck                        types.String                     `tfsdk:"peer_id_check"`
	PermitPeerIdMismatch               types.Bool                       `tfsdk:"permit_peer_id_mismatch"`
	PrivateKey                         types.String                     `tfsdk:"private_key"`
	PrivateKeyEncrypted                types.String                     `tfsdk:"private_key_encrypted"`
	RemoteCaCertificate                types.String                     `tfsdk:"remote_ca_certificate"`
	RemoteId                           types.String                     `tfsdk:"remote_id"`
	Secret                             types.String                     `tfsdk:"secret"`
	SecretEncrypted                    types.String                     `tfsdk:"secret_encrypted"`
	SecretHash                         types.String                     `tfsdk:"secret_hash"`
	StrictValidationPeerExtendedKeyUse types.Bool                       `tfsdk:"strict_validation_peer_extended_key_use"`
	Type                               types.String                     `tfsdk:"type"`
	X509Objects                        *interfaceRsModel_qSUpByF_Config `tfsdk:"x509_objects"`
}

type interfaceRsModel_mKyPIKy_Config struct {
	XauthId              types.String `tfsdk:"xauth_id"`
	XauthSecret          types.String `tfsdk:"xauth_secret"`
	XauthSecretEncrypted types.String `tfsdk:"xauth_secret_encrypted"`
	XauthSecretHash      types.String `tfsdk:"xauth_secret_hash"`
	XauthType            types.String `tfsdk:"xauth_type"`
}

type interfaceRsModel_qSUpByF_Config struct {
	CertHolder          types.Bool   `tfsdk:"cert_holder"`
	Certificate         types.String `tfsdk:"certificate"`
	IsLocalCaCertSet    types.Bool   `tfsdk:"is_local_ca_cert_set"`
	IsRemoteCaCertSet   types.Bool   `tfsdk:"is_remote_ca_cert_set"`
	KeyPair             types.Bool   `tfsdk:"key_pair"`
	LocalCaCertificate  types.String `tfsdk:"local_ca_certificate"`
	LocalCaCertsSet     types.List   `tfsdk:"local_ca_certs_set"`
	Passphrase          types.String `tfsdk:"passphrase"`
	PrivateKey          types.String `tfsdk:"private_key"`
	RemoteCaCertificate types.String `tfsdk:"remote_ca_certificate"`
	RemoteCaCertsSet    types.List   `tfsdk:"remote_ca_certs_set"`
}

type interfaceRsModel_wiUYuNU_Config struct {
	Enable        types.Bool `tfsdk:"enable"`
	PeerIpDynamic types.Bool `tfsdk:"peer_ip_dynamic"`
}

type interfaceRsModel_pjMVEcr_Config struct {
	Hostname    types.String `tfsdk:"hostname"`
	IpAddresses types.List   `tfsdk:"ip_addresses"`
}

type interfaceRsModel_pWDbfYi_Config struct {
	Ipv4Address types.String `tfsdk:"ipv4_address"`
	MacAddress  types.String `tfsdk:"mac_address"`
}

type interfaceRsModel_jEYlBbY_Config struct {
	VlanId types.Int64 `tfsdk:"vlan_id"`
}

type interfaceRsModel_kslrKbF_Config struct {
	AccessVlanId       types.Int64                      `tfsdk:"access_vlan_id"`
	BpduGuardEnabled   types.Bool                       `tfsdk:"bpdu_guard_enabled"`
	ForwardFastEnabled types.Bool                       `tfsdk:"forward_fast_enabled"`
	NativeVlanId       types.Int64                      `tfsdk:"native_vlan_id"`
	RootGuardEnabled   types.Bool                       `tfsdk:"root_guard_enabled"`
	StormControlConfig *interfaceRsModel_qhDZEMT_Config `tfsdk:"storm_control_config"`
	StpPortCost        types.Int64                      `tfsdk:"stp_port_cost"`
	StpPortEnabled     types.Bool                       `tfsdk:"stp_port_enabled"`
	StpPortPriority    types.Int64                      `tfsdk:"stp_port_priority"`
	TrunkVlans         types.List                       `tfsdk:"trunk_vlans"`
	VlanMode           types.String                     `tfsdk:"vlan_mode"`
	VoiceVlanId        types.Int64                      `tfsdk:"voice_vlan_id"`
}

type interfaceRsModel_qhDZEMT_Config struct {
	BroadcastThreshold types.Int64 `tfsdk:"broadcast_threshold"`
	MulticastThreshold types.Int64 `tfsdk:"multicast_threshold"`
	UnicastThreshold   types.Int64 `tfsdk:"unicast_threshold"`
}

type interfaceRsModel_aCdiNxV_Config struct {
	MstpInstance types.Int64 `tfsdk:"mstp_instance"`
	VlanId       types.Int64 `tfsdk:"vlan_id"`
	VoiceEnabled types.Bool  `tfsdk:"voice_enabled"`
}

// Metadata returns the data source type name.
func (r *interfaceResource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_interface"
}

// Schema defines the schema for this data source.
func (r *interfaceResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = rsschema.Schema{
		Description: "Retrieves a config item.",

		Attributes: map[string]rsschema.Attribute{
			// inputs:map[string]bool{"admin_up":true, "attached_lan_networks":true, "authentication_config":true, "bound_interfaces":true, "bypass_pair":true, "cellular_config":true, "description":true, "devicemgmt_policysetstack_id":true, "dhcp_relay":true, "directed_broadcast":true, "element_id":true, "etag":true, "ethernet_port":true, "id":true, "interface_profile_id":true, "ipfixcollectorcontext_id":true, "ipfixfiltercontext_id":true, "ipv4_config":true, "ipv6_config":true, "lldp_enabled":true, "mac_address":true, "mtu":true, "multicast_config":true, "name":true, "nat_address":true, "nat_address_v6":true, "nat_pools":true, "nat_port":true, "nat_port_v6":true, "nat_zone_id":true, "network_context_id":true, "parent":true, "peer_bypasspair_wan_port_type":true, "poe_enabled":true, "power_usage_threshold":true, "pppoe_config":true, "scope":true, "secondary_ip_configs":true, "service_link_config":true, "site_id":true, "site_wan_interface_ids":true, "static_arp_configs":true, "sub_interface":true, "switch_port_config":true, "tags":true, "type":true, "used_for":true, "vlan_config":true, "vrf_context_id":true} outputs:map[string]bool{"admin_up":true, "attached_lan_networks":true, "authentication_config":true, "bound_interfaces":true, "bypass_pair":true, "cellular_config":true, "description":true, "devicemgmt_policysetstack_id":true, "dhcp_relay":true, "directed_broadcast":true, "etag":true, "ethernet_port":true, "id":true, "interface_profile_id":true, "ipfixcollectorcontext_id":true, "ipfixfiltercontext_id":true, "ipv4_config":true, "ipv6_config":true, "lldp_enabled":true, "mac_address":true, "mtu":true, "multicast_config":true, "name":true, "nat_address":true, "nat_address_v6":true, "nat_pools":true, "nat_port":true, "nat_port_v6":true, "nat_zone_id":true, "network_context_id":true, "parent":true, "peer_bypasspair_wan_port_type":true, "poe_enabled":true, "power_usage_threshold":true, "pppoe_config":true, "scope":true, "secondary_ip_configs":true, "service_link_config":true, "site_wan_interface_ids":true, "static_arp_configs":true, "sub_interface":true, "switch_port_config":true, "tags":true, "tfid":true, "type":true, "used_for":true, "vlan_config":true, "vrf_context_id":true} forceNew:map[string]bool{"element_id":true, "site_id":true}
			"admin_up": rsschema.BoolAttribute{
				Description: "Admin Up.",
				Optional:    true,
			},
			"attached_lan_networks": rsschema.ListNestedAttribute{
				Description: "Attached Lan Networks: Valid .",
				Optional:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"lan_network_id":true, "vlan_id":true} outputs:map[string]bool{"lan_network_id":true, "vlan_id":true} forceNew:map[string]bool(nil)
						"lan_network_id": rsschema.StringAttribute{
							Description: "Lan Network Id.",
							Optional:    true,
						},
						"vlan_id": rsschema.Int64Attribute{
							Description: "Vlan Id: Range(max = 4095L, error = INVALID_VLANID: VLAN ID should be between 0 and 4095., min = 0L) .",
							Optional:    true,
						},
					},
				},
			},
			"authentication_config": rsschema.SingleNestedAttribute{
				Description: "The AuthenticationConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"fallback_retry_count":true, "mode":true, "reauthentication_timeout":true} outputs:map[string]bool{"fallback_retry_count":true, "mode":true, "reauthentication_timeout":true} forceNew:map[string]bool(nil)
					"fallback_retry_count": rsschema.Int64Attribute{
						Description: "Fallback Retry Count.",
						Optional:    true,
					},
					"mode": rsschema.StringAttribute{
						Description: "Mode. String must be one of these: `\"none\"`, `\"dot1x\"`, `\"macauth\"`, `\"dot1x-to-macauth-fallback\"`.",
						Optional:    true,
						Validators: []validator.String{
							stringvalidator.OneOf("none", "dot1x", "macauth", "dot1x-to-macauth-fallback"),
						},
					},
					"reauthentication_timeout": rsschema.Int64Attribute{
						Description: "Reauthentication Timeout.",
						Optional:    true,
					},
				},
			},
			"bound_interfaces": rsschema.ListAttribute{
				Description: "Bound Interfaces.",
				Optional:    true,
				ElementType: types.StringType,
			},
			"bypass_pair": rsschema.SingleNestedAttribute{
				Description: "The BypassPair param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"lan":true, "lan_state_propagation":true, "use_relay":true, "wan":true} outputs:map[string]bool{"lan":true, "lan_state_propagation":true, "use_relay":true, "wan":true} forceNew:map[string]bool(nil)
					"lan": rsschema.StringAttribute{
						Description: "Lan.",
						Optional:    true,
					},
					"lan_state_propagation": rsschema.BoolAttribute{
						Description: "Lan State Propagation.",
						Optional:    true,
					},
					"use_relay": rsschema.BoolAttribute{
						Description: "Use Relay.",
						Optional:    true,
					},
					"wan": rsschema.StringAttribute{
						Description: "Wan.",
						Optional:    true,
					},
				},
			},
			"cellular_config": rsschema.SingleNestedAttribute{
				Description: "The CellularConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"apn_config":true, "apnprofile_id":true, "auto_apn":true, "parent_module_id":true, "parent_sim_slot_number":true} outputs:map[string]bool{"apn_config":true, "apnprofile_id":true, "auto_apn":true, "parent_module_id":true, "parent_sim_slot_number":true} forceNew:map[string]bool(nil)
					"apn_config": rsschema.SingleNestedAttribute{
						Description: "The ApnConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"apn":true, "authentication":true, "clear_password":true, "password":true, "password_encrypted":true, "user_name":true} outputs:map[string]bool{"apn":true, "authentication":true, "clear_password":true, "password":true, "password_encrypted":true, "user_name":true} forceNew:map[string]bool(nil)
							"apn": rsschema.StringAttribute{
								Description: "Apn: Size(max = 100, error = CELLULAR_INTERFACE_CONFIG_APN_CONFIG_PROFILE_NAME_INVALID: Invalid cellular interface config. APN name is invalid. APN name allowed max length is 100. Valid characters are alphanumeric, hyphen (-), and period (.). Must begin and end with an alphanumeric character., min = 0) .",
								Optional:    true,
							},
							"authentication": rsschema.StringAttribute{
								Description: "Authentication: ValidateEnum(enumClass = classOf[APNAuthentication], message = INVALID_APN_AUTHENTICATION, nullAllowed = false) . String must be one of these: `\"none\"`, `\"pap\"`, `\"chap\"`, `\"pap_or_chap\"`.",
								Required:    true,
								Validators: []validator.String{
									stringvalidator.OneOf("none", "pap", "chap", "pap_or_chap"),
								},
							},
							"clear_password": rsschema.BoolAttribute{
								Description: "Clear Password.",
								Optional:    true,
							},
							"password": rsschema.StringAttribute{
								Description: "Password.",
								Optional:    true,
							},
							"password_encrypted": rsschema.StringAttribute{
								Description: "Password Encrypted: JsonIgnore(value = true) .",
								Optional:    true,
							},
							"user_name": rsschema.StringAttribute{
								Description: "User Name: Size(max = 100, error = CELLULAR_INTERFACE_CONFIG_APN_CONFIG_USERNAME_INVALID: Invalid cellular interface config. APN username is invalid. APN username allowed max length is 100., min = 0) .",
								Optional:    true,
							},
						},
					},
					"apnprofile_id": rsschema.StringAttribute{
						Description: "Apnprofile Id.",
						Optional:    true,
					},
					"auto_apn": rsschema.BoolAttribute{
						Description: "Auto Apn.",
						Optional:    true,
					},
					"parent_module_id": rsschema.StringAttribute{
						Description: "Parent Module Id.",
						Optional:    true,
					},
					"parent_sim_slot_number": rsschema.Int64Attribute{
						Description: "Parent Sim Slot Number.",
						Optional:    true,
					},
				},
			},
			"description": rsschema.StringAttribute{
				Description: "Description: Size(max = 256, error = DESCRIPTION_EXCEEDS_LIMIT: Description length exceeds limit, min = 0) .",
				Optional:    true,
			},
			"devicemgmt_policysetstack_id": rsschema.StringAttribute{
				Description: "Devicemgmt Policysetstack Id: Digits(fraction = 0, integer = 30, INVALID_DEVICEMGMT_POLICYSETSTACK_ID) .",
				Optional:    true,
			},
			"dhcp_relay": rsschema.SingleNestedAttribute{
				Description: "The DhcpRelay param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} outputs:map[string]bool{"enabled":true, "option_82":true, "server_ips":true, "source_interface":true} forceNew:map[string]bool(nil)
					"enabled": rsschema.BoolAttribute{
						Description: "Enabled.",
						Optional:    true,
					},
					"option_82": rsschema.SingleNestedAttribute{
						Description: "The Option82 param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} outputs:map[string]bool{"circuit_id":true, "enabled":true, "reforwarding_policy":true, "remote_id":true} forceNew:map[string]bool(nil)
							"circuit_id": rsschema.StringAttribute{
								Description: "Circuit Id: Size(max = 255, error = DHCPRELAY_CIRCUIT_ID_EXCEEDS_LIMIT: Option 82 Circuid ID exceeds maximum length, min = 0) .",
								Optional:    true,
							},
							"enabled": rsschema.BoolAttribute{
								Description: "Enabled.",
								Optional:    true,
							},
							"reforwarding_policy": rsschema.StringAttribute{
								Description: "Reforwarding Policy: ValidateEnum(enumClass = classOf[DHCPRelayReforwardingPolicy], error = INVALID_DHCP_RELAY_REFWDING_POLICY: Option 82 invalid reforwarding policy, nullAllowed = false) . String must be one of these: `\"REPLACE\"`, `\"KEEP\"`, `\"APPEND\"`, `\"DROP\"`.",
								Required:    true,
								Validators: []validator.String{
									stringvalidator.OneOf("REPLACE", "KEEP", "APPEND", "DROP"),
								},
							},
							"remote_id": rsschema.StringAttribute{
								Description: "Remote Id: Size(max = 255, error = DHCPRELAY_REMOTE_ID_EXCEEDS_LIMIT: Option 82 Remote ID exceeds maximum length, min = 0) .",
								Optional:    true,
							},
						},
					},
					"server_ips": rsschema.ListAttribute{
						Description: "Server Ips: ListIPAddress(bcast = DENY, listMaxSize = 0, error = INTERFACE_CONFIG_INVALID_DHCP_RELAY_LIST: DHCP Servers IP specified in the list are invalid, required = true, type = IP) Size(max = 16, error = INTERFACE_CONFIG_DHCP_RELAY_LIST_EXCEEDS_LIMIT: DHCP Servers specified in the list exceeds maximum limit, min = 0) .",
						Optional:    true,
						ElementType: types.StringType,
					},
					"source_interface": rsschema.StringAttribute{
						Description: "Source Interface.",
						Optional:    true,
					},
				},
			},
			"directed_broadcast": rsschema.BoolAttribute{
				Description: "Directed Broadcast.",
				Optional:    true,
			},
			"element_id": rsschema.StringAttribute{
				Description: "Element Id.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"etag": rsschema.Int64Attribute{
				Description: "Entity tag for the resource.",
				Optional:    true,
				Computed:    true,
			},
			"ethernet_port": rsschema.SingleNestedAttribute{
				Description: "The EthernetPort param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"full_duplex":true, "port_id":true, "port_name":true, "speed":true} outputs:map[string]bool{"full_duplex":true, "port_id":true, "port_name":true, "speed":true} forceNew:map[string]bool(nil)
					"full_duplex": rsschema.BoolAttribute{
						Description: "Full Duplex.",
						Optional:    true,
					},
					"port_id": rsschema.SingleNestedAttribute{
						Description: "The PortId param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"connector":true, "device":true, "disabled":true, "disabled_reason":true, "element_id":true, "id":true, "inactive":true, "inactive_reason":true, "max_mtu":true, "max_speed":true, "name":true, "original_mac_address":true, "region":true, "site_id":true} outputs:map[string]bool{"connector":true, "device":true, "disabled":true, "disabled_reason":true, "element_id":true, "id":true, "inactive":true, "inactive_reason":true, "max_mtu":true, "max_speed":true, "name":true, "original_mac_address":true, "region":true, "site_id":true} forceNew:map[string]bool(nil)
							"connector": rsschema.StringAttribute{
								Description: "Connector Type.",
								Optional:    true,
							},
							"device": rsschema.StringAttribute{
								Description: "Device Name.",
								Optional:    true,
							},
							"disabled": rsschema.BoolAttribute{
								Description: "Disabled.",
								Optional:    true,
							},
							"disabled_reason": rsschema.StringAttribute{
								Description: "Disabled Reason: Size(max = 5000, DISABLED_REASON_INVALID_0001, min = 0) .",
								Optional:    true,
							},
							"element_id": rsschema.StringAttribute{
								Description: "Element Id.",
								Optional:    true,
							},
							"id": rsschema.StringAttribute{
								Description: "The Id param.",
								Optional:    true,
								Computed:    true,
							},
							"inactive": rsschema.BoolAttribute{
								Description: "Inactive.",
								Optional:    true,
							},
							"inactive_reason": rsschema.StringAttribute{
								Description: "Inactive Reason: Size(max = 5000, INACTIVE_REASON_INVALID_0001, min = 0) .",
								Optional:    true,
							},
							"max_mtu": rsschema.Int64Attribute{
								Description: "Max Mtu.",
								Optional:    true,
							},
							"max_speed": rsschema.Int64Attribute{
								Description: "Max Speed.",
								Optional:    true,
							},
							"name": rsschema.StringAttribute{
								Description: "Name.",
								Optional:    true,
							},
							"original_mac_address": rsschema.StringAttribute{
								Description: "Orig Mac Addr.",
								Optional:    true,
							},
							"region": rsschema.StringAttribute{
								Description: "Region.",
								Optional:    true,
							},
							"site_id": rsschema.StringAttribute{
								Description: "Site Id: Digits(fraction = 0, integer = 50, SITEID_INVALID) NotNull .",
								Required:    true,
							},
						},
					},
					"port_name": rsschema.StringAttribute{
						Description: "Port Name.",
						Optional:    true,
					},
					"speed": rsschema.Int64Attribute{
						Description: "Speed.",
						Optional:    true,
					},
				},
			},
			"id": rsschema.StringAttribute{
				Description: "Id.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"interface_profile_id": rsschema.StringAttribute{
				Description: "Interface Profile Id.",
				Optional:    true,
			},
			"ipfixcollectorcontext_id": rsschema.StringAttribute{
				Description: "Ipfixcollectorcontext Id.",
				Optional:    true,
			},
			"ipfixfiltercontext_id": rsschema.StringAttribute{
				Description: "Ipfixfiltercontext Id.",
				Optional:    true,
			},
			"ipv4_config": rsschema.SingleNestedAttribute{
				Description: "The Ipv4Config param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"dhcp_config":true, "dns_v4_config":true, "pppoe_config":true, "routes":true, "static_config":true, "type":true} outputs:map[string]bool{"dhcp_config":true, "dns_v4_config":true, "pppoe_config":true, "routes":true, "static_config":true, "type":true} forceNew:map[string]bool(nil)
					"dhcp_config": rsschema.SingleNestedAttribute{
						Description: "The DhcpConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"client_id":true, "hostname":true} outputs:map[string]bool{"client_id":true, "hostname":true} forceNew:map[string]bool(nil)
							"client_id": rsschema.StringAttribute{
								Description: "Client Id.",
								Optional:    true,
							},
							"hostname": rsschema.StringAttribute{
								Description: "Hostname.",
								Optional:    true,
							},
						},
					},
					"dns_v4_config": rsschema.SingleNestedAttribute{
						Description: "The DnsV4Config param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"name_servers":true, "search":true} outputs:map[string]bool{"name_servers":true, "search":true} forceNew:map[string]bool(nil)
							"name_servers": rsschema.ListAttribute{
								Description: "Name Servers.",
								Optional:    true,
								ElementType: types.StringType,
							},
							"search": rsschema.ListAttribute{
								Description: "Search.",
								Optional:    true,
								ElementType: types.StringType,
							},
						},
					},
					"pppoe_config": rsschema.SingleNestedAttribute{
						Description: "The PppoeConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"chap_passwd":true, "chap_user":true, "set_route":true} outputs:map[string]bool{"chap_passwd":true, "chap_user":true, "set_route":true} forceNew:map[string]bool(nil)
							"chap_passwd": rsschema.StringAttribute{
								Description: "Chap Passwd.",
								Optional:    true,
							},
							"chap_user": rsschema.StringAttribute{
								Description: "Chap User.",
								Optional:    true,
							},
							"set_route": rsschema.BoolAttribute{
								Description: "Set Route.",
								Optional:    true,
							},
						},
					},
					"routes": rsschema.ListNestedAttribute{
						Description: "Routes: Valid .",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"destination":true, "via":true} outputs:map[string]bool{"destination":true, "via":true} forceNew:map[string]bool(nil)
								"destination": rsschema.StringAttribute{
									Description: "Destination.",
									Optional:    true,
								},
								"via": rsschema.StringAttribute{
									Description: "Via.",
									Optional:    true,
								},
							},
						},
					},
					"static_config": rsschema.SingleNestedAttribute{
						Description: "The StaticConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"address":true} outputs:map[string]bool{"address":true} forceNew:map[string]bool(nil)
							"address": rsschema.StringAttribute{
								Description: "Address.",
								Optional:    true,
							},
						},
					},
					"type": rsschema.StringAttribute{
						Description: "Type: Size(max = 12, error = INTERFACE_CONFIG_INVALID_IP_TYPE: IP Type is not valid., min = 0) .",
						Optional:    true,
					},
				},
			},
			"ipv6_config": rsschema.SingleNestedAttribute{
				Description: "The Ipv6Config param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"dhcp_config":true, "dns_v6_config":true, "routes":true, "static_config":true, "type":true} outputs:map[string]bool{"dhcp_config":true, "dns_v6_config":true, "routes":true, "static_config":true, "type":true} forceNew:map[string]bool(nil)
					"dhcp_config": rsschema.SingleNestedAttribute{
						Description: "The DhcpConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"client_id":true, "hostname":true} outputs:map[string]bool{"client_id":true, "hostname":true} forceNew:map[string]bool(nil)
							"client_id": rsschema.StringAttribute{
								Description: "Client Id.",
								Optional:    true,
							},
							"hostname": rsschema.StringAttribute{
								Description: "Hostname.",
								Optional:    true,
							},
						},
					},
					"dns_v6_config": rsschema.SingleNestedAttribute{
						Description: "The DnsV6Config param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"name_servers":true, "search":true} outputs:map[string]bool{"name_servers":true, "search":true} forceNew:map[string]bool(nil)
							"name_servers": rsschema.ListAttribute{
								Description: "Name Servers.",
								Optional:    true,
								ElementType: types.StringType,
							},
							"search": rsschema.ListAttribute{
								Description: "Search.",
								Optional:    true,
								ElementType: types.StringType,
							},
						},
					},
					"routes": rsschema.ListNestedAttribute{
						Description: "Routes.",
						Optional:    true,
						NestedObject: rsschema.NestedAttributeObject{
							Attributes: map[string]rsschema.Attribute{
								// inputs:map[string]bool{"destination":true, "via":true} outputs:map[string]bool{"destination":true, "via":true} forceNew:map[string]bool(nil)
								"destination": rsschema.StringAttribute{
									Description: "Destination.",
									Optional:    true,
								},
								"via": rsschema.StringAttribute{
									Description: "Via.",
									Optional:    true,
								},
							},
						},
					},
					"static_config": rsschema.SingleNestedAttribute{
						Description: "The StaticConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"address":true, "enable_prefix_distribution":true} outputs:map[string]bool{"address":true, "enable_prefix_distribution":true} forceNew:map[string]bool(nil)
							"address": rsschema.StringAttribute{
								Description: "Address.",
								Optional:    true,
							},
							"enable_prefix_distribution": rsschema.BoolAttribute{
								Description: "Enable Prefix Distribution.",
								Optional:    true,
							},
						},
					},
					"type": rsschema.StringAttribute{
						Description: "Type.",
						Optional:    true,
					},
				},
			},
			"lldp_enabled": rsschema.BoolAttribute{
				Description: "Lldp Enabled.",
				Optional:    true,
			},
			"mac_address": rsschema.StringAttribute{
				Description: "Mac Address: Pattern(error = INTERFACE_CONFIG_INVALID_MAC: Invalid mac address syntax., regexp = ([0-9a-f]{2}[:]){5}([0-9a-f]{2})) .",
				Optional:    true,
			},
			"mtu": rsschema.Int64Attribute{
				Description: "Mtu: Range(max = 9216L, error = INTERFACE_CONFIG_INVALID_MTU: MTU is not in the valid range., min = 0L) .",
				Optional:    true,
			},
			"multicast_config": rsschema.SingleNestedAttribute{
				Description: "The MulticastConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"igmp_version":true, "multicast_enabled":true} outputs:map[string]bool{"igmp_version":true, "multicast_enabled":true} forceNew:map[string]bool(nil)
					"igmp_version": rsschema.StringAttribute{
						Description: "Igmp Version. String must be one of these: `\"IGMPV2\"`, `\"IGMPV3\"`.",
						Optional:    true,
						Validators: []validator.String{
							stringvalidator.OneOf("IGMPV2", "IGMPV3"),
						},
					},
					"multicast_enabled": rsschema.BoolAttribute{
						Description: "Multicast Enabled.",
						Optional:    true,
					},
				},
			},
			"name": rsschema.StringAttribute{
				Description: "Name: Size(max = 128, error = NAME_EXCEEDS_LIMIT: Name of the resource exceeds limit., min = 0) .",
				Optional:    true,
			},
			"nat_address": rsschema.StringAttribute{
				Description: "Nat Address: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = INVALID_NAT_IP: NAT IP address is invalid., type = IP) .",
				Optional:    true,
			},
			"nat_address_v6": rsschema.StringAttribute{
				Description: "Nat Address V6: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = INVALID_IPV6_NAT: IPv6 NAT address is invalid., type = IPV6) .",
				Optional:    true,
			},
			"nat_pools": rsschema.ListNestedAttribute{
				Description: "Nat Pools: Valid .",
				Optional:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"ipv4_ranges":true, "nat_pool_id":true} outputs:map[string]bool{"ipv4_ranges":true, "nat_pool_id":true} forceNew:map[string]bool(nil)
						"ipv4_ranges": rsschema.ListNestedAttribute{
							Description: "Ipv4 Ranges: Size(max = 4, error = INTERFACE_CONFIG_INVALID_NAT_POOL_IP_RANGE: Minimum 1 and maximum 4 nat pool IP ranges can be specified., min = 1) Valid .",
							Optional:    true,
							NestedObject: rsschema.NestedAttributeObject{
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"end":true, "start":true} outputs:map[string]bool{"end":true, "start":true} forceNew:map[string]bool(nil)
									"end": rsschema.StringAttribute{
										Description: "End: NotNull(error = END_IP_MISSING: End ip is not specified in range.) IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = END_IP_INVALID_IN_RANGE: Invalid end ip specified in range., type = IP) .",
										Required:    true,
									},
									"start": rsschema.StringAttribute{
										Description: "Start: NotNull(error = START_IP_MISSING: Start ip is not specified in range.) IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, error = START_IP_INVALID_IN_RANGE: Invalid start ip specified in range., type = IP) .",
										Required:    true,
									},
								},
							},
						},
						"nat_pool_id": rsschema.StringAttribute{
							Description: "Nat Pool Id: Digits(fraction = 0, integer = 30, INVALID_NAT_POLICYPOOL_ID) .",
							Optional:    true,
						},
					},
				},
			},
			"nat_port": rsschema.Int64Attribute{
				Description: "Nat Port: Range(max = 65535L, error = INTERFACE_CONFIG_INVALID_PORT: LAN,WAN,Internet bypass ports cannot be part of logical interface groups., min = 0L) .",
				Optional:    true,
			},
			"nat_port_v6": rsschema.Int64Attribute{
				Description: "Nat Port V6: Range(max = 65535L, error = INTERFACE_CONFIG_INVALID_PORT: LAN,WAN,Internet bypass ports cannot be part of logical interface groups., min = 0L) .",
				Optional:    true,
			},
			"nat_zone_id": rsschema.StringAttribute{
				Description: "Nat Zone Id: Digits(fraction = 0, integer = 30, INVALID_NAT_POLICY_ZONE) .",
				Optional:    true,
			},
			"network_context_id": rsschema.StringAttribute{
				Description: "Network Context Id.",
				Optional:    true,
			},
			"parent": rsschema.StringAttribute{
				Description: "Parent.",
				Optional:    true,
			},
			"peer_bypasspair_wan_port_type": rsschema.StringAttribute{
				Description: "Peer Bypasspair Wan Port Type: ValidateEnum(enumClass = classOf[PortExtensionType], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"none\"`, `\"cellular\"`.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("none", "cellular"),
				},
			},
			"poe_enabled": rsschema.BoolAttribute{
				Description: "Poe Enabled.",
				Optional:    true,
			},
			"power_usage_threshold": rsschema.Int64Attribute{
				Description: "Power Usage Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_POE_POWER_USAGE_THRESHOLD: Invalid Interface configuration. Invalid PoE alarm threshold value {}. Valid values are in the range 50-100., min = 0) .",
				Optional:    true,
			},
			"pppoe_config": rsschema.SingleNestedAttribute{
				Description: "The PppoeConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"host_uniq":true, "ip_address_type":true, "password":true, "reconnection_delay":true, "service_name":true, "username":true} outputs:map[string]bool{"host_uniq":true, "ip_address_type":true, "password":true, "reconnection_delay":true, "service_name":true, "username":true} forceNew:map[string]bool(nil)
					"host_uniq": rsschema.StringAttribute{
						Description: "Host Uniq.",
						Optional:    true,
					},
					"ip_address_type": rsschema.StringAttribute{
						Description: "Ip Address Type.",
						Optional:    true,
					},
					"password": rsschema.StringAttribute{
						Description: "Password.",
						Optional:    true,
					},
					"reconnection_delay": rsschema.Int64Attribute{
						Description: "Reconnection Delay.",
						Optional:    true,
					},
					"service_name": rsschema.StringAttribute{
						Description: "Service Name.",
						Optional:    true,
					},
					"username": rsschema.StringAttribute{
						Description: "Username.",
						Optional:    true,
					},
				},
			},
			"scope": rsschema.StringAttribute{
				Description: "Scope: ValidateEnum(enumClass = classOf[NetworkScope], message = Invalid enum string., nullAllowed = false) . String must be one of these: `\"GLOBAL\"`, `\"LOCAL\"`.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("GLOBAL", "LOCAL"),
				},
			},
			"secondary_ip_configs": rsschema.ListNestedAttribute{
				Description: "Secondary Ip Configs.",
				Optional:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"ipv4_address":true, "scope":true} outputs:map[string]bool{"ipv4_address":true, "scope":true} forceNew:map[string]bool(nil)
						"ipv4_address": rsschema.StringAttribute{
							Description: "Ipv4 Address.",
							Optional:    true,
						},
						"scope": rsschema.StringAttribute{
							Description: "Scope.",
							Optional:    true,
						},
					},
				},
			},
			"service_link_config": rsschema.SingleNestedAttribute{
				Description: "The ServiceLinkConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"gre_config":true, "ipsec_config":true, "last_parent":true, "parent":true, "passive_mode":true, "peer":true, "service_endpoint_id":true, "type":true} outputs:map[string]bool{"gre_config":true, "ipsec_config":true, "last_parent":true, "parent":true, "passive_mode":true, "peer":true, "service_endpoint_id":true, "type":true} forceNew:map[string]bool(nil)
					"gre_config": rsschema.SingleNestedAttribute{
						Description: "The GreConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"csum":true, "keepalive_enable":true, "keepalive_fail_count":true, "keepalive_interval":true} outputs:map[string]bool{"csum":true, "keepalive_enable":true, "keepalive_fail_count":true, "keepalive_interval":true} forceNew:map[string]bool(nil)
							"csum": rsschema.BoolAttribute{
								Description: "Csum.",
								Optional:    true,
							},
							"keepalive_enable": rsschema.BoolAttribute{
								Description: "Keepalive Enable.",
								Optional:    true,
							},
							"keepalive_fail_count": rsschema.Int64Attribute{
								Description: "Keepalive Fail Count: Range(max = 10L, error = INTERFACE_CONFIG_SERVICE_LINK_INVALID_GRE_KEEPALIVE_FAIL_COUNT: Keep alive fail count should be in range 1 to 10, min = 1L) .",
								Optional:    true,
							},
							"keepalive_interval": rsschema.Int64Attribute{
								Description: "Keepalive Interval: Range(max = 30L, error = INTERFACE_CONFIG_SERVICE_LINK_INVALID_GRE_KEEPALIVE_INTERVAL: Keep alive interval should be in range 3 to 30, min = 3L) .",
								Optional:    true,
							},
						},
					},
					"ipsec_config": rsschema.SingleNestedAttribute{
						Description: "The IpsecConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"authentication":true, "ipsec_profile_id":true} outputs:map[string]bool{"authentication":true, "ipsec_profile_id":true} forceNew:map[string]bool(nil)
							"authentication": rsschema.SingleNestedAttribute{
								Description: "The Authentication param.",
								Optional:    true,
								Attributes: map[string]rsschema.Attribute{
									// inputs:map[string]bool{"certificate":true, "certificate_profile_id":true, "comment":true, "ikev1_params":true, "local_ca_certificate":true, "local_id":true, "local_id_custom":true, "local_pa_certificate_id":true, "pa_master_key_id":true, "passphrase":true, "passphrase_encrypted":true, "peer_id_check":true, "permit_peer_id_mismatch":true, "private_key":true, "private_key_encrypted":true, "remote_ca_certificate":true, "remote_id":true, "secret":true, "secret_encrypted":true, "secret_hash":true, "strict_validation_peer_extended_key_use":true, "type":true, "x509Objects":true} outputs:map[string]bool{"certificate":true, "certificate_profile_id":true, "comment":true, "ikev1_params":true, "local_ca_certificate":true, "local_id":true, "local_id_custom":true, "local_pa_certificate_id":true, "pa_master_key_id":true, "passphrase":true, "passphrase_encrypted":true, "peer_id_check":true, "permit_peer_id_mismatch":true, "private_key":true, "private_key_encrypted":true, "remote_ca_certificate":true, "remote_id":true, "secret":true, "secret_encrypted":true, "secret_hash":true, "strict_validation_peer_extended_key_use":true, "type":true, "x509Objects":true} forceNew:map[string]bool(nil)
									"certificate": rsschema.StringAttribute{
										Description: "Certificate.",
										Optional:    true,
									},
									"certificate_profile_id": rsschema.StringAttribute{
										Description: "Certificate Profile Id.",
										Optional:    true,
									},
									"comment": rsschema.StringAttribute{
										Description: "Comment.",
										Optional:    true,
									},
									"ikev1_params": rsschema.SingleNestedAttribute{
										Description: "The Ikev1Params param.",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"xauth_id":true, "xauth_secret":true, "xauth_secret_encrypted":true, "xauth_secret_hash":true, "xauth_type":true} outputs:map[string]bool{"xauth_id":true, "xauth_secret":true, "xauth_secret_encrypted":true, "xauth_secret_hash":true, "xauth_type":true} forceNew:map[string]bool(nil)
											"xauth_id": rsschema.StringAttribute{
												Description: "Xauth Id.",
												Optional:    true,
											},
											"xauth_secret": rsschema.StringAttribute{
												Description: "Xauth Secret: Length(max = 128, error = IPSECCONFIG_INVALID_XAUTH_SECRET_LEN: Invalid extended authentication secret length.Should be between 4-128., min = 4) .",
												Optional:    true,
											},
											"xauth_secret_encrypted": rsschema.StringAttribute{
												Description: "Xauth Secret Encrypted: JsonIgnore(value = true) .",
												Optional:    true,
											},
											"xauth_secret_hash": rsschema.StringAttribute{
												Description: "Xauth Secret Hash: JsonIgnore(value = true) .",
												Optional:    true,
											},
											"xauth_type": rsschema.StringAttribute{
												Description: "Xauth Type: ValidateEnum(enumClass = classOf[IKEXAuthType], error = IPSECCONFIG_INVALID_XAUTH_TYPE: Invalid extended authentication type specified.Valid type are secret or none., nullAllowed = false) . String must be one of these: `\"NONE\"`, `\"SECRET\"`.",
												Required:    true,
												Validators: []validator.String{
													stringvalidator.OneOf("NONE", "SECRET"),
												},
											},
										},
									},
									"local_ca_certificate": rsschema.StringAttribute{
										Description: "Local Ca Certificate.",
										Optional:    true,
									},
									"local_id": rsschema.StringAttribute{
										Description: "Local Id: ValidateEnum(enumClass = classOf[IPSECLocalIdType], error = IPSECCONFIG_INVALID_LOCAL_ID_TYPE: Invalid local id type.Should be either hostname, dn, local_ip or custom, nullAllowed = false) . String must be one of these: `\"LOCAL_IP\"`, `\"DN\"`, `\"HOSTNAME\"`, `\"CUSTOM\"`, `\"NONE\"`.",
										Required:    true,
										Validators: []validator.String{
											stringvalidator.OneOf("LOCAL_IP", "DN", "HOSTNAME", "CUSTOM", "NONE"),
										},
									},
									"local_id_custom": rsschema.StringAttribute{
										Description: "Local Id Custom: Length(max = 255, error = IPSECCONFIG_INVALID_LOCAL_ID_LEN: Invalid local id len.Should be between 2-255., min = 2) .",
										Optional:    true,
									},
									"local_pa_certificate_id": rsschema.StringAttribute{
										Description: "Local Pa Certificate Id.",
										Optional:    true,
									},
									"pa_master_key_id": rsschema.StringAttribute{
										Description: "Pa Master Key Id.",
										Optional:    true,
									},
									"passphrase": rsschema.StringAttribute{
										Description: "Passphrase.",
										Optional:    true,
									},
									"passphrase_encrypted": rsschema.StringAttribute{
										Description: "Passphrase Encrypted: JsonIgnore(value = true) .",
										Optional:    true,
									},
									"peer_id_check": rsschema.StringAttribute{
										Description: "Peer Id Check. String must be one of these: `\"EXACT\"`, `\"WILDCARD\"`.",
										Optional:    true,
										Validators: []validator.String{
											stringvalidator.OneOf("EXACT", "WILDCARD"),
										},
									},
									"permit_peer_id_mismatch": rsschema.BoolAttribute{
										Description: "Permit Peer Id Mismatch.",
										Optional:    true,
									},
									"private_key": rsschema.StringAttribute{
										Description: "Private Key.",
										Optional:    true,
									},
									"private_key_encrypted": rsschema.StringAttribute{
										Description: "Private Key Encrypted: JsonIgnore(value = true) .",
										Optional:    true,
									},
									"remote_ca_certificate": rsschema.StringAttribute{
										Description: "Remote Ca Certificate.",
										Optional:    true,
									},
									"remote_id": rsschema.StringAttribute{
										Description: "Remote Id: Length(max = 255, error = IPSECCONFIG_INVALID_REMOTE_ID_LEN: Invalid remote id len.Should be between 2-255., min = 2) .",
										Optional:    true,
									},
									"secret": rsschema.StringAttribute{
										Description: "Secret.",
										Optional:    true,
									},
									"secret_encrypted": rsschema.StringAttribute{
										Description: "Secret Encrypted: JsonIgnore(value = true) .",
										Optional:    true,
									},
									"secret_hash": rsschema.StringAttribute{
										Description: "Secret Hash: JsonIgnore(value = true) .",
										Optional:    true,
									},
									"strict_validation_peer_extended_key_use": rsschema.BoolAttribute{
										Description: "Strict Validation Peer Extended Key Use.",
										Optional:    true,
									},
									"type": rsschema.StringAttribute{
										Description: "Type: ValidateEnum(enumClass = classOf[IPSECAuthenticationType], error = IPSECCONFIG_INVALID_AUTHENTICATION_TYPE: Invalid authentication type specified.Valid type are x509, psk or none., nullAllowed = false) . String must be one of these: `\"NONE\"`, `\"PSK\"`, `\"X509\"`.",
										Required:    true,
										Validators: []validator.String{
											stringvalidator.OneOf("NONE", "PSK", "X509"),
										},
									},
									"x509_objects": rsschema.SingleNestedAttribute{
										Description: "The X509Objects param.",
										Optional:    true,
										Attributes: map[string]rsschema.Attribute{
											// inputs:map[string]bool{"certHolder":true, "certificate":true, "is_local_ca_cert_set":true, "is_remote_ca_cert_set":true, "keyPair":true, "local_ca_certificate":true, "local_ca_certs_set":true, "passphrase":true, "private_key":true, "remote_ca_certificate":true, "remote_ca_certs_set":true} outputs:map[string]bool{"certHolder":true, "certificate":true, "is_local_ca_cert_set":true, "is_remote_ca_cert_set":true, "keyPair":true, "local_ca_certificate":true, "local_ca_certs_set":true, "passphrase":true, "private_key":true, "remote_ca_certificate":true, "remote_ca_certs_set":true} forceNew:map[string]bool(nil)
											"cert_holder": rsschema.BoolAttribute{
												Description: "The CertHolder param. Default: `false`.",
												Optional:    true,
												Computed:    true,
												Default:     booldefault.StaticBool(false),
											},
											"certificate": rsschema.StringAttribute{
												Description: "Certificate.",
												Optional:    true,
											},
											"is_local_ca_cert_set": rsschema.BoolAttribute{
												Description: "Is Local Ca Cert Set.",
												Optional:    true,
											},
											"is_remote_ca_cert_set": rsschema.BoolAttribute{
												Description: "Is Remote Ca Cert Set.",
												Optional:    true,
											},
											"key_pair": rsschema.BoolAttribute{
												Description: "The KeyPair param. Default: `false`.",
												Optional:    true,
												Computed:    true,
												Default:     booldefault.StaticBool(false),
											},
											"local_ca_certificate": rsschema.StringAttribute{
												Description: "Local Ca Certificate.",
												Optional:    true,
											},
											"local_ca_certs_set": rsschema.ListAttribute{
												Description: "Local Ca Certs Set.",
												Optional:    true,
												ElementType: types.BoolType,
											},
											"passphrase": rsschema.StringAttribute{
												Description: "Passphrase.",
												Optional:    true,
											},
											"private_key": rsschema.StringAttribute{
												Description: "Private Key.",
												Optional:    true,
											},
											"remote_ca_certificate": rsschema.StringAttribute{
												Description: "Remote Ca Certificate.",
												Optional:    true,
											},
											"remote_ca_certs_set": rsschema.ListAttribute{
												Description: "Remote Ca Certs Set.",
												Optional:    true,
												ElementType: types.BoolType,
											},
										},
									},
								},
							},
							"ipsec_profile_id": rsschema.StringAttribute{
								Description: "Ipsec Profile Id: Required(IPSEC_PROFILE_ID_MISSING) .",
								Required:    true,
							},
						},
					},
					"last_parent": rsschema.StringAttribute{
						Description: "Last Parent: JsonIgnore(value = true) .",
						Optional:    true,
					},
					"parent": rsschema.StringAttribute{
						Description: "Parent: JsonIgnore(value = true) .",
						Optional:    true,
					},
					"passive_mode": rsschema.SingleNestedAttribute{
						Description: "The PassiveMode param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"enable":true, "peer_ip_dynamic":true} outputs:map[string]bool{"enable":true, "peer_ip_dynamic":true} forceNew:map[string]bool(nil)
							"enable": rsschema.BoolAttribute{
								Description: "Enable.",
								Optional:    true,
							},
							"peer_ip_dynamic": rsschema.BoolAttribute{
								Description: "Peer Ip Dynamic.",
								Optional:    true,
							},
						},
					},
					"peer": rsschema.SingleNestedAttribute{
						Description: "The Peer param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"hostname":true, "ip_addresses":true} outputs:map[string]bool{"hostname":true, "ip_addresses":true} forceNew:map[string]bool(nil)
							"hostname": rsschema.StringAttribute{
								Description: "Hostname: Size(max = 256, INVALID_PEER_HOSTNAME, min = 0) .",
								Optional:    true,
							},
							"ip_addresses": rsschema.ListAttribute{
								Description: "Ip Addresses.",
								Optional:    true,
								ElementType: types.StringType,
							},
						},
					},
					"service_endpoint_id": rsschema.StringAttribute{
						Description: "Service Endpoint Id.",
						Optional:    true,
					},
					"type": rsschema.StringAttribute{
						Description: "Type: ValidateEnum(enumClass = classOf[ServiceLinkType], INVALID_SERVICE_LINK_TYPE, nullAllowed = false) . String must be one of these: `\"IPSEC\"`, `\"GRE\"`, `\"GENEVE\"`.",
						Required:    true,
						Validators: []validator.String{
							stringvalidator.OneOf("IPSEC", "GRE", "GENEVE"),
						},
					},
				},
			},
			"site_id": rsschema.StringAttribute{
				Description: "Site Id.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"site_wan_interface_ids": rsschema.ListAttribute{
				Description: "Site Wan Interface Ids.",
				Optional:    true,
				ElementType: types.StringType,
			},
			"static_arp_configs": rsschema.ListNestedAttribute{
				Description: "Static Arp Configs: Size(max = 32, error = INTERFACE_CONFIG_STATIC_ARP_EXCEEDS_LIMIT: Invalid interface configuration. Static ARP entries exceed the supported limit of 16, min = 0) .",
				Optional:    true,
				NestedObject: rsschema.NestedAttributeObject{
					Attributes: map[string]rsschema.Attribute{
						// inputs:map[string]bool{"ipv4_address":true, "mac_address":true} outputs:map[string]bool{"ipv4_address":true, "mac_address":true} forceNew:map[string]bool(nil)
						"ipv4_address": rsschema.StringAttribute{
							Description: "Ipv4 Address: IPAddress(allowEmpty = true, allowLinkLocal = false, allowNull = true, bcast = DENY, defaultRoute = false, dnsCheck = false, INVALID_IP, type = IP) .",
							Optional:    true,
						},
						"mac_address": rsschema.StringAttribute{
							Description: "Mac Address: MACAddress(error = INTERFACE_CONFIG_INVALID_MAC: Invalid mac address syntax.) .",
							Optional:    true,
						},
					},
				},
			},
			"sub_interface": rsschema.SingleNestedAttribute{
				Description: "The SubInterface param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"vlan_id":true} outputs:map[string]bool{"vlan_id":true} forceNew:map[string]bool(nil)
					"vlan_id": rsschema.Int64Attribute{
						Description: "Vlan Id.",
						Optional:    true,
					},
				},
			},
			"switch_port_config": rsschema.SingleNestedAttribute{
				Description: "The SwitchPortConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"access_vlan_id":true, "bpdu_guard_enabled":true, "forward_fast_enabled":true, "native_vlan_id":true, "root_guard_enabled":true, "storm_control_config":true, "stp_port_cost":true, "stp_port_enabled":true, "stp_port_priority":true, "trunk_vlans":true, "vlan_mode":true, "voice_vlan_id":true} outputs:map[string]bool{"access_vlan_id":true, "bpdu_guard_enabled":true, "forward_fast_enabled":true, "native_vlan_id":true, "root_guard_enabled":true, "storm_control_config":true, "stp_port_cost":true, "stp_port_enabled":true, "stp_port_priority":true, "trunk_vlans":true, "vlan_mode":true, "voice_vlan_id":true} forceNew:map[string]bool(nil)
					"access_vlan_id": rsschema.Int64Attribute{
						Description: "Access Vlan Id.",
						Optional:    true,
					},
					"bpdu_guard_enabled": rsschema.BoolAttribute{
						Description: "Bpdu Guard Enabled.",
						Optional:    true,
					},
					"forward_fast_enabled": rsschema.BoolAttribute{
						Description: "Forward Fast Enabled.",
						Optional:    true,
					},
					"native_vlan_id": rsschema.Int64Attribute{
						Description: "Native Vlan Id.",
						Optional:    true,
					},
					"root_guard_enabled": rsschema.BoolAttribute{
						Description: "Root Guard Enabled.",
						Optional:    true,
					},
					"storm_control_config": rsschema.SingleNestedAttribute{
						Description: "The StormControlConfig param.",
						Optional:    true,
						Attributes: map[string]rsschema.Attribute{
							// inputs:map[string]bool{"broadcast_threshold":true, "multicast_threshold":true, "unicast_threshold":true} outputs:map[string]bool{"broadcast_threshold":true, "multicast_threshold":true, "unicast_threshold":true} forceNew:map[string]bool(nil)
							"broadcast_threshold": rsschema.Int64Attribute{
								Description: "Broadcast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_BROADCAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control broadcast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
								Optional:    true,
							},
							"multicast_threshold": rsschema.Int64Attribute{
								Description: "Multicast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_MULTICAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control multicast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
								Optional:    true,
							},
							"unicast_threshold": rsschema.Int64Attribute{
								Description: "Unicast Threshold: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_INVALID_STORM_CONTROL_UNICAST_THRESHOLD: Invalid interface configuration. Switch port interface storm control unicast threshold value is invalid. Valid value is 0, or range must be [64-1000000] kbps, [64kbps to < 1Mbps in increments of 64kbps], [1Mbps to 100Mbps in increments of 1Mbps], [100Mbps to 1000Mbps in increments of 10Mbps], min = 0) .",
								Optional:    true,
							},
						},
					},
					"stp_port_cost": rsschema.Int64Attribute{
						Description: "Stp Port Cost: Range(max = 65535L, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_STP_COST: Invalid interface configuration. Switch port interface config is invalid. Invalid STP cost. Valid values are 1-65535., min = 1L) .",
						Optional:    true,
					},
					"stp_port_enabled": rsschema.BoolAttribute{
						Description: "Stp Port Enabled.",
						Optional:    true,
					},
					"stp_port_priority": rsschema.Int64Attribute{
						Description: "Stp Port Priority: ValidateDecimal(allowZero = true, increment = 0, max = 0, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_STP_PRIORITY: Invalid interface configuration. Switch port interface config is invalid. Invalid stp priority. Valid values are 0-240 and must be a multiple of 16., min = 0) .",
						Optional:    true,
					},
					"trunk_vlans": rsschema.ListAttribute{
						Description: "Trunk Vlans: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 0, listMaxSize = 32, error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_TRUNK_VLANS: Invalid interface configuration. Switch port config is invalid.  VLAN mode is trunk. Max trunk VLANs allowed is 32 and no duplicates are allowed., noTrim = false, regex = , required = false) .",
						Optional:    true,
						ElementType: types.StringType,
					},
					"vlan_mode": rsschema.StringAttribute{
						Description: "Vlan Mode: ValidateEnum(enumClass = classOf[VlanMode], error = INTERFACE_CONFIG_SWITCH_PORT_INVALID_VLAN_MODE: Invalid interface configuration. Switch port interface config is invalid. Invalid vlan mode. Valid values are access and trunk., nullAllowed = false) . String must be one of these: `\"access\"`, `\"trunk\"`.",
						Required:    true,
						Validators: []validator.String{
							stringvalidator.OneOf("access", "trunk"),
						},
					},
					"voice_vlan_id": rsschema.Int64Attribute{
						Description: "Voice Vlan Id.",
						Optional:    true,
					},
				},
			},
			"tags": rsschema.ListAttribute{
				Description: "Tags: ListString(allowDuplicate = false, allowEmpty = true, allowNull = true, length = 128, listMaxSize = 10, error = INVALID_TAG: Maximum 10 Unique tags of length 1024 each are allowed, noTrim = false, regex = [^,\\\\s]+, required = false) .",
				Optional:    true,
				ElementType: types.StringType,
			},
			"tfid": rsschema.StringAttribute{
				Description: "The Terraform ID.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"type": rsschema.StringAttribute{
				Description: "Type: ValidateEnum(enumClass = classOf[InterfaceType], error = INVALID_PORT_TYPE: Port type is not valid., nullAllowed = false) .",
				Required:    true,
			},
			"used_for": rsschema.StringAttribute{
				Description: "Used For: ValidateEnum(enumClass = classOf[UsedFor], error = INTERFACE_CONFIG_INVALID_USEDFOR_VALUE: Invalid used for value specified.The allowed values are public,private_wan,lan,none, nullAllowed = false) .",
				Required:    true,
			},
			"vlan_config": rsschema.SingleNestedAttribute{
				Description: "The VlanConfig param.",
				Optional:    true,
				Attributes: map[string]rsschema.Attribute{
					// inputs:map[string]bool{"mstp_instance":true, "vlan_id":true, "voice_enabled":true} outputs:map[string]bool{"mstp_instance":true, "vlan_id":true, "voice_enabled":true} forceNew:map[string]bool(nil)
					"mstp_instance": rsschema.Int64Attribute{
						Description: "Mstp Instance.",
						Optional:    true,
					},
					"vlan_id": rsschema.Int64Attribute{
						Description: "Vlan Id.",
						Optional:    true,
					},
					"voice_enabled": rsschema.BoolAttribute{
						Description: "Voice Enabled.",
						Optional:    true,
					},
				},
			},
			"vrf_context_id": rsschema.StringAttribute{
				Description: "Vrf Context Id.",
				Optional:    true,
			},
		},
	}
}

// Configure prepares the struct.
func (r *interfaceResource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	r.client = req.ProviderData.(*sdwan.Client)
}

// Create resource.
func (r *interfaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var state interfaceRsModel
	resp.Diagnostics.Append(req.Plan.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource create", map[string]any{
		"resource_name":               "prismasdwan_interface",
		"terraform_provider_function": "Create",
		"site_id":                     state.SiteId.ValueString(),
		"element_id":                  state.ElementId.ValueString(),
	})

	// Prepare to create the config.
	svc := aSvnUVk.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := aSvnUVk.CreateInput{}

	input.SiteId = StringValue(state.SiteId)

	input.ElementId = StringValue(state.ElementId)
	input.Request = &quvWIWu.Config{}

	input.Request.AdminUp = BoolValueOrNil(state.AdminUp)

	if len(state.AttachedLanNetworks) != 0 {
		input.Request.AttachedLanNetworks = make([]irQawLY.Config, 0, len(state.AttachedLanNetworks))
		for _, var0 := range state.AttachedLanNetworks {
			var var1 irQawLY.Config

			var1.LanNetworkId = StringValueOrNil(var0.LanNetworkId)

			var1.VlanId = Int64ValueOrNil(var0.VlanId)
			input.Request.AttachedLanNetworks = append(input.Request.AttachedLanNetworks, var1)
		}
	}

	if state.AuthenticationConfig != nil {
		input.Request.AuthenticationConfig = &mIAatvm.Config{}

		input.Request.AuthenticationConfig.FallbackRetryCount = Int64ValueOrNil(state.AuthenticationConfig.FallbackRetryCount)

		input.Request.AuthenticationConfig.Mode = StringValueOrNil(state.AuthenticationConfig.Mode)

		input.Request.AuthenticationConfig.ReauthenticationTimeout = Int64ValueOrNil(state.AuthenticationConfig.ReauthenticationTimeout)
	}

	input.Request.BoundInterfaces = ListStringValueOrNil(ctx, state.BoundInterfaces)

	if state.BypassPair != nil {
		input.Request.BypassPair = &zGfKFAQ.Config{}

		input.Request.BypassPair.Lan = StringValueOrNil(state.BypassPair.Lan)

		input.Request.BypassPair.LanStatePropagation = BoolValueOrNil(state.BypassPair.LanStatePropagation)

		input.Request.BypassPair.UseRelay = BoolValueOrNil(state.BypassPair.UseRelay)

		input.Request.BypassPair.Wan = StringValueOrNil(state.BypassPair.Wan)
	}

	if state.CellularConfig != nil {
		input.Request.CellularConfig = &eumQbRC.Config{}

		if state.CellularConfig.ApnConfig != nil {
			input.Request.CellularConfig.ApnConfig = &aeWshcf.Config{}

			input.Request.CellularConfig.ApnConfig.Apn = StringValueOrNil(state.CellularConfig.ApnConfig.Apn)

			input.Request.CellularConfig.ApnConfig.Authentication = StringValue(state.CellularConfig.ApnConfig.Authentication)

			input.Request.CellularConfig.ApnConfig.ClearPassword = BoolValueOrNil(state.CellularConfig.ApnConfig.ClearPassword)

			input.Request.CellularConfig.ApnConfig.Password = StringValueOrNil(state.CellularConfig.ApnConfig.Password)

			input.Request.CellularConfig.ApnConfig.PasswordEncrypted = StringValueOrNil(state.CellularConfig.ApnConfig.PasswordEncrypted)

			input.Request.CellularConfig.ApnConfig.UserName = StringValueOrNil(state.CellularConfig.ApnConfig.UserName)
		}

		input.Request.CellularConfig.ApnprofileId = StringValueOrNil(state.CellularConfig.ApnprofileId)

		input.Request.CellularConfig.AutoApn = BoolValueOrNil(state.CellularConfig.AutoApn)

		input.Request.CellularConfig.ParentModuleId = StringValueOrNil(state.CellularConfig.ParentModuleId)

		input.Request.CellularConfig.ParentSimSlotNumber = Int64ValueOrNil(state.CellularConfig.ParentSimSlotNumber)
	}

	input.Request.Description = StringValueOrNil(state.Description)

	input.Request.DevicemgmtPolicysetstackId = StringValueOrNil(state.DevicemgmtPolicysetstackId)

	if state.DhcpRelay != nil {
		input.Request.DhcpRelay = &mCcgFKg.Config{}

		input.Request.DhcpRelay.Enabled = BoolValueOrNil(state.DhcpRelay.Enabled)

		if state.DhcpRelay.Option82 != nil {
			input.Request.DhcpRelay.Option82 = &tOChZgD.Config{}

			input.Request.DhcpRelay.Option82.CircuitId = StringValueOrNil(state.DhcpRelay.Option82.CircuitId)

			input.Request.DhcpRelay.Option82.Enabled = BoolValueOrNil(state.DhcpRelay.Option82.Enabled)

			input.Request.DhcpRelay.Option82.ReforwardingPolicy = StringValue(state.DhcpRelay.Option82.ReforwardingPolicy)

			input.Request.DhcpRelay.Option82.RemoteId = StringValueOrNil(state.DhcpRelay.Option82.RemoteId)
		}

		input.Request.DhcpRelay.ServerIps = ListStringValueOrNil(ctx, state.DhcpRelay.ServerIps)

		input.Request.DhcpRelay.SourceInterface = StringValueOrNil(state.DhcpRelay.SourceInterface)
	}

	input.Request.DirectedBroadcast = BoolValueOrNil(state.DirectedBroadcast)

	input.Request.Etag = Int64ValueOrNil(state.Etag)

	if state.EthernetPort != nil {
		input.Request.EthernetPort = &ehJLagQ.Config{}

		input.Request.EthernetPort.FullDuplex = BoolValueOrNil(state.EthernetPort.FullDuplex)

		if state.EthernetPort.PortId != nil {
			input.Request.EthernetPort.PortId = &ujXZojh.Config{}

			input.Request.EthernetPort.PortId.Connector = StringValueOrNil(state.EthernetPort.PortId.Connector)

			input.Request.EthernetPort.PortId.Device = StringValueOrNil(state.EthernetPort.PortId.Device)

			input.Request.EthernetPort.PortId.Disabled = BoolValueOrNil(state.EthernetPort.PortId.Disabled)

			input.Request.EthernetPort.PortId.DisabledReason = StringValueOrNil(state.EthernetPort.PortId.DisabledReason)

			input.Request.EthernetPort.PortId.ElementId = StringValueOrNil(state.EthernetPort.PortId.ElementId)

			input.Request.EthernetPort.PortId.Id = StringValueOrNil(state.EthernetPort.PortId.Id)

			input.Request.EthernetPort.PortId.Inactive = BoolValueOrNil(state.EthernetPort.PortId.Inactive)

			input.Request.EthernetPort.PortId.InactiveReason = StringValueOrNil(state.EthernetPort.PortId.InactiveReason)

			input.Request.EthernetPort.PortId.MaxMtu = Int64ValueOrNil(state.EthernetPort.PortId.MaxMtu)

			input.Request.EthernetPort.PortId.MaxSpeed = Int64ValueOrNil(state.EthernetPort.PortId.MaxSpeed)

			input.Request.EthernetPort.PortId.Name = StringValueOrNil(state.EthernetPort.PortId.Name)

			input.Request.EthernetPort.PortId.OriginalMacAddress = StringValueOrNil(state.EthernetPort.PortId.OriginalMacAddress)

			input.Request.EthernetPort.PortId.Region = StringValueOrNil(state.EthernetPort.PortId.Region)

			input.Request.EthernetPort.PortId.SiteId = StringValue(state.EthernetPort.PortId.SiteId)
		}

		input.Request.EthernetPort.PortName = StringValueOrNil(state.EthernetPort.PortName)

		input.Request.EthernetPort.Speed = Int64ValueOrNil(state.EthernetPort.Speed)
	}

	input.Request.InterfaceProfileId = StringValueOrNil(state.InterfaceProfileId)

	input.Request.IpfixcollectorcontextId = StringValueOrNil(state.IpfixcollectorcontextId)

	input.Request.IpfixfiltercontextId = StringValueOrNil(state.IpfixfiltercontextId)

	if state.Ipv4Config != nil {
		input.Request.Ipv4Config = &wsoFfyL.Config{}

		if state.Ipv4Config.DhcpConfig != nil {
			input.Request.Ipv4Config.DhcpConfig = &rKcwmLF.Config{}

			input.Request.Ipv4Config.DhcpConfig.ClientId = StringValueOrNil(state.Ipv4Config.DhcpConfig.ClientId)

			input.Request.Ipv4Config.DhcpConfig.Hostname = StringValueOrNil(state.Ipv4Config.DhcpConfig.Hostname)
		}

		if state.Ipv4Config.DnsV4Config != nil {
			input.Request.Ipv4Config.DnsV4Config = &mTuoPRe.Config{}

			input.Request.Ipv4Config.DnsV4Config.NameServers = ListStringValueOrNil(ctx, state.Ipv4Config.DnsV4Config.NameServers)

			input.Request.Ipv4Config.DnsV4Config.Search = ListStringValueOrNil(ctx, state.Ipv4Config.DnsV4Config.Search)
		}

		if state.Ipv4Config.PppoeConfig != nil {
			input.Request.Ipv4Config.PppoeConfig = &cvAyZuw.Config{}

			input.Request.Ipv4Config.PppoeConfig.ChapPasswd = StringValueOrNil(state.Ipv4Config.PppoeConfig.ChapPasswd)

			input.Request.Ipv4Config.PppoeConfig.ChapUser = StringValueOrNil(state.Ipv4Config.PppoeConfig.ChapUser)

			input.Request.Ipv4Config.PppoeConfig.SetRoute = BoolValueOrNil(state.Ipv4Config.PppoeConfig.SetRoute)
		}

		if len(state.Ipv4Config.Routes) != 0 {
			input.Request.Ipv4Config.Routes = make([]bBEnHsN.Config, 0, len(state.Ipv4Config.Routes))
			for _, var6 := range state.Ipv4Config.Routes {
				var var7 bBEnHsN.Config

				var7.Destination = StringValueOrNil(var6.Destination)

				var7.Via = StringValueOrNil(var6.Via)
				input.Request.Ipv4Config.Routes = append(input.Request.Ipv4Config.Routes, var7)
			}
		}

		if state.Ipv4Config.StaticConfig != nil {
			input.Request.Ipv4Config.StaticConfig = &nfiOrAO.Config{}

			input.Request.Ipv4Config.StaticConfig.Address = StringValueOrNil(state.Ipv4Config.StaticConfig.Address)
		}

		input.Request.Ipv4Config.Type = StringValueOrNil(state.Ipv4Config.Type)
	}

	if state.Ipv6Config != nil {
		input.Request.Ipv6Config = &bMGDwkY.Config{}

		if state.Ipv6Config.DhcpConfig != nil {
			input.Request.Ipv6Config.DhcpConfig = &juuQHdk.Config{}

			input.Request.Ipv6Config.DhcpConfig.ClientId = StringValueOrNil(state.Ipv6Config.DhcpConfig.ClientId)

			input.Request.Ipv6Config.DhcpConfig.Hostname = StringValueOrNil(state.Ipv6Config.DhcpConfig.Hostname)
		}

		if state.Ipv6Config.DnsV6Config != nil {
			input.Request.Ipv6Config.DnsV6Config = &mTuoPRe.Config{}

			input.Request.Ipv6Config.DnsV6Config.NameServers = ListStringValueOrNil(ctx, state.Ipv6Config.DnsV6Config.NameServers)

			input.Request.Ipv6Config.DnsV6Config.Search = ListStringValueOrNil(ctx, state.Ipv6Config.DnsV6Config.Search)
		}

		if len(state.Ipv6Config.Routes) != 0 {
			input.Request.Ipv6Config.Routes = make([]bBEnHsN.Config, 0, len(state.Ipv6Config.Routes))
			for _, var10 := range state.Ipv6Config.Routes {
				var var11 bBEnHsN.Config

				var11.Destination = StringValueOrNil(var10.Destination)

				var11.Via = StringValueOrNil(var10.Via)
				input.Request.Ipv6Config.Routes = append(input.Request.Ipv6Config.Routes, var11)
			}
		}

		if state.Ipv6Config.StaticConfig != nil {
			input.Request.Ipv6Config.StaticConfig = &lIDFRUy.Config{}

			input.Request.Ipv6Config.StaticConfig.Address = StringValueOrNil(state.Ipv6Config.StaticConfig.Address)

			input.Request.Ipv6Config.StaticConfig.EnablePrefixDistribution = BoolValueOrNil(state.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}

		input.Request.Ipv6Config.Type = StringValueOrNil(state.Ipv6Config.Type)
	}

	input.Request.LldpEnabled = BoolValueOrNil(state.LldpEnabled)

	input.Request.MacAddress = StringValueOrNil(state.MacAddress)

	input.Request.Mtu = Int64ValueOrNil(state.Mtu)

	if state.MulticastConfig != nil {
		input.Request.MulticastConfig = &zLXjrfn.Config{}

		input.Request.MulticastConfig.IgmpVersion = StringValueOrNil(state.MulticastConfig.IgmpVersion)

		input.Request.MulticastConfig.MulticastEnabled = BoolValueOrNil(state.MulticastConfig.MulticastEnabled)
	}

	input.Request.Name = StringValueOrNil(state.Name)

	input.Request.NatAddress = StringValueOrNil(state.NatAddress)

	input.Request.NatAddressV6 = StringValueOrNil(state.NatAddressV6)

	if len(state.NatPools) != 0 {
		input.Request.NatPools = make([]alJfwdK.Config, 0, len(state.NatPools))
		for _, var12 := range state.NatPools {
			var var13 alJfwdK.Config

			if len(var12.Ipv4Ranges) != 0 {
				var13.Ipv4Ranges = make([]xYviIkG.Config, 0, len(var12.Ipv4Ranges))
				for _, var14 := range var12.Ipv4Ranges {
					var var15 xYviIkG.Config

					var15.End = StringValue(var14.End)

					var15.Start = StringValue(var14.Start)
					var13.Ipv4Ranges = append(var13.Ipv4Ranges, var15)
				}
			}

			var13.NatPoolId = StringValueOrNil(var12.NatPoolId)
			input.Request.NatPools = append(input.Request.NatPools, var13)
		}
	}

	input.Request.NatPort = Int64ValueOrNil(state.NatPort)

	input.Request.NatPortV6 = Int64ValueOrNil(state.NatPortV6)

	input.Request.NatZoneId = StringValueOrNil(state.NatZoneId)

	input.Request.NetworkContextId = StringValueOrNil(state.NetworkContextId)

	input.Request.Parent = StringValueOrNil(state.Parent)

	input.Request.PeerBypasspairWanPortType = StringValue(state.PeerBypasspairWanPortType)

	input.Request.PoeEnabled = BoolValueOrNil(state.PoeEnabled)

	input.Request.PowerUsageThreshold = Int64ValueOrNil(state.PowerUsageThreshold)

	if state.PppoeConfig != nil {
		input.Request.PppoeConfig = &yxxGXUe.Config{}

		input.Request.PppoeConfig.HostUniq = StringValueOrNil(state.PppoeConfig.HostUniq)

		input.Request.PppoeConfig.IpAddressType = StringValueOrNil(state.PppoeConfig.IpAddressType)

		input.Request.PppoeConfig.Password = StringValueOrNil(state.PppoeConfig.Password)

		input.Request.PppoeConfig.ReconnectionDelay = Int64ValueOrNil(state.PppoeConfig.ReconnectionDelay)

		input.Request.PppoeConfig.ServiceName = StringValueOrNil(state.PppoeConfig.ServiceName)

		input.Request.PppoeConfig.Username = StringValueOrNil(state.PppoeConfig.Username)
	}

	input.Request.Scope = StringValue(state.Scope)

	if len(state.SecondaryIpConfigs) != 0 {
		input.Request.SecondaryIpConfigs = make([]jmyEuEW.Config, 0, len(state.SecondaryIpConfigs))
		for _, var16 := range state.SecondaryIpConfigs {
			var var17 jmyEuEW.Config

			var17.Ipv4Address = StringValueOrNil(var16.Ipv4Address)

			var17.Scope = StringValueOrNil(var16.Scope)
			input.Request.SecondaryIpConfigs = append(input.Request.SecondaryIpConfigs, var17)
		}
	}

	if state.ServiceLinkConfig != nil {
		input.Request.ServiceLinkConfig = &obJkRYB.Config{}

		if state.ServiceLinkConfig.GreConfig != nil {
			input.Request.ServiceLinkConfig.GreConfig = &suSmnCD.Config{}

			input.Request.ServiceLinkConfig.GreConfig.Csum = BoolValueOrNil(state.ServiceLinkConfig.GreConfig.Csum)

			input.Request.ServiceLinkConfig.GreConfig.KeepaliveEnable = BoolValueOrNil(state.ServiceLinkConfig.GreConfig.KeepaliveEnable)

			input.Request.ServiceLinkConfig.GreConfig.KeepaliveFailCount = Int64ValueOrNil(state.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

			input.Request.ServiceLinkConfig.GreConfig.KeepaliveInterval = Int64ValueOrNil(state.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}

		if state.ServiceLinkConfig.IpsecConfig != nil {
			input.Request.ServiceLinkConfig.IpsecConfig = &nnsRzDg.Config{}

			if state.ServiceLinkConfig.IpsecConfig.Authentication != nil {
				input.Request.ServiceLinkConfig.IpsecConfig.Authentication = &xdEvbZX.Config{}

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Comment = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

				if state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &mKyPIKy.Config{}

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = StringValue(state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = StringValue(state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = BoolValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Secret = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = BoolValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Type = StringValue(state.ServiceLinkConfig.IpsecConfig.Authentication.Type)

				if state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects != nil {
					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &qSUpByF.Config{}

					if !state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder.IsNull() && state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder.ValueBool() {
						input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = map[string]interface{}{}
					}

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = BoolValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = BoolValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

					if !state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair.IsNull() && state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair.ValueBool() {
						input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = map[string]interface{}{}
					}

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

					resp.Diagnostics.Append(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet.ElementsAs(ctx, &input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet, false)...)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = StringValueOrNil(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

					resp.Diagnostics.Append(state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet.ElementsAs(ctx, &input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet, false)...)
				}
			}

			input.Request.ServiceLinkConfig.IpsecConfig.IpsecProfileId = StringValue(state.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}

		input.Request.ServiceLinkConfig.LastParent = StringValueOrNil(state.ServiceLinkConfig.LastParent)

		input.Request.ServiceLinkConfig.Parent = StringValueOrNil(state.ServiceLinkConfig.Parent)

		if state.ServiceLinkConfig.PassiveMode != nil {
			input.Request.ServiceLinkConfig.PassiveMode = &wiUYuNU.Config{}

			input.Request.ServiceLinkConfig.PassiveMode.Enable = BoolValueOrNil(state.ServiceLinkConfig.PassiveMode.Enable)

			input.Request.ServiceLinkConfig.PassiveMode.PeerIpDynamic = BoolValueOrNil(state.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}

		if state.ServiceLinkConfig.Peer != nil {
			input.Request.ServiceLinkConfig.Peer = &pjMVEcr.Config{}

			input.Request.ServiceLinkConfig.Peer.Hostname = StringValueOrNil(state.ServiceLinkConfig.Peer.Hostname)

			input.Request.ServiceLinkConfig.Peer.IpAddresses = ListStringValueOrNil(ctx, state.ServiceLinkConfig.Peer.IpAddresses)
		}

		input.Request.ServiceLinkConfig.ServiceEndpointId = StringValueOrNil(state.ServiceLinkConfig.ServiceEndpointId)

		input.Request.ServiceLinkConfig.Type = StringValue(state.ServiceLinkConfig.Type)
	}

	input.Request.SiteWanInterfaceIds = ListStringValueOrNil(ctx, state.SiteWanInterfaceIds)

	if len(state.StaticArpConfigs) != 0 {
		input.Request.StaticArpConfigs = make([]pWDbfYi.Config, 0, len(state.StaticArpConfigs))
		for _, var22 := range state.StaticArpConfigs {
			var var23 pWDbfYi.Config

			var23.Ipv4Address = StringValueOrNil(var22.Ipv4Address)

			var23.MacAddress = StringValueOrNil(var22.MacAddress)
			input.Request.StaticArpConfigs = append(input.Request.StaticArpConfigs, var23)
		}
	}

	if state.SubInterface != nil {
		input.Request.SubInterface = &jEYlBbY.Config{}

		input.Request.SubInterface.VlanId = Int64ValueOrNil(state.SubInterface.VlanId)
	}

	if state.SwitchPortConfig != nil {
		input.Request.SwitchPortConfig = &kslrKbF.Config{}

		input.Request.SwitchPortConfig.AccessVlanId = Int64ValueOrNil(state.SwitchPortConfig.AccessVlanId)

		input.Request.SwitchPortConfig.BpduGuardEnabled = BoolValueOrNil(state.SwitchPortConfig.BpduGuardEnabled)

		input.Request.SwitchPortConfig.ForwardFastEnabled = BoolValueOrNil(state.SwitchPortConfig.ForwardFastEnabled)

		input.Request.SwitchPortConfig.NativeVlanId = Int64ValueOrNil(state.SwitchPortConfig.NativeVlanId)

		input.Request.SwitchPortConfig.RootGuardEnabled = BoolValueOrNil(state.SwitchPortConfig.RootGuardEnabled)

		if state.SwitchPortConfig.StormControlConfig != nil {
			input.Request.SwitchPortConfig.StormControlConfig = &qhDZEMT.Config{}

			input.Request.SwitchPortConfig.StormControlConfig.BroadcastThreshold = Int64ValueOrNil(state.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

			input.Request.SwitchPortConfig.StormControlConfig.MulticastThreshold = Int64ValueOrNil(state.SwitchPortConfig.StormControlConfig.MulticastThreshold)

			input.Request.SwitchPortConfig.StormControlConfig.UnicastThreshold = Int64ValueOrNil(state.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}

		input.Request.SwitchPortConfig.StpPortCost = Int64ValueOrNil(state.SwitchPortConfig.StpPortCost)

		input.Request.SwitchPortConfig.StpPortEnabled = BoolValueOrNil(state.SwitchPortConfig.StpPortEnabled)

		input.Request.SwitchPortConfig.StpPortPriority = Int64ValueOrNil(state.SwitchPortConfig.StpPortPriority)

		input.Request.SwitchPortConfig.TrunkVlans = ListStringValueOrNil(ctx, state.SwitchPortConfig.TrunkVlans)

		input.Request.SwitchPortConfig.VlanMode = StringValue(state.SwitchPortConfig.VlanMode)

		input.Request.SwitchPortConfig.VoiceVlanId = Int64ValueOrNil(state.SwitchPortConfig.VoiceVlanId)
	}

	input.Request.Tags = ListStringValueOrNil(ctx, state.Tags)

	input.Request.Type = StringValue(state.Type)

	input.Request.UsedFor = StringValue(state.UsedFor)

	if state.VlanConfig != nil {
		input.Request.VlanConfig = &aCdiNxV.Config{}

		input.Request.VlanConfig.MstpInstance = Int64ValueOrNil(state.VlanConfig.MstpInstance)

		input.Request.VlanConfig.VlanId = Int64ValueOrNil(state.VlanConfig.VlanId)

		input.Request.VlanConfig.VoiceEnabled = BoolValueOrNil(state.VlanConfig.VoiceEnabled)
	}

	input.Request.VrfContextId = StringValueOrNil(state.VrfContextId)

	// Perform the operation.
	ans, err := svc.Create(ctx, input)
	if err != nil {
		resp.Diagnostics.AddError("Error creating config", err.Error())
		return
	}

	// Create the Terraform ID.
	var idBuilder strings.Builder
	idBuilder.WriteString(input.SiteId)

	idBuilder.WriteString(IdSeparator)
	idBuilder.WriteString(input.ElementId)

	idBuilder.WriteString(IdSeparator)
	if ans.Id == nil {
		resp.Diagnostics.AddError("Undefined param required for ID", "Id")
		return
	}
	if ans.Id != nil {
		idBuilder.WriteString(*ans.Id)
	}

	// Store the answer to state.

	state.Tfid = types.StringValue(idBuilder.String())

	state.AdminUp = types.BoolPointerValue(ans.AdminUp)

	if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = nil
	} else {
		state.AttachedLanNetworks = make([]interfaceRsModel_irQawLY_Config, 0, len(ans.AttachedLanNetworks))
		for _, var26 := range ans.AttachedLanNetworks {
			var27 := interfaceRsModel_irQawLY_Config{}

			var27.LanNetworkId = types.StringPointerValue(var26.LanNetworkId)

			var27.VlanId = types.Int64PointerValue(var26.VlanId)
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, var27)
		}
	}

	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &interfaceRsModel_mIAatvm_Config{}

		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)

		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)

		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}

	var28, var29 := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = var28
	resp.Diagnostics.Append(var29.Errors()...)

	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &interfaceRsModel_zGfKFAQ_Config{}

		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)

		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)

		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)

		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}

	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &interfaceRsModel_eumQbRC_Config{}

		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &interfaceRsModel_aeWshcf_Config{}

			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)

			state.CellularConfig.ApnConfig.Authentication = types.StringValue(ans.CellularConfig.ApnConfig.Authentication)

			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)

			state.CellularConfig.ApnConfig.Password = types.StringPointerValue(ans.CellularConfig.ApnConfig.Password)

			state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(ans.CellularConfig.ApnConfig.PasswordEncrypted)

			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}

		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)

		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)

		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)

		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}

	state.Description = types.StringPointerValue(ans.Description)

	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)

	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &interfaceRsModel_mCcgFKg_Config{}

		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)

		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &interfaceRsModel_tOChZgD_Config{}

			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)

			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)

			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.DhcpRelay.Option82.ReforwardingPolicy)

			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}

		var30, var31 := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = var30
		resp.Diagnostics.Append(var31.Errors()...)

		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}

	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)

	state.Etag = types.Int64PointerValue(ans.Etag)

	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &interfaceRsModel_ehJLagQ_Config{}

		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)

		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &interfaceRsModel_ujXZojh_Config{}

			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)

			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)

			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)

			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)

			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)

			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)

			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)

			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)

			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)

			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)

			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)

			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)

			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)

			state.EthernetPort.PortId.SiteId = types.StringValue(ans.EthernetPort.PortId.SiteId)
		}

		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)

		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}

	state.Id = types.StringPointerValue(ans.Id)

	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)

	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)

	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &interfaceRsModel_wsoFfyL_Config{}

		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &interfaceRsModel_rKcwmLF_Config{}

			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)

			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}

		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &interfaceRsModel_mTuoPRe_Config{}

			var32, var33 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = var32
			resp.Diagnostics.Append(var33.Errors()...)

			var34, var35 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = var34
			resp.Diagnostics.Append(var35.Errors()...)
		}

		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &interfaceRsModel_cvAyZuw_Config{}

			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)

			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)

			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}

		if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = nil
		} else {
			state.Ipv4Config.Routes = make([]interfaceRsModel_bBEnHsN_Config, 0, len(ans.Ipv4Config.Routes))
			for _, var36 := range ans.Ipv4Config.Routes {
				var37 := interfaceRsModel_bBEnHsN_Config{}

				var37.Destination = types.StringPointerValue(var36.Destination)

				var37.Via = types.StringPointerValue(var36.Via)
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, var37)
			}
		}

		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &interfaceRsModel_nfiOrAO_Config{}

			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}

		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &interfaceRsModel_bMGDwkY_Config{}

		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &interfaceRsModel_juuQHdk_Config{}

			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)

			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}

		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &interfaceRsModel_mTuoPRe_Config{}

			var38, var39 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = var38
			resp.Diagnostics.Append(var39.Errors()...)

			var40, var41 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = var40
			resp.Diagnostics.Append(var41.Errors()...)
		}

		if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = nil
		} else {
			state.Ipv6Config.Routes = make([]interfaceRsModel_bBEnHsN_Config, 0, len(ans.Ipv6Config.Routes))
			for _, var42 := range ans.Ipv6Config.Routes {
				var43 := interfaceRsModel_bBEnHsN_Config{}

				var43.Destination = types.StringPointerValue(var42.Destination)

				var43.Via = types.StringPointerValue(var42.Via)
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, var43)
			}
		}

		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &interfaceRsModel_lIDFRUy_Config{}

			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)

			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}

		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}

	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)

	state.MacAddress = types.StringPointerValue(ans.MacAddress)

	state.Mtu = types.Int64PointerValue(ans.Mtu)

	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &interfaceRsModel_zLXjrfn_Config{}

		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)

		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}

	state.Name = types.StringPointerValue(ans.Name)

	state.NatAddress = types.StringPointerValue(ans.NatAddress)

	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)

	if len(ans.NatPools) == 0 {
		state.NatPools = nil
	} else {
		state.NatPools = make([]interfaceRsModel_alJfwdK_Config, 0, len(ans.NatPools))
		for _, var44 := range ans.NatPools {
			var45 := interfaceRsModel_alJfwdK_Config{}

			if len(var44.Ipv4Ranges) == 0 {
				var45.Ipv4Ranges = nil
			} else {
				var45.Ipv4Ranges = make([]interfaceRsModel_xYviIkG_Config, 0, len(var44.Ipv4Ranges))
				for _, var46 := range var44.Ipv4Ranges {
					var47 := interfaceRsModel_xYviIkG_Config{}

					var47.End = types.StringValue(var46.End)

					var47.Start = types.StringValue(var46.Start)
					var45.Ipv4Ranges = append(var45.Ipv4Ranges, var47)
				}
			}

			var45.NatPoolId = types.StringPointerValue(var44.NatPoolId)
			state.NatPools = append(state.NatPools, var45)
		}
	}

	state.NatPort = types.Int64PointerValue(ans.NatPort)

	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)

	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Parent = types.StringPointerValue(ans.Parent)

	state.PeerBypasspairWanPortType = types.StringValue(ans.PeerBypasspairWanPortType)

	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)

	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)

	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &interfaceRsModel_yxxGXUe_Config{}

		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)

		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)

		state.PppoeConfig.Password = types.StringPointerValue(ans.PppoeConfig.Password)

		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)

		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)

		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}

	state.Scope = types.StringValue(ans.Scope)

	if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = nil
	} else {
		state.SecondaryIpConfigs = make([]interfaceRsModel_jmyEuEW_Config, 0, len(ans.SecondaryIpConfigs))
		for _, var48 := range ans.SecondaryIpConfigs {
			var49 := interfaceRsModel_jmyEuEW_Config{}

			var49.Ipv4Address = types.StringPointerValue(var48.Ipv4Address)

			var49.Scope = types.StringPointerValue(var48.Scope)
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, var49)
		}
	}

	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &interfaceRsModel_obJkRYB_Config{}

		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &interfaceRsModel_suSmnCD_Config{}

			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)

			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)

			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}

		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &interfaceRsModel_nnsRzDg_Config{}

			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &interfaceRsModel_xdEvbZX_Config{}

				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &interfaceRsModel_mKyPIKy_Config{}

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &interfaceRsModel_qSUpByF_Config{}

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

					var50, var51 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet = var50
					resp.Diagnostics.Append(var51.Errors()...)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

					var52, var53 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet = var52
					resp.Diagnostics.Append(var53.Errors()...)
				}
			}

			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}

		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)

		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)

		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &interfaceRsModel_wiUYuNU_Config{}

			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)

			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}

		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &interfaceRsModel_pjMVEcr_Config{}

			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)

			var54, var55 := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = var54
			resp.Diagnostics.Append(var55.Errors()...)
		}

		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)

		state.ServiceLinkConfig.Type = types.StringValue(ans.ServiceLinkConfig.Type)
	}

	var56, var57 := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = var56
	resp.Diagnostics.Append(var57.Errors()...)

	if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = nil
	} else {
		state.StaticArpConfigs = make([]interfaceRsModel_pWDbfYi_Config, 0, len(ans.StaticArpConfigs))
		for _, var58 := range ans.StaticArpConfigs {
			var59 := interfaceRsModel_pWDbfYi_Config{}

			var59.Ipv4Address = types.StringPointerValue(var58.Ipv4Address)

			var59.MacAddress = types.StringPointerValue(var58.MacAddress)
			state.StaticArpConfigs = append(state.StaticArpConfigs, var59)
		}
	}

	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &interfaceRsModel_jEYlBbY_Config{}

		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}

	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &interfaceRsModel_kslrKbF_Config{}

		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)

		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)

		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)

		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)

		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)

		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &interfaceRsModel_qhDZEMT_Config{}

			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)

			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}

		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)

		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)

		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)

		var60, var61 := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = var60
		resp.Diagnostics.Append(var61.Errors()...)

		state.SwitchPortConfig.VlanMode = types.StringValue(ans.SwitchPortConfig.VlanMode)

		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}

	var62, var63 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var62
	resp.Diagnostics.Append(var63.Errors()...)

	state.Type = types.StringValue(ans.Type)

	state.UsedFor = types.StringValue(ans.UsedFor)

	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &interfaceRsModel_aCdiNxV_Config{}

		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)

		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)

		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Read performs Read for the struct.
func (r *interfaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var savestate, state interfaceRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &savestate)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := savestate.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 3 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 3 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource read", map[string]any{
		"terraform_provider_function": "Read",
		"resource_name":               "prismasdwan_interface",
		"locMap":                      map[string]int{"element_id": 1, "interface_id": 2, "site_id": 0},
		"tokens":                      tokens,
	})

	// Prepare to read the config.
	svc := aSvnUVk.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := aSvnUVk.ReadInput{}

	input.SiteId = tokens[0]

	input.ElementId = tokens[1]

	input.InterfaceId = tokens[2]

	// Perform the operation.
	ans, err := svc.Read(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error reading config", err.Error())
		}
		return
	}

	// Store the answer to state.

	if tokens[0] == "" {
		state.SiteId = types.StringNull()
	} else {
		state.SiteId = types.StringValue(tokens[0])
	}

	if tokens[1] == "" {
		state.ElementId = types.StringNull()
	} else {
		state.ElementId = types.StringValue(tokens[1])
	}
	state.Tfid = savestate.Tfid

	state.AdminUp = types.BoolPointerValue(ans.AdminUp)

	if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = nil
	} else {
		state.AttachedLanNetworks = make([]interfaceRsModel_irQawLY_Config, 0, len(ans.AttachedLanNetworks))
		for _, var0 := range ans.AttachedLanNetworks {
			var1 := interfaceRsModel_irQawLY_Config{}

			var1.LanNetworkId = types.StringPointerValue(var0.LanNetworkId)

			var1.VlanId = types.Int64PointerValue(var0.VlanId)
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, var1)
		}
	}

	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &interfaceRsModel_mIAatvm_Config{}

		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)

		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)

		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}

	var2, var3 := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = var2
	resp.Diagnostics.Append(var3.Errors()...)

	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &interfaceRsModel_zGfKFAQ_Config{}

		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)

		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)

		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)

		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}

	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &interfaceRsModel_eumQbRC_Config{}

		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &interfaceRsModel_aeWshcf_Config{}

			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)

			state.CellularConfig.ApnConfig.Authentication = types.StringValue(ans.CellularConfig.ApnConfig.Authentication)

			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)

			state.CellularConfig.ApnConfig.Password = types.StringPointerValue(ans.CellularConfig.ApnConfig.Password)

			state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(ans.CellularConfig.ApnConfig.PasswordEncrypted)

			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}

		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)

		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)

		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)

		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}

	state.Description = types.StringPointerValue(ans.Description)

	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)

	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &interfaceRsModel_mCcgFKg_Config{}

		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)

		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &interfaceRsModel_tOChZgD_Config{}

			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)

			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)

			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.DhcpRelay.Option82.ReforwardingPolicy)

			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}

		var4, var5 := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = var4
		resp.Diagnostics.Append(var5.Errors()...)

		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}

	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)

	state.Etag = types.Int64PointerValue(ans.Etag)

	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &interfaceRsModel_ehJLagQ_Config{}

		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)

		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &interfaceRsModel_ujXZojh_Config{}

			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)

			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)

			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)

			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)

			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)

			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)

			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)

			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)

			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)

			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)

			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)

			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)

			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)

			state.EthernetPort.PortId.SiteId = types.StringValue(ans.EthernetPort.PortId.SiteId)
		}

		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)

		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}

	state.Id = types.StringPointerValue(ans.Id)

	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)

	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)

	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &interfaceRsModel_wsoFfyL_Config{}

		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &interfaceRsModel_rKcwmLF_Config{}

			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)

			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}

		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &interfaceRsModel_mTuoPRe_Config{}

			var6, var7 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = var6
			resp.Diagnostics.Append(var7.Errors()...)

			var8, var9 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = var8
			resp.Diagnostics.Append(var9.Errors()...)
		}

		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &interfaceRsModel_cvAyZuw_Config{}

			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)

			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)

			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}

		if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = nil
		} else {
			state.Ipv4Config.Routes = make([]interfaceRsModel_bBEnHsN_Config, 0, len(ans.Ipv4Config.Routes))
			for _, var10 := range ans.Ipv4Config.Routes {
				var11 := interfaceRsModel_bBEnHsN_Config{}

				var11.Destination = types.StringPointerValue(var10.Destination)

				var11.Via = types.StringPointerValue(var10.Via)
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, var11)
			}
		}

		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &interfaceRsModel_nfiOrAO_Config{}

			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}

		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &interfaceRsModel_bMGDwkY_Config{}

		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &interfaceRsModel_juuQHdk_Config{}

			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)

			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}

		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &interfaceRsModel_mTuoPRe_Config{}

			var12, var13 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = var12
			resp.Diagnostics.Append(var13.Errors()...)

			var14, var15 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = var14
			resp.Diagnostics.Append(var15.Errors()...)
		}

		if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = nil
		} else {
			state.Ipv6Config.Routes = make([]interfaceRsModel_bBEnHsN_Config, 0, len(ans.Ipv6Config.Routes))
			for _, var16 := range ans.Ipv6Config.Routes {
				var17 := interfaceRsModel_bBEnHsN_Config{}

				var17.Destination = types.StringPointerValue(var16.Destination)

				var17.Via = types.StringPointerValue(var16.Via)
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, var17)
			}
		}

		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &interfaceRsModel_lIDFRUy_Config{}

			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)

			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}

		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}

	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)

	state.MacAddress = types.StringPointerValue(ans.MacAddress)

	state.Mtu = types.Int64PointerValue(ans.Mtu)

	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &interfaceRsModel_zLXjrfn_Config{}

		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)

		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}

	state.Name = types.StringPointerValue(ans.Name)

	state.NatAddress = types.StringPointerValue(ans.NatAddress)

	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)

	if len(ans.NatPools) == 0 {
		state.NatPools = nil
	} else {
		state.NatPools = make([]interfaceRsModel_alJfwdK_Config, 0, len(ans.NatPools))
		for _, var18 := range ans.NatPools {
			var19 := interfaceRsModel_alJfwdK_Config{}

			if len(var18.Ipv4Ranges) == 0 {
				var19.Ipv4Ranges = nil
			} else {
				var19.Ipv4Ranges = make([]interfaceRsModel_xYviIkG_Config, 0, len(var18.Ipv4Ranges))
				for _, var20 := range var18.Ipv4Ranges {
					var21 := interfaceRsModel_xYviIkG_Config{}

					var21.End = types.StringValue(var20.End)

					var21.Start = types.StringValue(var20.Start)
					var19.Ipv4Ranges = append(var19.Ipv4Ranges, var21)
				}
			}

			var19.NatPoolId = types.StringPointerValue(var18.NatPoolId)
			state.NatPools = append(state.NatPools, var19)
		}
	}

	state.NatPort = types.Int64PointerValue(ans.NatPort)

	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)

	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Parent = types.StringPointerValue(ans.Parent)

	state.PeerBypasspairWanPortType = types.StringValue(ans.PeerBypasspairWanPortType)

	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)

	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)

	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &interfaceRsModel_yxxGXUe_Config{}

		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)

		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)

		state.PppoeConfig.Password = types.StringPointerValue(ans.PppoeConfig.Password)

		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)

		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)

		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}

	state.Scope = types.StringValue(ans.Scope)

	if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = nil
	} else {
		state.SecondaryIpConfigs = make([]interfaceRsModel_jmyEuEW_Config, 0, len(ans.SecondaryIpConfigs))
		for _, var22 := range ans.SecondaryIpConfigs {
			var23 := interfaceRsModel_jmyEuEW_Config{}

			var23.Ipv4Address = types.StringPointerValue(var22.Ipv4Address)

			var23.Scope = types.StringPointerValue(var22.Scope)
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, var23)
		}
	}

	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &interfaceRsModel_obJkRYB_Config{}

		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &interfaceRsModel_suSmnCD_Config{}

			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)

			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)

			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}

		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &interfaceRsModel_nnsRzDg_Config{}

			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &interfaceRsModel_xdEvbZX_Config{}

				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &interfaceRsModel_mKyPIKy_Config{}

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &interfaceRsModel_qSUpByF_Config{}

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

					var24, var25 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet = var24
					resp.Diagnostics.Append(var25.Errors()...)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

					var26, var27 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet = var26
					resp.Diagnostics.Append(var27.Errors()...)
				}
			}

			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}

		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)

		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)

		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &interfaceRsModel_wiUYuNU_Config{}

			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)

			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}

		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &interfaceRsModel_pjMVEcr_Config{}

			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)

			var28, var29 := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = var28
			resp.Diagnostics.Append(var29.Errors()...)
		}

		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)

		state.ServiceLinkConfig.Type = types.StringValue(ans.ServiceLinkConfig.Type)
	}

	var30, var31 := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = var30
	resp.Diagnostics.Append(var31.Errors()...)

	if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = nil
	} else {
		state.StaticArpConfigs = make([]interfaceRsModel_pWDbfYi_Config, 0, len(ans.StaticArpConfigs))
		for _, var32 := range ans.StaticArpConfigs {
			var33 := interfaceRsModel_pWDbfYi_Config{}

			var33.Ipv4Address = types.StringPointerValue(var32.Ipv4Address)

			var33.MacAddress = types.StringPointerValue(var32.MacAddress)
			state.StaticArpConfigs = append(state.StaticArpConfigs, var33)
		}
	}

	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &interfaceRsModel_jEYlBbY_Config{}

		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}

	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &interfaceRsModel_kslrKbF_Config{}

		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)

		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)

		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)

		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)

		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)

		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &interfaceRsModel_qhDZEMT_Config{}

			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)

			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}

		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)

		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)

		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)

		var34, var35 := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = var34
		resp.Diagnostics.Append(var35.Errors()...)

		state.SwitchPortConfig.VlanMode = types.StringValue(ans.SwitchPortConfig.VlanMode)

		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}

	var36, var37 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var36
	resp.Diagnostics.Append(var37.Errors()...)

	state.Type = types.StringValue(ans.Type)

	state.UsedFor = types.StringValue(ans.UsedFor)

	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &interfaceRsModel_aCdiNxV_Config{}

		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)

		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)

		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Update performs the Update for the struct.
func (r *interfaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan, state interfaceRsModel
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	tfid := state.Tfid.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 3 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 3 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource update", map[string]any{
		"terraform_provider_function": "Update",
		"resource_name":               "prismasdwan_interface",
		"tfid":                        state.Tfid.ValueString(),
	})

	// Prepare to update the config.
	svc := aSvnUVk.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := aSvnUVk.UpdateInput{}

	if tokens[0] != "" {
		input.SiteId = tokens[0]
	}

	if tokens[1] != "" {
		input.ElementId = tokens[1]
	}

	if tokens[2] != "" {
		input.InterfaceId = tokens[2]
	}
	input.Request = &quvWIWu.Config{}

	input.Request.AdminUp = ValueBoolPointerFromPlanOrState(plan.AdminUp, state.AdminUp)

	if len(plan.AttachedLanNetworks) != 0 || len(state.AttachedLanNetworks) != 0 {
		AttachedLanNetworksToUse := plan.AttachedLanNetworks
		if len(plan.AttachedLanNetworks) == 0 {
			AttachedLanNetworksToUse = state.AttachedLanNetworks
		}
		input.Request.AttachedLanNetworks = make([]irQawLY.Config, 0, len(AttachedLanNetworksToUse))
		for _, var0 := range plan.AttachedLanNetworks {
			var var1 irQawLY.Config

			var1.LanNetworkId = StringValueOrNil(var0.LanNetworkId)

			var1.VlanId = Int64ValueOrNil(var0.VlanId)
			input.Request.AttachedLanNetworks = append(input.Request.AttachedLanNetworks, var1)
		}
	}

	if plan.AuthenticationConfig != nil {
		input.Request.AuthenticationConfig = &mIAatvm.Config{}

		input.Request.AuthenticationConfig.FallbackRetryCount = ValueInt64PointerFromPlanOrState(plan.AuthenticationConfig.FallbackRetryCount, state.AuthenticationConfig.FallbackRetryCount)

		input.Request.AuthenticationConfig.Mode = ValueStringPointerFromPlanOrState(plan.AuthenticationConfig.Mode, state.AuthenticationConfig.Mode)

		input.Request.AuthenticationConfig.ReauthenticationTimeout = ValueInt64PointerFromPlanOrState(plan.AuthenticationConfig.ReauthenticationTimeout, state.AuthenticationConfig.ReauthenticationTimeout)
	}

	input.Request.BoundInterfaces = ListStringValueOrNil(ctx, plan.BoundInterfaces)

	if plan.BypassPair != nil {
		input.Request.BypassPair = &zGfKFAQ.Config{}

		input.Request.BypassPair.Lan = ValueStringPointerFromPlanOrState(plan.BypassPair.Lan, state.BypassPair.Lan)

		input.Request.BypassPair.LanStatePropagation = ValueBoolPointerFromPlanOrState(plan.BypassPair.LanStatePropagation, state.BypassPair.LanStatePropagation)

		input.Request.BypassPair.UseRelay = ValueBoolPointerFromPlanOrState(plan.BypassPair.UseRelay, state.BypassPair.UseRelay)

		input.Request.BypassPair.Wan = ValueStringPointerFromPlanOrState(plan.BypassPair.Wan, state.BypassPair.Wan)
	}

	if plan.CellularConfig != nil {
		input.Request.CellularConfig = &eumQbRC.Config{}

		if plan.CellularConfig.ApnConfig != nil {
			input.Request.CellularConfig.ApnConfig = &aeWshcf.Config{}

			input.Request.CellularConfig.ApnConfig.Apn = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.Apn, state.CellularConfig.ApnConfig.Apn)

			input.Request.CellularConfig.ApnConfig.Authentication = ValueStringFromPlanOrState(plan.CellularConfig.ApnConfig.Authentication, state.CellularConfig.ApnConfig.Authentication)

			input.Request.CellularConfig.ApnConfig.ClearPassword = ValueBoolPointerFromPlanOrState(plan.CellularConfig.ApnConfig.ClearPassword, state.CellularConfig.ApnConfig.ClearPassword)

			input.Request.CellularConfig.ApnConfig.Password = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.Password, state.CellularConfig.ApnConfig.Password)

			input.Request.CellularConfig.ApnConfig.PasswordEncrypted = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.PasswordEncrypted, state.CellularConfig.ApnConfig.PasswordEncrypted)

			input.Request.CellularConfig.ApnConfig.UserName = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnConfig.UserName, state.CellularConfig.ApnConfig.UserName)
		}

		input.Request.CellularConfig.ApnprofileId = ValueStringPointerFromPlanOrState(plan.CellularConfig.ApnprofileId, state.CellularConfig.ApnprofileId)

		input.Request.CellularConfig.AutoApn = ValueBoolPointerFromPlanOrState(plan.CellularConfig.AutoApn, state.CellularConfig.AutoApn)

		input.Request.CellularConfig.ParentModuleId = ValueStringPointerFromPlanOrState(plan.CellularConfig.ParentModuleId, state.CellularConfig.ParentModuleId)

		input.Request.CellularConfig.ParentSimSlotNumber = ValueInt64PointerFromPlanOrState(plan.CellularConfig.ParentSimSlotNumber, state.CellularConfig.ParentSimSlotNumber)
	}

	input.Request.Description = ValueStringPointerFromPlanOrState(plan.Description, state.Description)

	input.Request.DevicemgmtPolicysetstackId = ValueStringPointerFromPlanOrState(plan.DevicemgmtPolicysetstackId, state.DevicemgmtPolicysetstackId)

	if plan.DhcpRelay != nil {
		input.Request.DhcpRelay = &mCcgFKg.Config{}

		input.Request.DhcpRelay.Enabled = ValueBoolPointerFromPlanOrState(plan.DhcpRelay.Enabled, state.DhcpRelay.Enabled)

		if plan.DhcpRelay.Option82 != nil {
			input.Request.DhcpRelay.Option82 = &tOChZgD.Config{}

			input.Request.DhcpRelay.Option82.CircuitId = ValueStringPointerFromPlanOrState(plan.DhcpRelay.Option82.CircuitId, state.DhcpRelay.Option82.CircuitId)

			input.Request.DhcpRelay.Option82.Enabled = ValueBoolPointerFromPlanOrState(plan.DhcpRelay.Option82.Enabled, state.DhcpRelay.Option82.Enabled)

			input.Request.DhcpRelay.Option82.ReforwardingPolicy = ValueStringFromPlanOrState(plan.DhcpRelay.Option82.ReforwardingPolicy, state.DhcpRelay.Option82.ReforwardingPolicy)

			input.Request.DhcpRelay.Option82.RemoteId = ValueStringPointerFromPlanOrState(plan.DhcpRelay.Option82.RemoteId, state.DhcpRelay.Option82.RemoteId)
		}

		input.Request.DhcpRelay.ServerIps = ListStringValueOrNil(ctx, plan.DhcpRelay.ServerIps)

		input.Request.DhcpRelay.SourceInterface = ValueStringPointerFromPlanOrState(plan.DhcpRelay.SourceInterface, state.DhcpRelay.SourceInterface)
	}

	input.Request.DirectedBroadcast = ValueBoolPointerFromPlanOrState(plan.DirectedBroadcast, state.DirectedBroadcast)

	input.Request.Etag = ValueInt64PointerFromPlanOrState(plan.Etag, state.Etag)

	if plan.EthernetPort != nil {
		input.Request.EthernetPort = &ehJLagQ.Config{}

		input.Request.EthernetPort.FullDuplex = ValueBoolPointerFromPlanOrState(plan.EthernetPort.FullDuplex, state.EthernetPort.FullDuplex)

		if plan.EthernetPort.PortId != nil {
			input.Request.EthernetPort.PortId = &ujXZojh.Config{}

			input.Request.EthernetPort.PortId.Connector = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Connector, state.EthernetPort.PortId.Connector)

			input.Request.EthernetPort.PortId.Device = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Device, state.EthernetPort.PortId.Device)

			input.Request.EthernetPort.PortId.Disabled = ValueBoolPointerFromPlanOrState(plan.EthernetPort.PortId.Disabled, state.EthernetPort.PortId.Disabled)

			input.Request.EthernetPort.PortId.DisabledReason = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.DisabledReason, state.EthernetPort.PortId.DisabledReason)

			input.Request.EthernetPort.PortId.ElementId = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.ElementId, state.EthernetPort.PortId.ElementId)

			input.Request.EthernetPort.PortId.Id = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Id, state.EthernetPort.PortId.Id)

			input.Request.EthernetPort.PortId.Inactive = ValueBoolPointerFromPlanOrState(plan.EthernetPort.PortId.Inactive, state.EthernetPort.PortId.Inactive)

			input.Request.EthernetPort.PortId.InactiveReason = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.InactiveReason, state.EthernetPort.PortId.InactiveReason)

			input.Request.EthernetPort.PortId.MaxMtu = ValueInt64PointerFromPlanOrState(plan.EthernetPort.PortId.MaxMtu, state.EthernetPort.PortId.MaxMtu)

			input.Request.EthernetPort.PortId.MaxSpeed = ValueInt64PointerFromPlanOrState(plan.EthernetPort.PortId.MaxSpeed, state.EthernetPort.PortId.MaxSpeed)

			input.Request.EthernetPort.PortId.Name = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Name, state.EthernetPort.PortId.Name)

			input.Request.EthernetPort.PortId.OriginalMacAddress = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.OriginalMacAddress, state.EthernetPort.PortId.OriginalMacAddress)

			input.Request.EthernetPort.PortId.Region = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortId.Region, state.EthernetPort.PortId.Region)

			input.Request.EthernetPort.PortId.SiteId = ValueStringFromPlanOrState(plan.EthernetPort.PortId.SiteId, state.EthernetPort.PortId.SiteId)
		}

		input.Request.EthernetPort.PortName = ValueStringPointerFromPlanOrState(plan.EthernetPort.PortName, state.EthernetPort.PortName)

		input.Request.EthernetPort.Speed = ValueInt64PointerFromPlanOrState(plan.EthernetPort.Speed, state.EthernetPort.Speed)
	}

	input.Request.InterfaceProfileId = ValueStringPointerFromPlanOrState(plan.InterfaceProfileId, state.InterfaceProfileId)

	input.Request.IpfixcollectorcontextId = ValueStringPointerFromPlanOrState(plan.IpfixcollectorcontextId, state.IpfixcollectorcontextId)

	input.Request.IpfixfiltercontextId = ValueStringPointerFromPlanOrState(plan.IpfixfiltercontextId, state.IpfixfiltercontextId)

	if plan.Ipv4Config != nil {
		input.Request.Ipv4Config = &wsoFfyL.Config{}

		if plan.Ipv4Config.DhcpConfig != nil {
			input.Request.Ipv4Config.DhcpConfig = &rKcwmLF.Config{}

			input.Request.Ipv4Config.DhcpConfig.ClientId = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpConfig.ClientId, state.Ipv4Config.DhcpConfig.ClientId)

			input.Request.Ipv4Config.DhcpConfig.Hostname = ValueStringPointerFromPlanOrState(plan.Ipv4Config.DhcpConfig.Hostname, state.Ipv4Config.DhcpConfig.Hostname)
		}

		if plan.Ipv4Config.DnsV4Config != nil {
			input.Request.Ipv4Config.DnsV4Config = &mTuoPRe.Config{}

			input.Request.Ipv4Config.DnsV4Config.NameServers = ListStringValueOrNil(ctx, plan.Ipv4Config.DnsV4Config.NameServers)

			input.Request.Ipv4Config.DnsV4Config.Search = ListStringValueOrNil(ctx, plan.Ipv4Config.DnsV4Config.Search)
		}

		if plan.Ipv4Config.PppoeConfig != nil {
			input.Request.Ipv4Config.PppoeConfig = &cvAyZuw.Config{}

			input.Request.Ipv4Config.PppoeConfig.ChapPasswd = ValueStringPointerFromPlanOrState(plan.Ipv4Config.PppoeConfig.ChapPasswd, state.Ipv4Config.PppoeConfig.ChapPasswd)

			input.Request.Ipv4Config.PppoeConfig.ChapUser = ValueStringPointerFromPlanOrState(plan.Ipv4Config.PppoeConfig.ChapUser, state.Ipv4Config.PppoeConfig.ChapUser)

			input.Request.Ipv4Config.PppoeConfig.SetRoute = ValueBoolPointerFromPlanOrState(plan.Ipv4Config.PppoeConfig.SetRoute, state.Ipv4Config.PppoeConfig.SetRoute)
		}

		if len(plan.Ipv4Config.Routes) != 0 || len(state.Ipv4Config.Routes) != 0 {
			Ipv4ConfigRoutesToUse := plan.Ipv4Config.Routes
			if len(plan.Ipv4Config.Routes) == 0 {
				Ipv4ConfigRoutesToUse = state.Ipv4Config.Routes
			}
			input.Request.Ipv4Config.Routes = make([]bBEnHsN.Config, 0, len(Ipv4ConfigRoutesToUse))
			for _, var6 := range plan.Ipv4Config.Routes {
				var var7 bBEnHsN.Config

				var7.Destination = StringValueOrNil(var6.Destination)

				var7.Via = StringValueOrNil(var6.Via)
				input.Request.Ipv4Config.Routes = append(input.Request.Ipv4Config.Routes, var7)
			}
		}

		if plan.Ipv4Config.StaticConfig != nil {
			input.Request.Ipv4Config.StaticConfig = &nfiOrAO.Config{}

			input.Request.Ipv4Config.StaticConfig.Address = ValueStringPointerFromPlanOrState(plan.Ipv4Config.StaticConfig.Address, state.Ipv4Config.StaticConfig.Address)
		}

		input.Request.Ipv4Config.Type = ValueStringPointerFromPlanOrState(plan.Ipv4Config.Type, state.Ipv4Config.Type)
	}

	if plan.Ipv6Config != nil {
		input.Request.Ipv6Config = &bMGDwkY.Config{}

		if plan.Ipv6Config.DhcpConfig != nil {
			input.Request.Ipv6Config.DhcpConfig = &juuQHdk.Config{}

			input.Request.Ipv6Config.DhcpConfig.ClientId = ValueStringPointerFromPlanOrState(plan.Ipv6Config.DhcpConfig.ClientId, state.Ipv6Config.DhcpConfig.ClientId)

			input.Request.Ipv6Config.DhcpConfig.Hostname = ValueStringPointerFromPlanOrState(plan.Ipv6Config.DhcpConfig.Hostname, state.Ipv6Config.DhcpConfig.Hostname)
		}

		if plan.Ipv6Config.DnsV6Config != nil {
			input.Request.Ipv6Config.DnsV6Config = &mTuoPRe.Config{}

			input.Request.Ipv6Config.DnsV6Config.NameServers = ListStringValueOrNil(ctx, plan.Ipv6Config.DnsV6Config.NameServers)

			input.Request.Ipv6Config.DnsV6Config.Search = ListStringValueOrNil(ctx, plan.Ipv6Config.DnsV6Config.Search)
		}

		if len(plan.Ipv6Config.Routes) != 0 || len(state.Ipv6Config.Routes) != 0 {
			Ipv6ConfigRoutesToUse := plan.Ipv6Config.Routes
			if len(plan.Ipv6Config.Routes) == 0 {
				Ipv6ConfigRoutesToUse = state.Ipv6Config.Routes
			}
			input.Request.Ipv6Config.Routes = make([]bBEnHsN.Config, 0, len(Ipv6ConfigRoutesToUse))
			for _, var10 := range plan.Ipv6Config.Routes {
				var var11 bBEnHsN.Config

				var11.Destination = StringValueOrNil(var10.Destination)

				var11.Via = StringValueOrNil(var10.Via)
				input.Request.Ipv6Config.Routes = append(input.Request.Ipv6Config.Routes, var11)
			}
		}

		if plan.Ipv6Config.StaticConfig != nil {
			input.Request.Ipv6Config.StaticConfig = &lIDFRUy.Config{}

			input.Request.Ipv6Config.StaticConfig.Address = ValueStringPointerFromPlanOrState(plan.Ipv6Config.StaticConfig.Address, state.Ipv6Config.StaticConfig.Address)

			input.Request.Ipv6Config.StaticConfig.EnablePrefixDistribution = ValueBoolPointerFromPlanOrState(plan.Ipv6Config.StaticConfig.EnablePrefixDistribution, state.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}

		input.Request.Ipv6Config.Type = ValueStringPointerFromPlanOrState(plan.Ipv6Config.Type, state.Ipv6Config.Type)
	}

	input.Request.LldpEnabled = ValueBoolPointerFromPlanOrState(plan.LldpEnabled, state.LldpEnabled)

	input.Request.MacAddress = ValueStringPointerFromPlanOrState(plan.MacAddress, state.MacAddress)

	input.Request.Mtu = ValueInt64PointerFromPlanOrState(plan.Mtu, state.Mtu)

	if plan.MulticastConfig != nil {
		input.Request.MulticastConfig = &zLXjrfn.Config{}

		input.Request.MulticastConfig.IgmpVersion = ValueStringPointerFromPlanOrState(plan.MulticastConfig.IgmpVersion, state.MulticastConfig.IgmpVersion)

		input.Request.MulticastConfig.MulticastEnabled = ValueBoolPointerFromPlanOrState(plan.MulticastConfig.MulticastEnabled, state.MulticastConfig.MulticastEnabled)
	}

	input.Request.Name = ValueStringPointerFromPlanOrState(plan.Name, state.Name)

	input.Request.NatAddress = ValueStringPointerFromPlanOrState(plan.NatAddress, state.NatAddress)

	input.Request.NatAddressV6 = ValueStringPointerFromPlanOrState(plan.NatAddressV6, state.NatAddressV6)

	if len(plan.NatPools) != 0 || len(state.NatPools) != 0 {
		NatPoolsToUse := plan.NatPools
		if len(plan.NatPools) == 0 {
			NatPoolsToUse = state.NatPools
		}
		input.Request.NatPools = make([]alJfwdK.Config, 0, len(NatPoolsToUse))
		for _, var12 := range plan.NatPools {
			var var13 alJfwdK.Config

			if len(var12.Ipv4Ranges) != 0 {
				var13.Ipv4Ranges = make([]xYviIkG.Config, 0, len(var12.Ipv4Ranges))
				for _, var14 := range var12.Ipv4Ranges {
					var var15 xYviIkG.Config

					var15.End = StringValue(var14.End)

					var15.Start = StringValue(var14.Start)
					var13.Ipv4Ranges = append(var13.Ipv4Ranges, var15)
				}
			}

			var13.NatPoolId = StringValueOrNil(var12.NatPoolId)
			input.Request.NatPools = append(input.Request.NatPools, var13)
		}
	}

	input.Request.NatPort = ValueInt64PointerFromPlanOrState(plan.NatPort, state.NatPort)

	input.Request.NatPortV6 = ValueInt64PointerFromPlanOrState(plan.NatPortV6, state.NatPortV6)

	input.Request.NatZoneId = ValueStringPointerFromPlanOrState(plan.NatZoneId, state.NatZoneId)

	input.Request.NetworkContextId = ValueStringPointerFromPlanOrState(plan.NetworkContextId, state.NetworkContextId)

	input.Request.Parent = ValueStringPointerFromPlanOrState(plan.Parent, state.Parent)

	input.Request.PeerBypasspairWanPortType = ValueStringFromPlanOrState(plan.PeerBypasspairWanPortType, state.PeerBypasspairWanPortType)

	input.Request.PoeEnabled = ValueBoolPointerFromPlanOrState(plan.PoeEnabled, state.PoeEnabled)

	input.Request.PowerUsageThreshold = ValueInt64PointerFromPlanOrState(plan.PowerUsageThreshold, state.PowerUsageThreshold)

	if plan.PppoeConfig != nil {
		input.Request.PppoeConfig = &yxxGXUe.Config{}

		input.Request.PppoeConfig.HostUniq = ValueStringPointerFromPlanOrState(plan.PppoeConfig.HostUniq, state.PppoeConfig.HostUniq)

		input.Request.PppoeConfig.IpAddressType = ValueStringPointerFromPlanOrState(plan.PppoeConfig.IpAddressType, state.PppoeConfig.IpAddressType)

		input.Request.PppoeConfig.Password = ValueStringPointerFromPlanOrState(plan.PppoeConfig.Password, state.PppoeConfig.Password)

		input.Request.PppoeConfig.ReconnectionDelay = ValueInt64PointerFromPlanOrState(plan.PppoeConfig.ReconnectionDelay, state.PppoeConfig.ReconnectionDelay)

		input.Request.PppoeConfig.ServiceName = ValueStringPointerFromPlanOrState(plan.PppoeConfig.ServiceName, state.PppoeConfig.ServiceName)

		input.Request.PppoeConfig.Username = ValueStringPointerFromPlanOrState(plan.PppoeConfig.Username, state.PppoeConfig.Username)
	}

	input.Request.Scope = ValueStringFromPlanOrState(plan.Scope, state.Scope)

	if len(plan.SecondaryIpConfigs) != 0 || len(state.SecondaryIpConfigs) != 0 {
		SecondaryIpConfigsToUse := plan.SecondaryIpConfigs
		if len(plan.SecondaryIpConfigs) == 0 {
			SecondaryIpConfigsToUse = state.SecondaryIpConfigs
		}
		input.Request.SecondaryIpConfigs = make([]jmyEuEW.Config, 0, len(SecondaryIpConfigsToUse))
		for _, var16 := range plan.SecondaryIpConfigs {
			var var17 jmyEuEW.Config

			var17.Ipv4Address = StringValueOrNil(var16.Ipv4Address)

			var17.Scope = StringValueOrNil(var16.Scope)
			input.Request.SecondaryIpConfigs = append(input.Request.SecondaryIpConfigs, var17)
		}
	}

	if plan.ServiceLinkConfig != nil {
		input.Request.ServiceLinkConfig = &obJkRYB.Config{}

		if plan.ServiceLinkConfig.GreConfig != nil {
			input.Request.ServiceLinkConfig.GreConfig = &suSmnCD.Config{}

			input.Request.ServiceLinkConfig.GreConfig.Csum = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.Csum, state.ServiceLinkConfig.GreConfig.Csum)

			input.Request.ServiceLinkConfig.GreConfig.KeepaliveEnable = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.KeepaliveEnable, state.ServiceLinkConfig.GreConfig.KeepaliveEnable)

			input.Request.ServiceLinkConfig.GreConfig.KeepaliveFailCount = ValueInt64PointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.KeepaliveFailCount, state.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

			input.Request.ServiceLinkConfig.GreConfig.KeepaliveInterval = ValueInt64PointerFromPlanOrState(plan.ServiceLinkConfig.GreConfig.KeepaliveInterval, state.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}

		if plan.ServiceLinkConfig.IpsecConfig != nil {
			input.Request.ServiceLinkConfig.IpsecConfig = &nnsRzDg.Config{}

			if plan.ServiceLinkConfig.IpsecConfig.Authentication != nil {
				input.Request.ServiceLinkConfig.IpsecConfig.Authentication = &xdEvbZX.Config{}

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Certificate, state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId, state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Comment = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Comment, state.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

				if plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params != nil {
					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &mKyPIKy.Config{}

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = ValueStringFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType, state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = ValueStringFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalId, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId, state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId, state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase, state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck, state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch, state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey, state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate, state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId, state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Secret = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Secret, state.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash, state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse, state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

				input.Request.ServiceLinkConfig.IpsecConfig.Authentication.Type = ValueStringFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.Type, state.ServiceLinkConfig.IpsecConfig.Authentication.Type)

				if plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects != nil {
					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &qSUpByF.Config{}

					if !plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder.IsNull() && plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder.ValueBool() {
						input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = map[string]interface{}{}
					}

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

					if !plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair.IsNull() && plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair.ValueBool() {
						input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = map[string]interface{}{}
					}

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

					resp.Diagnostics.Append(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet.ElementsAs(ctx, &input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet, false)...)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

					input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate, state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

					resp.Diagnostics.Append(plan.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet.ElementsAs(ctx, &input.Request.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet, false)...)
				}
			}

			input.Request.ServiceLinkConfig.IpsecConfig.IpsecProfileId = ValueStringFromPlanOrState(plan.ServiceLinkConfig.IpsecConfig.IpsecProfileId, state.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}

		input.Request.ServiceLinkConfig.LastParent = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.LastParent, state.ServiceLinkConfig.LastParent)

		input.Request.ServiceLinkConfig.Parent = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.Parent, state.ServiceLinkConfig.Parent)

		if plan.ServiceLinkConfig.PassiveMode != nil {
			input.Request.ServiceLinkConfig.PassiveMode = &wiUYuNU.Config{}

			input.Request.ServiceLinkConfig.PassiveMode.Enable = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.PassiveMode.Enable, state.ServiceLinkConfig.PassiveMode.Enable)

			input.Request.ServiceLinkConfig.PassiveMode.PeerIpDynamic = ValueBoolPointerFromPlanOrState(plan.ServiceLinkConfig.PassiveMode.PeerIpDynamic, state.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}

		if plan.ServiceLinkConfig.Peer != nil {
			input.Request.ServiceLinkConfig.Peer = &pjMVEcr.Config{}

			input.Request.ServiceLinkConfig.Peer.Hostname = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.Peer.Hostname, state.ServiceLinkConfig.Peer.Hostname)

			input.Request.ServiceLinkConfig.Peer.IpAddresses = ListStringValueOrNil(ctx, plan.ServiceLinkConfig.Peer.IpAddresses)
		}

		input.Request.ServiceLinkConfig.ServiceEndpointId = ValueStringPointerFromPlanOrState(plan.ServiceLinkConfig.ServiceEndpointId, state.ServiceLinkConfig.ServiceEndpointId)

		input.Request.ServiceLinkConfig.Type = ValueStringFromPlanOrState(plan.ServiceLinkConfig.Type, state.ServiceLinkConfig.Type)
	}

	input.Request.SiteWanInterfaceIds = ListStringValueOrNil(ctx, plan.SiteWanInterfaceIds)

	if len(plan.StaticArpConfigs) != 0 || len(state.StaticArpConfigs) != 0 {
		StaticArpConfigsToUse := plan.StaticArpConfigs
		if len(plan.StaticArpConfigs) == 0 {
			StaticArpConfigsToUse = state.StaticArpConfigs
		}
		input.Request.StaticArpConfigs = make([]pWDbfYi.Config, 0, len(StaticArpConfigsToUse))
		for _, var22 := range plan.StaticArpConfigs {
			var var23 pWDbfYi.Config

			var23.Ipv4Address = StringValueOrNil(var22.Ipv4Address)

			var23.MacAddress = StringValueOrNil(var22.MacAddress)
			input.Request.StaticArpConfigs = append(input.Request.StaticArpConfigs, var23)
		}
	}

	if plan.SubInterface != nil {
		input.Request.SubInterface = &jEYlBbY.Config{}

		input.Request.SubInterface.VlanId = ValueInt64PointerFromPlanOrState(plan.SubInterface.VlanId, state.SubInterface.VlanId)
	}

	if plan.SwitchPortConfig != nil {
		input.Request.SwitchPortConfig = &kslrKbF.Config{}

		input.Request.SwitchPortConfig.AccessVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.AccessVlanId, state.SwitchPortConfig.AccessVlanId)

		input.Request.SwitchPortConfig.BpduGuardEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.BpduGuardEnabled, state.SwitchPortConfig.BpduGuardEnabled)

		input.Request.SwitchPortConfig.ForwardFastEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.ForwardFastEnabled, state.SwitchPortConfig.ForwardFastEnabled)

		input.Request.SwitchPortConfig.NativeVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.NativeVlanId, state.SwitchPortConfig.NativeVlanId)

		input.Request.SwitchPortConfig.RootGuardEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.RootGuardEnabled, state.SwitchPortConfig.RootGuardEnabled)

		if plan.SwitchPortConfig.StormControlConfig != nil {
			input.Request.SwitchPortConfig.StormControlConfig = &qhDZEMT.Config{}

			input.Request.SwitchPortConfig.StormControlConfig.BroadcastThreshold = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StormControlConfig.BroadcastThreshold, state.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

			input.Request.SwitchPortConfig.StormControlConfig.MulticastThreshold = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StormControlConfig.MulticastThreshold, state.SwitchPortConfig.StormControlConfig.MulticastThreshold)

			input.Request.SwitchPortConfig.StormControlConfig.UnicastThreshold = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StormControlConfig.UnicastThreshold, state.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}

		input.Request.SwitchPortConfig.StpPortCost = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StpPortCost, state.SwitchPortConfig.StpPortCost)

		input.Request.SwitchPortConfig.StpPortEnabled = ValueBoolPointerFromPlanOrState(plan.SwitchPortConfig.StpPortEnabled, state.SwitchPortConfig.StpPortEnabled)

		input.Request.SwitchPortConfig.StpPortPriority = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.StpPortPriority, state.SwitchPortConfig.StpPortPriority)

		input.Request.SwitchPortConfig.TrunkVlans = ListStringValueOrNil(ctx, plan.SwitchPortConfig.TrunkVlans)

		input.Request.SwitchPortConfig.VlanMode = ValueStringFromPlanOrState(plan.SwitchPortConfig.VlanMode, state.SwitchPortConfig.VlanMode)

		input.Request.SwitchPortConfig.VoiceVlanId = ValueInt64PointerFromPlanOrState(plan.SwitchPortConfig.VoiceVlanId, state.SwitchPortConfig.VoiceVlanId)
	}

	input.Request.Tags = ListStringValueOrNil(ctx, plan.Tags)

	input.Request.Type = ValueStringFromPlanOrState(plan.Type, state.Type)

	input.Request.UsedFor = ValueStringFromPlanOrState(plan.UsedFor, state.UsedFor)

	if plan.VlanConfig != nil {
		input.Request.VlanConfig = &aCdiNxV.Config{}

		input.Request.VlanConfig.MstpInstance = ValueInt64PointerFromPlanOrState(plan.VlanConfig.MstpInstance, state.VlanConfig.MstpInstance)

		input.Request.VlanConfig.VlanId = ValueInt64PointerFromPlanOrState(plan.VlanConfig.VlanId, state.VlanConfig.VlanId)

		input.Request.VlanConfig.VoiceEnabled = ValueBoolPointerFromPlanOrState(plan.VlanConfig.VoiceEnabled, state.VlanConfig.VoiceEnabled)
	}

	input.Request.VrfContextId = ValueStringPointerFromPlanOrState(plan.VrfContextId, state.VrfContextId)

	// Perform the operation.
	ans, err := svc.Update(ctx, input)
	if err != nil {
		if IsObjectNotFound(err) {
			resp.State.RemoveResource(ctx)
		} else {
			resp.Diagnostics.AddError("Error updating resource", err.Error())
		}
		return
	}

	// Store the answer to state.
	// Note: when supporting importing a resource, this will need to change to taking
	// values from the savestate.Tfid param and locMap.

	state.AdminUp = types.BoolPointerValue(ans.AdminUp)

	if len(ans.AttachedLanNetworks) == 0 {
		state.AttachedLanNetworks = nil
	} else {
		state.AttachedLanNetworks = make([]interfaceRsModel_irQawLY_Config, 0, len(ans.AttachedLanNetworks))
		for _, var26 := range ans.AttachedLanNetworks {
			var27 := interfaceRsModel_irQawLY_Config{}

			var27.LanNetworkId = types.StringPointerValue(var26.LanNetworkId)

			var27.VlanId = types.Int64PointerValue(var26.VlanId)
			state.AttachedLanNetworks = append(state.AttachedLanNetworks, var27)
		}
	}

	if ans.AuthenticationConfig == nil {
		state.AuthenticationConfig = nil
	} else {
		state.AuthenticationConfig = &interfaceRsModel_mIAatvm_Config{}

		state.AuthenticationConfig.FallbackRetryCount = types.Int64PointerValue(ans.AuthenticationConfig.FallbackRetryCount)

		state.AuthenticationConfig.Mode = types.StringPointerValue(ans.AuthenticationConfig.Mode)

		state.AuthenticationConfig.ReauthenticationTimeout = types.Int64PointerValue(ans.AuthenticationConfig.ReauthenticationTimeout)
	}

	var28, var29 := types.ListValueFrom(ctx, types.StringType, ans.BoundInterfaces)
	state.BoundInterfaces = var28
	resp.Diagnostics.Append(var29.Errors()...)

	if ans.BypassPair == nil {
		state.BypassPair = nil
	} else {
		state.BypassPair = &interfaceRsModel_zGfKFAQ_Config{}

		state.BypassPair.Lan = types.StringPointerValue(ans.BypassPair.Lan)

		state.BypassPair.LanStatePropagation = types.BoolPointerValue(ans.BypassPair.LanStatePropagation)

		state.BypassPair.UseRelay = types.BoolPointerValue(ans.BypassPair.UseRelay)

		state.BypassPair.Wan = types.StringPointerValue(ans.BypassPair.Wan)
	}

	if ans.CellularConfig == nil {
		state.CellularConfig = nil
	} else {
		state.CellularConfig = &interfaceRsModel_eumQbRC_Config{}

		if ans.CellularConfig.ApnConfig == nil {
			state.CellularConfig.ApnConfig = nil
		} else {
			state.CellularConfig.ApnConfig = &interfaceRsModel_aeWshcf_Config{}

			state.CellularConfig.ApnConfig.Apn = types.StringPointerValue(ans.CellularConfig.ApnConfig.Apn)

			state.CellularConfig.ApnConfig.Authentication = types.StringValue(ans.CellularConfig.ApnConfig.Authentication)

			state.CellularConfig.ApnConfig.ClearPassword = types.BoolPointerValue(ans.CellularConfig.ApnConfig.ClearPassword)

			state.CellularConfig.ApnConfig.Password = types.StringPointerValue(ans.CellularConfig.ApnConfig.Password)

			state.CellularConfig.ApnConfig.PasswordEncrypted = types.StringPointerValue(ans.CellularConfig.ApnConfig.PasswordEncrypted)

			state.CellularConfig.ApnConfig.UserName = types.StringPointerValue(ans.CellularConfig.ApnConfig.UserName)
		}

		state.CellularConfig.ApnprofileId = types.StringPointerValue(ans.CellularConfig.ApnprofileId)

		state.CellularConfig.AutoApn = types.BoolPointerValue(ans.CellularConfig.AutoApn)

		state.CellularConfig.ParentModuleId = types.StringPointerValue(ans.CellularConfig.ParentModuleId)

		state.CellularConfig.ParentSimSlotNumber = types.Int64PointerValue(ans.CellularConfig.ParentSimSlotNumber)
	}

	state.Description = types.StringPointerValue(ans.Description)

	state.DevicemgmtPolicysetstackId = types.StringPointerValue(ans.DevicemgmtPolicysetstackId)

	if ans.DhcpRelay == nil {
		state.DhcpRelay = nil
	} else {
		state.DhcpRelay = &interfaceRsModel_mCcgFKg_Config{}

		state.DhcpRelay.Enabled = types.BoolPointerValue(ans.DhcpRelay.Enabled)

		if ans.DhcpRelay.Option82 == nil {
			state.DhcpRelay.Option82 = nil
		} else {
			state.DhcpRelay.Option82 = &interfaceRsModel_tOChZgD_Config{}

			state.DhcpRelay.Option82.CircuitId = types.StringPointerValue(ans.DhcpRelay.Option82.CircuitId)

			state.DhcpRelay.Option82.Enabled = types.BoolPointerValue(ans.DhcpRelay.Option82.Enabled)

			state.DhcpRelay.Option82.ReforwardingPolicy = types.StringValue(ans.DhcpRelay.Option82.ReforwardingPolicy)

			state.DhcpRelay.Option82.RemoteId = types.StringPointerValue(ans.DhcpRelay.Option82.RemoteId)
		}

		var30, var31 := types.ListValueFrom(ctx, types.StringType, ans.DhcpRelay.ServerIps)
		state.DhcpRelay.ServerIps = var30
		resp.Diagnostics.Append(var31.Errors()...)

		state.DhcpRelay.SourceInterface = types.StringPointerValue(ans.DhcpRelay.SourceInterface)
	}

	state.DirectedBroadcast = types.BoolPointerValue(ans.DirectedBroadcast)

	state.Etag = types.Int64PointerValue(ans.Etag)

	if ans.EthernetPort == nil {
		state.EthernetPort = nil
	} else {
		state.EthernetPort = &interfaceRsModel_ehJLagQ_Config{}

		state.EthernetPort.FullDuplex = types.BoolPointerValue(ans.EthernetPort.FullDuplex)

		if ans.EthernetPort.PortId == nil {
			state.EthernetPort.PortId = nil
		} else {
			state.EthernetPort.PortId = &interfaceRsModel_ujXZojh_Config{}

			state.EthernetPort.PortId.Connector = types.StringPointerValue(ans.EthernetPort.PortId.Connector)

			state.EthernetPort.PortId.Device = types.StringPointerValue(ans.EthernetPort.PortId.Device)

			state.EthernetPort.PortId.Disabled = types.BoolPointerValue(ans.EthernetPort.PortId.Disabled)

			state.EthernetPort.PortId.DisabledReason = types.StringPointerValue(ans.EthernetPort.PortId.DisabledReason)

			state.EthernetPort.PortId.ElementId = types.StringPointerValue(ans.EthernetPort.PortId.ElementId)

			state.EthernetPort.PortId.Id = types.StringPointerValue(ans.EthernetPort.PortId.Id)

			state.EthernetPort.PortId.Inactive = types.BoolPointerValue(ans.EthernetPort.PortId.Inactive)

			state.EthernetPort.PortId.InactiveReason = types.StringPointerValue(ans.EthernetPort.PortId.InactiveReason)

			state.EthernetPort.PortId.MaxMtu = types.Int64PointerValue(ans.EthernetPort.PortId.MaxMtu)

			state.EthernetPort.PortId.MaxSpeed = types.Int64PointerValue(ans.EthernetPort.PortId.MaxSpeed)

			state.EthernetPort.PortId.Name = types.StringPointerValue(ans.EthernetPort.PortId.Name)

			state.EthernetPort.PortId.OriginalMacAddress = types.StringPointerValue(ans.EthernetPort.PortId.OriginalMacAddress)

			state.EthernetPort.PortId.Region = types.StringPointerValue(ans.EthernetPort.PortId.Region)

			state.EthernetPort.PortId.SiteId = types.StringValue(ans.EthernetPort.PortId.SiteId)
		}

		state.EthernetPort.PortName = types.StringPointerValue(ans.EthernetPort.PortName)

		state.EthernetPort.Speed = types.Int64PointerValue(ans.EthernetPort.Speed)
	}

	state.Id = types.StringPointerValue(ans.Id)

	state.InterfaceProfileId = types.StringPointerValue(ans.InterfaceProfileId)

	state.IpfixcollectorcontextId = types.StringPointerValue(ans.IpfixcollectorcontextId)

	state.IpfixfiltercontextId = types.StringPointerValue(ans.IpfixfiltercontextId)

	if ans.Ipv4Config == nil {
		state.Ipv4Config = nil
	} else {
		state.Ipv4Config = &interfaceRsModel_wsoFfyL_Config{}

		if ans.Ipv4Config.DhcpConfig == nil {
			state.Ipv4Config.DhcpConfig = nil
		} else {
			state.Ipv4Config.DhcpConfig = &interfaceRsModel_rKcwmLF_Config{}

			state.Ipv4Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.ClientId)

			state.Ipv4Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv4Config.DhcpConfig.Hostname)
		}

		if ans.Ipv4Config.DnsV4Config == nil {
			state.Ipv4Config.DnsV4Config = nil
		} else {
			state.Ipv4Config.DnsV4Config = &interfaceRsModel_mTuoPRe_Config{}

			var32, var33 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.NameServers)
			state.Ipv4Config.DnsV4Config.NameServers = var32
			resp.Diagnostics.Append(var33.Errors()...)

			var34, var35 := types.ListValueFrom(ctx, types.StringType, ans.Ipv4Config.DnsV4Config.Search)
			state.Ipv4Config.DnsV4Config.Search = var34
			resp.Diagnostics.Append(var35.Errors()...)
		}

		if ans.Ipv4Config.PppoeConfig == nil {
			state.Ipv4Config.PppoeConfig = nil
		} else {
			state.Ipv4Config.PppoeConfig = &interfaceRsModel_cvAyZuw_Config{}

			state.Ipv4Config.PppoeConfig.ChapPasswd = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapPasswd)

			state.Ipv4Config.PppoeConfig.ChapUser = types.StringPointerValue(ans.Ipv4Config.PppoeConfig.ChapUser)

			state.Ipv4Config.PppoeConfig.SetRoute = types.BoolPointerValue(ans.Ipv4Config.PppoeConfig.SetRoute)
		}

		if len(ans.Ipv4Config.Routes) == 0 {
			state.Ipv4Config.Routes = nil
		} else {
			state.Ipv4Config.Routes = make([]interfaceRsModel_bBEnHsN_Config, 0, len(ans.Ipv4Config.Routes))
			for _, var36 := range ans.Ipv4Config.Routes {
				var37 := interfaceRsModel_bBEnHsN_Config{}

				var37.Destination = types.StringPointerValue(var36.Destination)

				var37.Via = types.StringPointerValue(var36.Via)
				state.Ipv4Config.Routes = append(state.Ipv4Config.Routes, var37)
			}
		}

		if ans.Ipv4Config.StaticConfig == nil {
			state.Ipv4Config.StaticConfig = nil
		} else {
			state.Ipv4Config.StaticConfig = &interfaceRsModel_nfiOrAO_Config{}

			state.Ipv4Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv4Config.StaticConfig.Address)
		}

		state.Ipv4Config.Type = types.StringPointerValue(ans.Ipv4Config.Type)
	}

	if ans.Ipv6Config == nil {
		state.Ipv6Config = nil
	} else {
		state.Ipv6Config = &interfaceRsModel_bMGDwkY_Config{}

		if ans.Ipv6Config.DhcpConfig == nil {
			state.Ipv6Config.DhcpConfig = nil
		} else {
			state.Ipv6Config.DhcpConfig = &interfaceRsModel_juuQHdk_Config{}

			state.Ipv6Config.DhcpConfig.ClientId = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.ClientId)

			state.Ipv6Config.DhcpConfig.Hostname = types.StringPointerValue(ans.Ipv6Config.DhcpConfig.Hostname)
		}

		if ans.Ipv6Config.DnsV6Config == nil {
			state.Ipv6Config.DnsV6Config = nil
		} else {
			state.Ipv6Config.DnsV6Config = &interfaceRsModel_mTuoPRe_Config{}

			var38, var39 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.NameServers)
			state.Ipv6Config.DnsV6Config.NameServers = var38
			resp.Diagnostics.Append(var39.Errors()...)

			var40, var41 := types.ListValueFrom(ctx, types.StringType, ans.Ipv6Config.DnsV6Config.Search)
			state.Ipv6Config.DnsV6Config.Search = var40
			resp.Diagnostics.Append(var41.Errors()...)
		}

		if len(ans.Ipv6Config.Routes) == 0 {
			state.Ipv6Config.Routes = nil
		} else {
			state.Ipv6Config.Routes = make([]interfaceRsModel_bBEnHsN_Config, 0, len(ans.Ipv6Config.Routes))
			for _, var42 := range ans.Ipv6Config.Routes {
				var43 := interfaceRsModel_bBEnHsN_Config{}

				var43.Destination = types.StringPointerValue(var42.Destination)

				var43.Via = types.StringPointerValue(var42.Via)
				state.Ipv6Config.Routes = append(state.Ipv6Config.Routes, var43)
			}
		}

		if ans.Ipv6Config.StaticConfig == nil {
			state.Ipv6Config.StaticConfig = nil
		} else {
			state.Ipv6Config.StaticConfig = &interfaceRsModel_lIDFRUy_Config{}

			state.Ipv6Config.StaticConfig.Address = types.StringPointerValue(ans.Ipv6Config.StaticConfig.Address)

			state.Ipv6Config.StaticConfig.EnablePrefixDistribution = types.BoolPointerValue(ans.Ipv6Config.StaticConfig.EnablePrefixDistribution)
		}

		state.Ipv6Config.Type = types.StringPointerValue(ans.Ipv6Config.Type)
	}

	state.LldpEnabled = types.BoolPointerValue(ans.LldpEnabled)

	state.MacAddress = types.StringPointerValue(ans.MacAddress)

	state.Mtu = types.Int64PointerValue(ans.Mtu)

	if ans.MulticastConfig == nil {
		state.MulticastConfig = nil
	} else {
		state.MulticastConfig = &interfaceRsModel_zLXjrfn_Config{}

		state.MulticastConfig.IgmpVersion = types.StringPointerValue(ans.MulticastConfig.IgmpVersion)

		state.MulticastConfig.MulticastEnabled = types.BoolPointerValue(ans.MulticastConfig.MulticastEnabled)
	}

	state.Name = types.StringPointerValue(ans.Name)

	state.NatAddress = types.StringPointerValue(ans.NatAddress)

	state.NatAddressV6 = types.StringPointerValue(ans.NatAddressV6)

	if len(ans.NatPools) == 0 {
		state.NatPools = nil
	} else {
		state.NatPools = make([]interfaceRsModel_alJfwdK_Config, 0, len(ans.NatPools))
		for _, var44 := range ans.NatPools {
			var45 := interfaceRsModel_alJfwdK_Config{}

			if len(var44.Ipv4Ranges) == 0 {
				var45.Ipv4Ranges = nil
			} else {
				var45.Ipv4Ranges = make([]interfaceRsModel_xYviIkG_Config, 0, len(var44.Ipv4Ranges))
				for _, var46 := range var44.Ipv4Ranges {
					var47 := interfaceRsModel_xYviIkG_Config{}

					var47.End = types.StringValue(var46.End)

					var47.Start = types.StringValue(var46.Start)
					var45.Ipv4Ranges = append(var45.Ipv4Ranges, var47)
				}
			}

			var45.NatPoolId = types.StringPointerValue(var44.NatPoolId)
			state.NatPools = append(state.NatPools, var45)
		}
	}

	state.NatPort = types.Int64PointerValue(ans.NatPort)

	state.NatPortV6 = types.Int64PointerValue(ans.NatPortV6)

	state.NatZoneId = types.StringPointerValue(ans.NatZoneId)

	state.NetworkContextId = types.StringPointerValue(ans.NetworkContextId)

	state.Parent = types.StringPointerValue(ans.Parent)

	state.PeerBypasspairWanPortType = types.StringValue(ans.PeerBypasspairWanPortType)

	state.PoeEnabled = types.BoolPointerValue(ans.PoeEnabled)

	state.PowerUsageThreshold = types.Int64PointerValue(ans.PowerUsageThreshold)

	if ans.PppoeConfig == nil {
		state.PppoeConfig = nil
	} else {
		state.PppoeConfig = &interfaceRsModel_yxxGXUe_Config{}

		state.PppoeConfig.HostUniq = types.StringPointerValue(ans.PppoeConfig.HostUniq)

		state.PppoeConfig.IpAddressType = types.StringPointerValue(ans.PppoeConfig.IpAddressType)

		state.PppoeConfig.Password = types.StringPointerValue(ans.PppoeConfig.Password)

		state.PppoeConfig.ReconnectionDelay = types.Int64PointerValue(ans.PppoeConfig.ReconnectionDelay)

		state.PppoeConfig.ServiceName = types.StringPointerValue(ans.PppoeConfig.ServiceName)

		state.PppoeConfig.Username = types.StringPointerValue(ans.PppoeConfig.Username)
	}

	state.Scope = types.StringValue(ans.Scope)

	if len(ans.SecondaryIpConfigs) == 0 {
		state.SecondaryIpConfigs = nil
	} else {
		state.SecondaryIpConfigs = make([]interfaceRsModel_jmyEuEW_Config, 0, len(ans.SecondaryIpConfigs))
		for _, var48 := range ans.SecondaryIpConfigs {
			var49 := interfaceRsModel_jmyEuEW_Config{}

			var49.Ipv4Address = types.StringPointerValue(var48.Ipv4Address)

			var49.Scope = types.StringPointerValue(var48.Scope)
			state.SecondaryIpConfigs = append(state.SecondaryIpConfigs, var49)
		}
	}

	if ans.ServiceLinkConfig == nil {
		state.ServiceLinkConfig = nil
	} else {
		state.ServiceLinkConfig = &interfaceRsModel_obJkRYB_Config{}

		if ans.ServiceLinkConfig.GreConfig == nil {
			state.ServiceLinkConfig.GreConfig = nil
		} else {
			state.ServiceLinkConfig.GreConfig = &interfaceRsModel_suSmnCD_Config{}

			state.ServiceLinkConfig.GreConfig.Csum = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.Csum)

			state.ServiceLinkConfig.GreConfig.KeepaliveEnable = types.BoolPointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveEnable)

			state.ServiceLinkConfig.GreConfig.KeepaliveFailCount = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveFailCount)

			state.ServiceLinkConfig.GreConfig.KeepaliveInterval = types.Int64PointerValue(ans.ServiceLinkConfig.GreConfig.KeepaliveInterval)
		}

		if ans.ServiceLinkConfig.IpsecConfig == nil {
			state.ServiceLinkConfig.IpsecConfig = nil
		} else {
			state.ServiceLinkConfig.IpsecConfig = &interfaceRsModel_nnsRzDg_Config{}

			if ans.ServiceLinkConfig.IpsecConfig.Authentication == nil {
				state.ServiceLinkConfig.IpsecConfig.Authentication = nil
			} else {
				state.ServiceLinkConfig.IpsecConfig.Authentication = &interfaceRsModel_xdEvbZX_Config{}

				state.ServiceLinkConfig.IpsecConfig.Authentication.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Certificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.CertificateProfileId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Comment = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Comment)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params = &interfaceRsModel_mKyPIKy_Config{}

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthId)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecret)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretEncrypted)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthSecretHash)

					state.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Ikev1Params.XauthType)
				}

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalIdCustom)

				state.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.LocalPaCertificateId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PaMasterKeyId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Passphrase)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PassphraseEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PeerIdCheck)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PermitPeerIdMismatch)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKey)

				state.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.PrivateKeyEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteCaCertificate)

				state.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.RemoteId)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Secret = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Secret)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretEncrypted)

				state.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.SecretHash)

				state.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.StrictValidationPeerExtendedKeyUse)

				state.ServiceLinkConfig.IpsecConfig.Authentication.Type = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.Type)

				if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects == nil {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = nil
				} else {
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects = &interfaceRsModel_qSUpByF_Config{}

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.CertHolder != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Certificate)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsLocalCaCertSet)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet = types.BoolPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.IsRemoteCaCertSet)

					if ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(true)
					} else {
						state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolPointerValue(nil)
					}
					//state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair = types.BoolValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.KeyPair != nil)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertificate)

					var50, var51 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.LocalCaCertsSet = var50
					resp.Diagnostics.Append(var51.Errors()...)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.Passphrase)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.PrivateKey)

					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate = types.StringPointerValue(ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertificate)

					var52, var53 := types.ListValueFrom(ctx, types.BoolType, ans.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet)
					state.ServiceLinkConfig.IpsecConfig.Authentication.X509Objects.RemoteCaCertsSet = var52
					resp.Diagnostics.Append(var53.Errors()...)
				}
			}

			state.ServiceLinkConfig.IpsecConfig.IpsecProfileId = types.StringValue(ans.ServiceLinkConfig.IpsecConfig.IpsecProfileId)
		}

		state.ServiceLinkConfig.LastParent = types.StringPointerValue(ans.ServiceLinkConfig.LastParent)

		state.ServiceLinkConfig.Parent = types.StringPointerValue(ans.ServiceLinkConfig.Parent)

		if ans.ServiceLinkConfig.PassiveMode == nil {
			state.ServiceLinkConfig.PassiveMode = nil
		} else {
			state.ServiceLinkConfig.PassiveMode = &interfaceRsModel_wiUYuNU_Config{}

			state.ServiceLinkConfig.PassiveMode.Enable = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.Enable)

			state.ServiceLinkConfig.PassiveMode.PeerIpDynamic = types.BoolPointerValue(ans.ServiceLinkConfig.PassiveMode.PeerIpDynamic)
		}

		if ans.ServiceLinkConfig.Peer == nil {
			state.ServiceLinkConfig.Peer = nil
		} else {
			state.ServiceLinkConfig.Peer = &interfaceRsModel_pjMVEcr_Config{}

			state.ServiceLinkConfig.Peer.Hostname = types.StringPointerValue(ans.ServiceLinkConfig.Peer.Hostname)

			var54, var55 := types.ListValueFrom(ctx, types.StringType, ans.ServiceLinkConfig.Peer.IpAddresses)
			state.ServiceLinkConfig.Peer.IpAddresses = var54
			resp.Diagnostics.Append(var55.Errors()...)
		}

		state.ServiceLinkConfig.ServiceEndpointId = types.StringPointerValue(ans.ServiceLinkConfig.ServiceEndpointId)

		state.ServiceLinkConfig.Type = types.StringValue(ans.ServiceLinkConfig.Type)
	}

	var56, var57 := types.ListValueFrom(ctx, types.StringType, ans.SiteWanInterfaceIds)
	state.SiteWanInterfaceIds = var56
	resp.Diagnostics.Append(var57.Errors()...)

	if len(ans.StaticArpConfigs) == 0 {
		state.StaticArpConfigs = nil
	} else {
		state.StaticArpConfigs = make([]interfaceRsModel_pWDbfYi_Config, 0, len(ans.StaticArpConfigs))
		for _, var58 := range ans.StaticArpConfigs {
			var59 := interfaceRsModel_pWDbfYi_Config{}

			var59.Ipv4Address = types.StringPointerValue(var58.Ipv4Address)

			var59.MacAddress = types.StringPointerValue(var58.MacAddress)
			state.StaticArpConfigs = append(state.StaticArpConfigs, var59)
		}
	}

	if ans.SubInterface == nil {
		state.SubInterface = nil
	} else {
		state.SubInterface = &interfaceRsModel_jEYlBbY_Config{}

		state.SubInterface.VlanId = types.Int64PointerValue(ans.SubInterface.VlanId)
	}

	if ans.SwitchPortConfig == nil {
		state.SwitchPortConfig = nil
	} else {
		state.SwitchPortConfig = &interfaceRsModel_kslrKbF_Config{}

		state.SwitchPortConfig.AccessVlanId = types.Int64PointerValue(ans.SwitchPortConfig.AccessVlanId)

		state.SwitchPortConfig.BpduGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.BpduGuardEnabled)

		state.SwitchPortConfig.ForwardFastEnabled = types.BoolPointerValue(ans.SwitchPortConfig.ForwardFastEnabled)

		state.SwitchPortConfig.NativeVlanId = types.Int64PointerValue(ans.SwitchPortConfig.NativeVlanId)

		state.SwitchPortConfig.RootGuardEnabled = types.BoolPointerValue(ans.SwitchPortConfig.RootGuardEnabled)

		if ans.SwitchPortConfig.StormControlConfig == nil {
			state.SwitchPortConfig.StormControlConfig = nil
		} else {
			state.SwitchPortConfig.StormControlConfig = &interfaceRsModel_qhDZEMT_Config{}

			state.SwitchPortConfig.StormControlConfig.BroadcastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.BroadcastThreshold)

			state.SwitchPortConfig.StormControlConfig.MulticastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.MulticastThreshold)

			state.SwitchPortConfig.StormControlConfig.UnicastThreshold = types.Int64PointerValue(ans.SwitchPortConfig.StormControlConfig.UnicastThreshold)
		}

		state.SwitchPortConfig.StpPortCost = types.Int64PointerValue(ans.SwitchPortConfig.StpPortCost)

		state.SwitchPortConfig.StpPortEnabled = types.BoolPointerValue(ans.SwitchPortConfig.StpPortEnabled)

		state.SwitchPortConfig.StpPortPriority = types.Int64PointerValue(ans.SwitchPortConfig.StpPortPriority)

		var60, var61 := types.ListValueFrom(ctx, types.StringType, ans.SwitchPortConfig.TrunkVlans)
		state.SwitchPortConfig.TrunkVlans = var60
		resp.Diagnostics.Append(var61.Errors()...)

		state.SwitchPortConfig.VlanMode = types.StringValue(ans.SwitchPortConfig.VlanMode)

		state.SwitchPortConfig.VoiceVlanId = types.Int64PointerValue(ans.SwitchPortConfig.VoiceVlanId)
	}

	var62, var63 := types.ListValueFrom(ctx, types.StringType, ans.Tags)
	state.Tags = var62
	resp.Diagnostics.Append(var63.Errors()...)

	state.Type = types.StringValue(ans.Type)

	state.UsedFor = types.StringValue(ans.UsedFor)

	if ans.VlanConfig == nil {
		state.VlanConfig = nil
	} else {
		state.VlanConfig = &interfaceRsModel_aCdiNxV_Config{}

		state.VlanConfig.MstpInstance = types.Int64PointerValue(ans.VlanConfig.MstpInstance)

		state.VlanConfig.VlanId = types.Int64PointerValue(ans.VlanConfig.VlanId)

		state.VlanConfig.VoiceEnabled = types.BoolPointerValue(ans.VlanConfig.VoiceEnabled)
	}

	state.VrfContextId = types.StringPointerValue(ans.VrfContextId)

	// Done.
	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}

// Delete performs delete for the struct.
func (r *interfaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var idType types.String
	resp.Diagnostics.Append(req.State.GetAttribute(ctx, path.Root("tfid"), &idType)...)
	if resp.Diagnostics.HasError() {
		return
	}
	tfid := idType.ValueString()
	tokens := strings.Split(tfid, IdSeparator)
	if len(tokens) != 3 {
		resp.Diagnostics.AddError("Error in resource ID format", "Expected 3 tokens")
		return
	}

	// Basic logging.
	tflog.Info(ctx, "performing resource delete", map[string]any{
		"terraform_provider_function": "Delete",
		"resource_name":               "prismasdwan_interface",
		"locMap":                      map[string]int{"element_id": 1, "interface_id": 2, "site_id": 0},
		"tokens":                      tokens,
	})

	svc := aSvnUVk.NewClient(r.client)

	// Prepare input for the API endpoint.
	input := aSvnUVk.DeleteInput{}

	input.SiteId = tokens[0]

	input.ElementId = tokens[1]

	input.InterfaceId = tokens[2]

	// Perform the operation.
	if _, err := svc.Delete(ctx, input); err != nil && !IsObjectNotFound(err) {
		resp.Diagnostics.AddError("Error in delete", err.Error())
	}
}

func (r *interfaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("tfid"), req, resp)
}
